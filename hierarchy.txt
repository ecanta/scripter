using namespace std; using namespace _STD chrono; using Concurrency::parallel_for, this_thread::sleep_for; int __NULL__ = 0; HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE); HANDLE hConsoleInput = GetStdHandle(STD_INPUT_HANDLE); CONSOLE_CURSOR_INFO cursorInfo{ 10, FALSE }; CONSOLE_CURSOR_INFO cursor{ 10, TRUE }; CONSOLE_SCREEN_BUFFER_INFO csbi; static wchar_t charVariable(L); ptrdiff_t GlobalMax(0); const ptrdiff_t GLOBAL_CAP(5e10); bool BOOLALPHA(true); bool PRINTN(true); double CORRECTION_RATIO(1.0); atomic_bool GlobalInterr(false); atomic_bool interrupted(false); atomic_bool computing(false); atomic_bool IsDone(false); atomic_bool RunMonitor(true); condition_variable cv, Cv, MonitorCV; mutex CoutMutex, mtx, MonitorMTX; COORD Min{ 25, 15 }; LARGE_INTEGER ProgramFrequency; struct compost { ptrdiff_t factors; int exp; }; struct divisor { ptrdiff_t DivNumber{ 1 }; ptrdiff_t DivSum{ 1 }; ptrdiff_t DivProduct{ 1 }; wstring Div_pr; }; struct digitRatio { int digitSumRatioNum{}; int digitSumRatioDen{}; int digitProductRatioNum{}; int digitProductRatioDen{}; }; digitRatio items; struct coord { double X; double Y; coord() : X(0), Y(0) {} coord(double _x, double _y) : X(_x), Y(_y) {} coord(COORD _coord) : X(_coord.X), Y(_coord.Y) {} operator COORD() const {} }; enum switchcase { DoSimpleCode , DoComplexCode , DoSimpleFactor , DoComplexFactor , DoCodeFactor , DoAll , DebugSimpleCode , DebugComplexCode , DebugSimpleFactor , DebugComplexFactor , DebugCodeFactor , DebugAll , DebugDigits , DebugDigitsAndCode , DebugDigitsAndFactor, DebugComplete , ConvertCodeInverse , SeriesExpansion , FactorPolynomial , FractElaborator , FactorMatrix , Random , NotAssigned }; switchcase usefree; unordered_map<wstring, switchcase> stringToEnumMap { { L , switchcase::DoSimpleCode }, { L, switchcase::DoComplexCode }, { L , switchcase::DoSimpleFactor }, { L, switchcase::DoComplexFactor }, { L, switchcase::DoCodeFactor }, { L , switchcase::DoAll }, { L , switchcase::DebugSimpleCode }, { L, switchcase::DebugComplexCode }, { L , switchcase::DebugSimpleFactor }, { L, switchcase::DebugComplexFactor }, { L, switchcase::DebugCodeFactor }, { L , switchcase::DebugAll }, { L , switchcase::DebugDigits }, { L, switchcase::DebugDigitsAndCode }, { L, switchcase::DebugDigitsAndFactor }, { L, switchcase::DebugComplete }, { L, switchcase::ConvertCodeInverse }, { L, switchcase::SeriesExpansion }, { L, switchcase::FactorPolynomial }, { L, switchcase::FractElaborator }, { L, switchcase::FactorMatrix }, { L, switchcase::Random } }; unordered_map<switchcase, wstring> enumToStringMap { { switchcase::DoSimpleCode , L }, { switchcase::DoComplexCode , L }, { switchcase::DoSimpleFactor , L }, { switchcase::DoComplexFactor , L }, { switchcase::DoCodeFactor , L }, { switchcase::DoAll , L }, { switchcase::DebugSimpleCode , L }, { switchcase::DebugComplexCode , L }, { switchcase::DebugSimpleFactor , L }, { switchcase::DebugComplexFactor , L }, { switchcase::DebugCodeFactor , L }, { switchcase::DebugAll , L }, { switchcase::DebugDigits , L }, { switchcase::DebugDigitsAndCode , L }, { switchcase::DebugDigitsAndFactor, L }, { switchcase::DebugComplete , L }, { switchcase::ConvertCodeInverse , L }, { switchcase::SeriesExpansion , L }, { switchcase::FactorPolynomial , L }, { switchcase::FractElaborator , L }, { switchcase::FactorMatrix , L }, { switchcase::Random , L } }; unordered_map<wstring, wstring> ConvertFromSuperScript { { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, }; wstring Variables{ L }; using _TENSOR tensor, _TENSOR tensor_t; template<typename T> static bool Smaller(const T& A, const T& B) {} template<typename T> static ptrdiff_t BinarySearch(const tensor<T>& arr, const T target) {} template<typename Ty> class complex { public: Ty RealPart; Ty ImaginaryPart; Ty norm() const {} complex() : RealPart(0), ImaginaryPart(0) {} complex(Ty real) : RealPart(real), ImaginaryPart(0) {} complex(Ty real, Ty imag) : RealPart(real), ImaginaryPart(imag) {} inline complex conjugate() const {} inline complex opposite() const {} complex operator+(complex value) const {} inline complex& operator+=(complex value) {} inline complex& operator++() {} inline complex& operator++(int) {} complex operator-(complex value) const {} inline complex& operator-=(complex value) {} inline complex& operator--() {} inline complex& operator--(int) {} complex operator*(complex value) const {} inline complex& operator*=(complex value) {} complex operator/(complex value) const {} inline complex operator/=(complex value) {} wstring str() const {} friend wostream& operator<<(wostream& os, const complex& obj) {} }; template<typename Ty> static complex<Ty> InitExponentialForm(Ty radius, Ty angle) {} tensor<complex<long double>> Omega; static void FFT(tensor<complex<long double>>& List, bool inverse = false) {} class big { private: tensor<int> Integer; bool sign; long double decimal; void construct(ptrdiff_t param) {} bool compare(const big& A, const big& B) const {} big Add(const big& __This, const big& __Val, bool changesign) const {} big Sub(const big& __This, const big& __Val, bool changesign) const {} big AlgebricOperation1(const big& A, const big& B, bool Sign) const {} big FFT_Multiplication(const big& value) const {} public: template<typename t> t Number() {} big() : sign(false), Integer(0), decimal(0) {} big(int param) : sign(param < 0), Integer(0), decimal(0) {} big(ptrdiff_t param) : sign(param < 0), Integer(0), decimal(0) {} big(double param) : sign(param < 0), Integer(0), decimal(0) {} big(long double param) : sign(param < 0), Integer(0), decimal(0) {} big(tensor<int> Big) : sign(false), Integer(Big), decimal(0) {} big(wstring wstr) : sign(false), Integer(0), decimal(0) {} big& operator=(const big& other) {} inline bool operator==(const big& other) const {} inline bool operator!=(const big& other) const {} bool operator<(const big& other) const {} inline bool operator<=(const big& other) const {} inline bool operator>=(const big& other) const {} inline bool operator>(const big& other) const {} big operator+(const big& value) const {} inline big& operator+=(const big& value) {} inline big& operator++() {} inline big& operator++(int) {} big operator-(const big& value) const {} inline big& operator-=(const big& value) {} inline big& operator--() {} inline big& operator--(int) {} big operator<<(int shift) const {} inline big& operator<<=(int shift) {} big operator>>(int shift) const {} inline big& operator>>=(int shift) {} big operator*(const big& value) const {} inline big& operator*=(const big& value) {} big operator/(const big& value) const {} inline big& operator/=(const big& value) {} big operator%(const big& value) const {} inline big& operator%=(const big& value) {} big operator^(const big& exp) const {} inline big& operator^=(const big& exp) {} inline bool intg() const {} inline big fabs() const {} inline big floor() {} inline big ceil() {} inline big round() {} inline big invert() {} inline int log(int base) {} wostringstream c_str(int precision) const {} inline wstring str() const {} friend wostream& operator<<(wostream& os, const big& obj) {} }; static big pow(big x, int y) {} big LCM(1); static void ClearArea(COORD WinCenter, COORD Dimensions); template<typename T> void GeneralizedHeapify(tensor<T>& arr, int n, int i) {} template<typename T> void GeneralizedHeapSort(tensor<T>& arr) {} static tensor<compost> DecomposeNumber(ptrdiff_t input); class radical { int coefficient; ptrdiff_t Arg; tensor<int> primes; public: radical() : coefficient(0), Arg(1), primes({}) {} radical(int coeff) : coefficient(coeff), Arg(1), primes({}) {} radical(int coeff, int arg) : coefficient(coeff), Arg(1), primes({}) { if (arg < 0) {} normalize(); } radical(int coeff, int arg, bool off) : coefficient(coeff), Arg(abs(arg)), primes({}) { if (arg < 0) {} } int GetCoefficient() const {} void SetCoefficient(int NewCoefficient) {} void IncCoefficient(int increment) {} ptrdiff_t arg() const {} long double approximation() const {} void normalize() {} long double operator+(const radical& other) const {} long double operator-(const radical& other) const {} long double operator/(const radical& other) const {} radical operator*(const radical& other) const {} radical& operator*=(const radical& other) {} bool negative() const {} int len() const {} void write(WORD attrib = 15, bool NoSign = false) const {} }; class RadicalSum { tensor<radical> elements; public: RadicalSum() : elements({}) {} RadicalSum(radical el) : elements({}) {} RadicalSum(tensor<radical> elems) : elements(elems) {} long double approximation() const {} void normalize() {} void NORMALIZE() {} long double operator/(const RadicalSum& other) const {} RadicalSum operator+(const RadicalSum& other) const {} RadicalSum& operator+=(const RadicalSum& other) {} RadicalSum operator-(const RadicalSum& other) const {} RadicalSum& operator-=(const RadicalSum& other) {} RadicalSum operator*(const RadicalSum& other) const {} RadicalSum& operator*=(const RadicalSum& other) {} int len() const {} void write(WORD attrib = 15) const {} }; class RadicalFract { RadicalSum top, bottom; public: RadicalFract() : top(radical(0)), bottom(radical(1)) {} RadicalFract(RadicalSum Top) : top(Top), bottom(radical(1)) {} RadicalFract(RadicalSum Top, RadicalSum Bottom) : top(Top), bottom(Bottom) {} long double approximation() const {} RadicalFract operator+(const RadicalFract& other) const {} RadicalFract& operator+=(const RadicalFract& other) {} RadicalFract operator-(const RadicalFract& other) const {} RadicalFract& operator-=(const RadicalFract& other) {} RadicalFract operator*(const RadicalFract& other) const {} RadicalFract& operator*=(const RadicalFract& other) {} RadicalFract operator/(const RadicalFract& other) const {} RadicalFract& operator/=(const RadicalFract& other) {} void write(WORD wAttribute = 15) const {} }; template<typename T_int = long double>struct MONOMIAL { int degree; T_int coefficient; bool operator == (const MONOMIAL& other) const {} }; template<typename T_int = long double>class monomial { public: T_int coefficient{}; tensor<int> exp; bool operator==(const monomial& other) const {} int degree() const {} bool IsSquare() const {} monomial Root(int order) const {} }; template<typename T_int = long double>class factor : public tensor<monomial<T_int>> { public: factor() {} factor(initializer_list<monomial<T_int>> init): tensor<monomial<T_int>>(init) {} factor(size_t size, const monomial<T_int>& initial_value) {} factor(size_t size) {} factor(tensor<monomial<T_int>> vect) {} void SortByDegree() {} void SortByExponents() {} factor derivate(size_t Vpos) const {} T_int operator()(tensor<long double> params) const {} factor operator()(T_int x, size_t Vpos, int) const; bool operator()(T_int x, size_t Vpos, bool) const {} inline factor neg() const {} inline factor operator-(const factor& other) const; inline factor operator*(const factor& other) const; inline factor& operator-=(const factor& other); inline factor& operator*=(const factor& other); _NODISCARD wstring str(int size = Variables.size()) override {} friend wostream& operator<<(wostream& os, factor& obj) {} }; template<typename T_int = long double>class FACTOR : public tensor<MONOMIAL<T_int>> { public: FACTOR() {} FACTOR(initializer_list<MONOMIAL<T_int>> init): tensor<MONOMIAL<T_int>>(init) {} FACTOR(size_t size, const MONOMIAL<T_int>& initial_value) {} FACTOR(size_t size) {} FACTOR(tensor<MONOMIAL<T_int>> vect) {} void sort() {} void complete(int s) {} FACTOR derivate() const {} T_int operator()(T_int x) const {} inline FACTOR neg() const {} inline FACTOR operator-(const FACTOR& other) const; inline FACTOR operator*(const FACTOR& other) const; inline FACTOR& operator-=(const FACTOR& other); inline FACTOR& operator*=(const FACTOR& other); _NODISCARD wstring str(int size = Variables.size()) override {} friend wostream& operator<<(wostream& os, const FACTOR& obj) {} }; static factor<> ToXV(FACTOR<> vect) {} static FACTOR<> To1V(factor<> vect) {} static wstring CTSuperScript(wchar_t input); static wstring CFSuperScript(wstring script); static wstring ElabExponents(wstring& str); static void DeduceFromExponents(wstring& str); template<typename T_int = long double>class polynomial : public tensor<factor<T_int>> { public: polynomial() {} polynomial(initializer_list<factor<T_int>> init): tensor<factor<T_int>>(init) {} polynomial(size_t size, const factor<T_int>& initial_value) {} polynomial(size_t size) {} polynomial(tensor<factor<T_int>> vect) {} void open() {} void close() {} _NODISCARD wstring str(int size = Variables.size()) override {} friend wostream& operator<<(wostream& os, polynomial& obj) {} }; template<typename T_int = long double>class POLYNOMIAL : public tensor<FACTOR<T_int>> { public: POLYNOMIAL() {} POLYNOMIAL(initializer_list<FACTOR<T_int>> init): tensor<FACTOR<T_int>>(init) {} POLYNOMIAL(size_t size, const FACTOR<T_int>& initial_value) {} POLYNOMIAL(size_t size) {} POLYNOMIAL(tensor<FACTOR<T_int>> vect) {} void open() {} void close() {} _NODISCARD wstring str(int size = Variables.size()) override {} friend wostream& operator<<(wostream& os, const POLYNOMIAL& obj) {} }; static polynomial<> ToXV(POLYNOMIAL<> vect) {} static POLYNOMIAL<> To1V(polynomial<> vect) {} static polynomial<> FromBigToDefault(polynomial<big> BigPolynomial) {} template<typename T_int = long double> static factor<T_int> PolynomialSum(factor<T_int> vect); template<typename T_int = long double> static factor<T_int> PolynomialMultiply(polynomial<T_int> Polynomial); template <class T_int> factor<T_int> factor<T_int>::operator()(T_int x, size_t Vpos, int) const {} template<class T_int> inline factor<T_int> factor<T_int>::operator-(const factor& other) const {} template<class T_int> inline factor<T_int> factor<T_int>::operator*(const factor& other) const {} template<class T_int> inline factor<T_int>& factor<T_int>::operator-=(const factor& other) {} template<class T_int> inline factor<T_int>& factor<T_int>::operator*=(const factor& other) {} template<class T_int> inline FACTOR<T_int> FACTOR<T_int>::operator-(const FACTOR& other) const {} template<class T_int> inline FACTOR<T_int> FACTOR<T_int>::operator*(const FACTOR& other) const {} template<class T_int> inline FACTOR<T_int>& FACTOR<T_int>::operator-=(const FACTOR& other) {} template<class T_int> inline FACTOR<T_int>& FACTOR<T_int>::operator*=(const FACTOR& other) {} template<typename T> T ObjectOperations (wstring& errcode, tensor<T> list, tensor<wstring> ops, wstring disposition = L); template<class T = long double>class Fraction { public: polynomial<T> num, den; Fraction() : num(polynomial<T>{}), den(polynomial<T>{ { { 1, tensor<int>(Variables.size(), 0) } } }) {} Fraction(polynomial<T> numerator) : num(numerator), den(polynomial<T>{}) {} Fraction(polynomial<T> numerator, polynomial<T> denominator) : num(numerator), den(denominator) {} Fraction extend() {} Fraction derivate(size_t Vpos) const {} Fraction operator+(const Fraction& other) const {} Fraction operator+=(const Fraction& other) {} Fraction operator-(const Fraction& other) const {} Fraction operator-=(const Fraction& other) {} Fraction operator*(const Fraction& other) const {} Fraction operator*=(const Fraction& other) {} Fraction invert() {} Fraction operator/(const Fraction& other) const {} Fraction operator/=(const Fraction& other) {} Fraction operator()(T x, size_t Vpos) const {} T operator()(tensor<long double> params) const {} bool operator==(const Fraction& other) const {} wstring str() {} friend wostream& operator<<(wostream& os, const Fraction& obj) {} }; static tensor<Fraction<big>> GetManyFractions (tensor<wstring> numerators, tensor<wstring> denominators, wstring& errcode); class key : public tensor<int> { public: using tensor<int>::tensor; key(tensor<int> val) {} key operator!() {} key operator~() const {} _NODISCARD inline bool operator<(const tensor& other) const override {} _NODISCARD inline bool operator<=(const tensor& other) const override {} _NODISCARD inline bool operator>(const tensor& other) const override {} _NODISCARD inline bool operator>=(const tensor& other) const override {} }; static wstring ConvertEnumToWString(switchcase Enum); static switchcase ConvertWStringToEnum(wstring str); tensor<wstring> commands { L, L , L, L, L , L, L, L , L, L , L, L, L , L, L , L, L, L, L , L, L, L }; class Expression; tensor<Expression> __Expr; class Expression { private: using ReturnedFractionType = big; bool activator; _STD map<key, wstring> terms{ { {}, L } }; tensor<key> lines, lister{ {} }; tensor<COORD> FractionLinesPos; tensor<short> FractionLinesLenght; _STD map<key, COORD> dimensions, positions; public: Expression() : activator(false) {}; Expression& operator=(const Expression& other) {} bool contains(key index) const {} void clean() {} tensor<key> underbranch(key node) const {} void Insert(key where, wstring Num = L, wstring Den = L) {} void Remove(key node) {}; tensor_t PrimeNumbers; _STD map<int, wstring> CalculatedData; struct Console { wstring Text; WORD Attribute{ 15 }; void log() const {} bool operator!=(const Console& other) const {} friend wostream& operator<<(wostream& wos, const Console& T) {} }; class ConsoleStream : public tensor<Console> { public: ConsoleStream() {} ConsoleStream(initializer_list<Console> init) {} ConsoleStream operator+(ConsoleStream other) const {} inline void output() const {} inline void log() {} friend wostream& operator<<(wostream& wos, const ConsoleStream& T) {} }; ConsoleStream ConsoleText; static void SendCtrlPlusMinus(bool plus); static ptrdiff_t intpow(ptrdiff_t base, int exp); template<typename _Ty = long double> class Matrix : public tensor<tensor<_Ty>> { public: Matrix() {} using tensor<tensor<_Ty>>::tensor; int output( COORD SelectedElement = { -1, -1 }, int& extension = __NULL__, WORD Attribute = 15 ) const {} bool input(wstring& errcode) {} void DisplayWith(const Matrix other) const {} void DisplayWith(const Matrix A, const Matrix B) const {} Matrix operator+(const Matrix other) const {} Matrix operator+=(const Matrix other) {} Matrix operator-(const Matrix other) const {} Matrix operator-=(const Matrix other) {} tensor<_Ty> operator*(const tensor<_Ty> vector) const {} Matrix operator*(const _Ty scalar) const {} Matrix& operator*=(const _Ty scalar) {} Matrix operator*(const Matrix other) const {} Matrix& operator*=(const Matrix other) {} template<typename T = _Ty> T det() {} Matrix invert(_Ty det = 0) {} tensor<double> EigenValues() {} Matrix EigenVectors(tensor<double> EigenV = {}) {} }; template<typename T> T EmptyProduct(T shape) {} HDC GHDC; static void DrawLine(int firstX, int firstY, int secondX, int secondY, HPEN Hpen); static void DrawLineToBuffer( HDC hdcmem, HBITMAP hbmem, int firstX, int firstY, int secondX, int secondY, HPEN Hpen ); static void ProjectPoint(tensor<long double> point, int& pointX, int& pointY); static void ProjectAndDrawLine (tensor<long double> start, tensor<long double> end, HPEN Hpen); class Point__ { private: int ScreenX, ScreenY; tensor<long double> Normal; public: long double x, y, z; Point__() : x(0), y(0), z(0), ScreenX(-1), ScreenY(-1), Normal(3) {} Point__(long double _x, long double _y, long double _z) : x(_x), y(_y), z(_z), ScreenX(-1), ScreenY(-1), Normal(3) {} Point__(factor<> funct, long double _x, long double _y) : x(_x), y(_y), z(funct({})), ScreenX(-1), ScreenY(-1), Normal(3) {} Point__(Fraction<> funct, long double _x, long double _y) : x(_x), y(_y), z(funct({})), ScreenX(-1), ScreenY(-1), Normal(3) {} int GetScreenX() {} int GetScreenY() {} tensor<long double> GetNormalVector() const {} bool Void() const {} Point__& operator=(const Point__& other) {} tensor<long double> SetNormalVector(Fraction<> dfx, Fraction<> dfy) {} void Display(int width, COLORREF color) {} void StdDisplay (Fraction<> fx, Fraction<> dfx, Fraction<> dfy, tensor<long double> light) {} }; static void DrawLine(Point__ P1, Point__ P2, HPEN hpen); static void DrawLineToBuffer (HDC hdcmem, HBITMAP hbmem, Point__ P1, Point__ P2, HPEN Hpen); template<typename T> bool isnan(Fraction<T> object) {} template<typename T> bool isnan(Matrix<T> object) {} class NumberData { public: ptrdiff_t number{}; wstring code; int degree{}; wstring expression; tensor<ptrdiff_t> sequence; divisor div; digitRatio digit; strong_ordering operator<=>(const NumberData& other) const {} NumberData() = default; NumberData( ptrdiff_t num, const wstring& c, int deg, const wstring& expr, const tensor<ptrdiff_t>& seq, const divisor& d, const digitRatio& dr ) : number(num), code(c), degree(deg), expression(expr), sequence(seq), div(d), digit(dr) {} void printf() {} }; tensor<wstring> Numbers, Polynomials, Expressions; tensor<tensor<wstring>> GlobalNumerators, GlobalDenominators, GlobalOperators; tensor<tensor<short>> ActionsList; static wstring Handler(wstring test); static size_t Factorial(size_t n); static size_t BinomialCoeff(size_t n, size_t k); static ptrdiff_t Gcd(ptrdiff_t A, ptrdiff_t B); template<typename T> static int Gcd(tensor<T> terms); static void ReassigneEnum(switchcase& option); static void WriteFraction (wstring Num, wstring Den, wstring& command, COORD START = { -1, -1 }); static void PrintPFrame (double deg, int sides, double radius, COORD WinCenter); static void DrawFrame (int arc, double __i, int centerX, int centerY, double DIM); static void DrawCircleSquare(COORD CircleCenter); static void CS_CenterPrinter(); static void CS_CornerPrinter(); static void ProgressBar(long double ratio, double barWidth); static long double WaitingScreen(auto begin, auto end); static wstring GetLine(tensor<wstring>& sugg, bool ShowSuggestions = true); static wstring GetUserNum (wstring txt, ptrdiff_t low, ptrdiff_t high, bool ShowSuggestions); static void SetDebug(wstring message, switchcase& opt, bool& Return, ptrdiff_t& LowerBound, ptrdiff_t& UpperBound, ptrdiff_t& datalenght ); static void MonitorConsoleSize(COORD min, atomic_bool& runMonitor); static void UserInputThread(); static void DrawAxis(HDC hdcmem, HBITMAP hbmem, double pInc, double vInc); static LRESULT CALLBACK WindowProcessor2D( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ); static BOOL CreateGraph(Fraction<> funct = { {}, {} }); static LRESULT CALLBACK WindowProcessor3D( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ); static void Project3DGraph(Fraction<> funct); static bool Prime(ptrdiff_t number); static void PrimeNCalculator(ptrdiff_t max, ptrdiff_t min = 0); static tensor<wstring> Fractioner(wstring polinomial); static tensor<int> DecomposeStrings(wstring Terminal); static wstring Cript(ptrdiff_t input); static wstring FactNumber(ptrdiff_t input); static int ExeStrings(wstring input); static divisor DivisorCalculator(wstring factor); static digitRatio DigitRationalizer(ptrdiff_t inpt); static tensor<int> DivisorCounter(int num); static NumberData ExecuteSimpledeg(ptrdiff_t input); static NumberData ExecuteDegree(ptrdiff_t input); static NumberData ExecuteSimpleFact(ptrdiff_t input); static NumberData ExecuteFactor(ptrdiff_t input); static NumberData ExecuteSimpleDF(ptrdiff_t input); static NumberData ExecuteDigit(ptrdiff_t input); static NumberData ExecuteDegFactor(ptrdiff_t input); static NumberData ExecuteDegDigit(ptrdiff_t input); static NumberData ExecuteFactDigit(ptrdiff_t input); static NumberData ExecuteAll(ptrdiff_t input); static wstring PolynomialSyntax(wstring pol); static wstring PolynomialSyntaxDirector(wstring pol); static wstring UpdateString(wstring& ToEvaluate); static wstring NumberCodeSyntax(wstring ToEvaluate); static ptrdiff_t NumberConverter(size_t root, wstring M); static ptrdiff_t StringConverter(wstring ToEvaluate); static void CodeConverter (wstring ToEvaluate, wstring message, bool ShowErrors, bool NecBoundary); static void LongComputation (wstring ToEvaluate, wstring message, bool ShowErrors, bool NecBoundary); static factor<big> GetMonomials(wstring pol); static polynomial<big> GetMonomialsRedirector(wstring pol); static polynomial<big> GetMonomialsAssister(wstring pol); static tensor<tensor<long double>> FromPolynomialToPos( factor<> vect, int& StartIndex, tensor<int>& CorrectSizes, tensor<int>& VDirectorTerm, tensor<int>& VKnownTerm, tensor<tensor<int>>& VDirectorSeq, tensor<tensor<int>>& VKnownSeq ); static void PolynomialDivide ( FACTOR<> dividend, FACTOR<> divisor, FACTOR<>& quotient, FACTOR<>& rest ); static polynomial<> Total(factor<> vect); static polynomial<> Partial(factor<> vect); static polynomial<> Binomial(factor<> vect); static polynomial<> Trinomial(factor<> vect); static polynomial<> SquareDifference(factor<> vect); static polynomial<> Ruffini(factor<> vect); static polynomial<> CompleteTheSquare(factor<> vect); static polynomial<> TrinomialSquare(factor<> vect); static FACTOR<> Complementary(POLYNOMIAL<> Polynomial, FACTOR<> factor, int exp); static void Simplify(Fraction<>& fr, int& ncoeff, int& dcoeff); static void Approximator(tensor<long double>& Equation, long double& root); static tensor<wstring> EquationSolver(factor<> equation); static tensor<long double> RootExtractor(polynomial<> vect); static tensor<tensor<long double>> SystemSolver(tensor<factor<>> functions); static void FractDisequationMain( polynomial<> Num, polynomial<> Den, tensor<wstring>& Roots, tensor<bool>& ItsFromDenominator, bool& InitSign, bool& Invert ); static ConsoleStream GetAlgebricSolution( tensor<wstring> roots, tensor<bool> ItsFromDenominator, bool InitialSign, bool ExpectedSign, bool CanBeNull = false ); static bool ParamDisequationSetup( polynomial<>& Num, polynomial<>& Den, polynomial<>& Sum, tensor<bool>& FromDenominator, tensor<long double>& AdditionalRoots, factor<>& Parametric, tensor<factor<>>& tops, tensor<factor<>>& bottoms, bool& InitSign, bool& InvertSign ); static void ParamDisequationMain( polynomial<> Un, tensor<factor<>> tops, tensor<factor<>> bottoms, tensor<long double> AdditionalRoots, size_t& Unisize, tensor<tensor<factor<>>>& TableOfMains, tensor<long double>& RootSet, tensor<long double>& RootExamples, tensor<wstring>& vals ); static ConsoleStream GetParametricSolution( wchar_t parameter, size_t Unisize, size_t Vpos, bool InitialSign, bool ExpectedSign, bool CanBeNull, tensor<bool> TermsFromDenominator, polynomial<>& Num, polynomial<>& Den, factor<> Parametric, tensor<factor<>> tops, tensor<factor<>> bottoms, tensor<tensor<factor<>>> TableOfMains, tensor<long double> RootSet, tensor<long double> RootExamples, tensor<wstring> vals ); static ConsoleStream DisequationSolutionPrinter( polynomial<> Num, polynomial<> Den, int behaviour, bool ChangeSign, bool PrintCondition = true ); static void PrintFraction (int NC, int DC, int& LINE, bool WritePlus, Fraction<> fract); static void PrintFractionaryResult ( int NC, int DC, int& lines, Fraction<> Fract, POLYNOMIAL<> NScomp = { {} }, POLYNOMIAL<> DScomp = { {} }, bool HasMoreVariables = true, bool correct = false, tensor<double> roots = {}, tensor<POLYNOMIAL<>> Denominators = {} ); static void CodeToNumber(switchcase& argc); static wstring ExpandNumber( switchcase& argc, big Number = big(), int Base = 0, bool access = true ); static void Repeater( switchcase& argc, wstring message, NumberData CPU(ptrdiff_t input) ); static void Loop( switchcase& argc, wstring message, NumberData CPU(ptrdiff_t input), bool select = false ); static void DecompAndSolve(switchcase& argc); template<typename Type> static polynomial<> DecompPolynomial(switchcase& argc, Type Polynomial); static void DecompMatrices(switchcase& argc); int main() {} static wstring Handler(wstring test) {} static size_t Factorial(size_t n) {} static size_t BinomialCoeff(size_t n, size_t k) {} static ptrdiff_t Gcd(ptrdiff_t A, ptrdiff_t B) {} static big Gcd(big A, big B) {} template<typename T>static int Gcd(tensor<T> terms) {} static big Gcd(tensor<big> terms) {} static ptrdiff_t intpow(ptrdiff_t base, int exp) {} inline static wstring ConvertEnumToWString(switchcase Enum) {} inline static switchcase ConvertWStringToEnum(wstring str) {} static void ReassigneEnum(switchcase& option) {} namespace ConsoleLogData { int RotAngle{ 270 }, PolygDegree{}, PolygonSides{ 4 }; int CircleCenterX, CircleCenterY, CircleRotDegreeAngle{}; bool DecreaseAngle{ true }, DecreaseWidth{ true }; double DWidth{ 1.9 }; const tensor<int> spectrum{ 9, 9, 9, 11, 11, 3, 3, 12, 4 }; }; static void ClearArea(COORD WinCenter, COORD Dimensions) {} static void WriteFraction(wstring Num, wstring Den, wstring& command, COORD START) {} static void PrintPFrame (double deg, int sides, double radius, COORD WinCenter) {} static void DrawFrame (int arc, double __i, int centerX, int centerY, double DIM) {} static void DrawCircleSquare(COORD CircleCenter) {} inline static void CS_CenterPrinter() {} inline static void CS_CornerPrinter() {} static void ProgressBar(long double ratio, double barWidth) {} static long double WaitingScreen(auto begin, auto end) {} static wstring CTSuperScript(wchar_t input) {} static wstring CFSuperScript(wstring script) {} static wstring ElabExponents(wstring& str) {} static void DeduceFromExponents(wstring& str) {} static wstring GetLine(tensor<wstring>& sugg, bool ShowSuggestions) {} static wstring GetUserNum (wstring txt, ptrdiff_t low, ptrdiff_t high, bool ShowSuggestions) {} static void SetDebug(wstring message, switchcase& opt, bool& Return, ptrdiff_t& LowerBound, ptrdiff_t& UpperBound, ptrdiff_t& datalenght ) {} static void SendCtrlPlusMinus(bool plus) {} static void SendString(wstring str) {} static void MonitorConsoleSize(COORD min, atomic_bool& runMonitor) {} static void UserInputThread() {} RECT ClientRect; namespace WindowData { bool redo{ false }; enum states { MIN, MAX, H_FLX, A_FLX, D_FLX }; LPARAM Coords{}, Current{}; bool enable{ false }; double Zoom{ 1 }; wchar_t __save; int gIndex{}; tensor<int> Indexlist; int shiftX{}, shiftY{}; tensor<tensor<int>> memory{ {} }; class DATA { public: COLORREF Color; Fraction<> Function; wstring ID; tensor<int> States; tensor<long double> StatX, StatY; DATA() : Color(0) {} DATA(Fraction<> funct); bool operator==(DATA other) {} }; tensor<DATA> List; DATA::DATA(Fraction<> funct) : Function(funct), ID(funct.str()) {} }; namespace Window3Data { enum states { MINIMUM, MAXIMUM, SADDLE, UNKNOWN, }; tensor<int> def; tensor<int> Light{ 0, 0, -1 }; double Zoom{ 1 }; bool enable{ false }; LPARAM Coords{}, Current{}; tensor<long double> StatX, StatY, StatZ; Fraction<> Function, PartialXder, PartialYder; auto Theta{ M_PI / 4 }; auto Phi{ M_PI / 3 }; }; static void DrawLine(int firstX, int firstY, int secondX, int secondY, HPEN Hpen) {} static void DrawLineToBuffer( HDC hdcmem, HBITMAP hbmem, int firstX, int firstY, int secondX, int secondY, HPEN Hpen ) {} static void DrawLine(Point__ P1, Point__ P2, HPEN hpen) {} static void DrawLineToBuffer (HDC hdcmem, HBITMAP hbmem, Point__ P1, Point__ P2, HPEN Hpen) {} static void IncrementCalculator(double zoom, double& pInc, double& vInc) {} static void ProjectPoint(tensor<long double> point, int& pointX, int& pointY) {} static void ProjectAndDrawLine (tensor<long double> start, tensor<long double> end, HPEN Hpen) {} static void DrawAxis(HDC hdcmem, HBITMAP hbmem, double pInc, double vInc) {} static LRESULT CALLBACK WindowProcessor2D( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) {} static BOOL CreateGraph(Fraction<> funct) {} static LRESULT CALLBACK WindowProcessor3D( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) {} static void Project3DGraph(Fraction<> funct) {} static bool Prime(ptrdiff_t number) {} static void PrimeNCalculator(ptrdiff_t max, ptrdiff_t min) {} static tensor<compost> DecomposeNumber(ptrdiff_t input) {} static tensor<int> DecomposeStrings(wstring terminal) {} static tensor<wstring> Fractioner(wstring str) {} static tensor<tensor<wstring>> FractPolynomial(wstring pol) {} static wstring Cript(ptrdiff_t input) {} static wstring FactNumber(ptrdiff_t input) {} static int ExeStrings(wstring input) {} static divisor DivisorCalculator(wstring factor) {} static digitRatio DigitRationalizer(ptrdiff_t inpt) {} static tensor<int> DivisorCounter(int num) {} static NumberData ExecuteSimpledeg(ptrdiff_t input) {} static NumberData ExecuteDegree(ptrdiff_t input) {} static NumberData ExecuteSimpleFact(ptrdiff_t input) {} static NumberData ExecuteFactor(ptrdiff_t input) {} static NumberData ExecuteSimpleDF(ptrdiff_t input) {} static NumberData ExecuteDigit(ptrdiff_t input) {} static NumberData ExecuteDegFactor(ptrdiff_t input) {} static NumberData ExecuteDegDigit(ptrdiff_t input) {} static NumberData ExecuteFactDigit(ptrdiff_t input) {} static NumberData ExecuteAll(ptrdiff_t input) {} static wstring PolynomialSyntax(wstring pol) {} static wstring PolynomialSyntaxDirector(wstring pol) {} static wstring UpdateString(wstring& ToEvaluate) {} static wstring NumberCodeSyntax(wstring ToEvaluate) {} static ptrdiff_t NumberConverter(size_t root, wstring M) { bool WhichWay{ true }, XOutOfRange{ false }; bool UselessExponent{ false }; bool XSubscriptOutOfRange{ false }; int size = PrimeNumbers.list_primes.size(), nums; auto ciphres{ DecomposeStrings(M) }; for (size_t iter = 0; iter < ciphres; ++iter) { WhichWay = !WhichWay; nums = ciphres[iter]; if (!XOutOfRange and WhichWay) { UselessExponent = nums == 1; root = intpow(root, nums); } else do { if (!XOutOfRange and root < size) { if (root > 0) root = PrimeNumbers.list_primes[root - 1]; else XSubscriptOutOfRange = true; nums--; } else XOutOfRange = true; } while (!XSubscriptOutOfRange and !XOutOfRange and nums != 0); if (XSubscriptOutOfRange) return -3; if (UselessExponent) return -2; if (XOutOfRange) return -1; return root; } static ptrdiff_t StringConverter(wstring ToEvaluate) { size_t integer{ 1 }; auto mono{ Fractioner(ToEvaluate) }; for (size_t indexof = 0; indexof < mono; ++indexof) { auto M{ mono[indexof] }; ptrdiff_t FindIndex{ -1 }; for (ptrdiff_t i = M.size() - 1; i >= 0; --i) if (M.at(i) == ) { FindIndex = i; break; } ptrdiff_t root; if (M.at(0) != L) root = NumberConverter(1, M); lse root = NumberConverter( StringConverter(M.substr(1, FindIndex - 1)), M.substr(FindIndex + 1, M.size() - 1) ); if (root < 0) return root; else integer *= root; } return integer; } static void CodeConverter (wstring ToEvaluate, wstring message, bool ShowErrors, bool NecBoundary) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); ptrdiff_t number; if (ToEvaluate == L) return; for (ptrdiff_t space = ToEvaluate.size() - 1; space >= 0; --space) if (ToEvaluate.at(space) == L or ToEvaluate.at(space) == L) ToEvaluate.erase(space, 1); if (NecBoundary) UpdateString(ToEvaluate); number = StringConverter(ToEvaluate); if (ShowErrors or number > 0) { auto text{ L + ToEvaluate + L }; ConsoleText << Console{ text, 11 }; } if (number < -2 and ShowErrors) { auto text{ L }; ConsoleText << Console{ text, 12 }; } if (number == -1 and ShowErrors) { auto text{ L }; ConsoleText << Console{ text, 12 }; } if (number == -2 and ShowErrors) { auto text{ L }; ConsoleText << Console{ text, 6 }; } if (!message.empty() and ShowErrors and number > 0) { wstring text{ message == L ? L : L }; ConsoleText << Console{ text, 15 }; if (number < GlobalMax) text = L + Cript(number) + L; else text = L; ConsoleText << Console{ text, 2 }; } if (number > 0) { auto text{ L }; ConsoleText << Console{ text, 15 }; ConsoleText << Console{ to_wstring(number) + L, 4 }; } } static void LongComputation (wstring ToEvaluate, wstring message, bool ShowErrors, bool NecBoundary) { computing = true; interrupted = false; auto backup{ ToEvaluate }; int counter{}; tensor<size_t> pos; for (size_t i = 0; i < ToEvaluate.size(); ++i) if (ToEvaluate.at(i) == L) { pos << i; counter++; } if (counter == 0) { CodeConverter(ToEvaluate, message, ShowErrors, NecBoundary); ConsoleText.log(); } else for (size_t i = 0; i < intpow(10, counter); ++i) { { lock_guard<mutex> lock(mtx); if (GlobalInterr) break; } thread comp_thread([&]() { auto j{ to_wstring(i) }; backup = ToEvaluate; int ZerosCount = counter - j.size(); for (int k = 0; k < ZerosCount; ++k) j = L + j; for (size_t k = 0; k < j.size(); ++k) backup.replace(pos[k], 1, wstring(1, j.at(k))); if (NecBoundary) UpdateString(backup); message = NumberCodeSyntax(backup); { lock_guard<mutex> lock(mtx); if (message.size() > 1 and ShowErrors) { auto text{ L + backup + L }; ConsoleText << Console{ text , 11 }; text = L + message + L; ConsoleText << Console{ text , 4 }; } else CodeConverter(backup, message, ShowErrors, false); if (interrupted) return; IsDone = true; cv.notify_one(); } } ); thread output_thread(CS_CornerPrinter); if (comp_thread.joinable()) comp_thread.join(); if (output_thread.joinable()) output_thread.join(); ConsoleText.log(); { lock_guard<mutex> lock(mtx); if (GlobalInterr) break; } } Cv.notify_all(); computing = false; interrupted = true; } static factor<big> GetMonomials(wstring pol) { factor<big> out; if (pol.empty()) return {}; if (!issign(pol.at(0))) pol = L + pol; for (ptrdiff_t i = pol.size() - 1; i >= 0; --i) if (issign(pol.at(i))) { auto part{ pol }; pol.erase(i); part.erase(0, i); big Numerator = LCM; if (part.find(L) != wstring::npos) { auto Denominator{ part }; Denominator.erase(0, part.find(L)); Numerator /= Denominator; } monomial<big> mono{ 1, tensor<int>(Variables.size(), 0) }; if (part.at(0) == L) mono.coefficient = -1; part.erase(0, 1); wstring coeff; while (isdigit(part.at(0))) { coeff += part.at(0); part.erase(0, 1); if (part.empty()) break; } big Coeff; for (size_t j = 0; j < coeff.size(); ++j) { Coeff += coeff.at(j) - ; if (j < coeff.size() - 1) Coeff *= 10; } if (coeff.empty()) Coeff = 1; if (mono.coefficient < 0) Coeff.invert(); mono.coefficient = Coeff * Numerator; if (part.empty()) { out << mono; continue; } for (ptrdiff_t j = 0; j < part.size(); ++j) if (isalpha(part.at(j))) { size_t VariableIndex{}; for (size_t k = 0; k < Variables.size(); ++k) if (Variables.at(k) == part.at(j)) { VariableIndex = k; break; } int degree{ 1 }; if (j < (ptrdiff_t)part.size() - 2) if (part.at(j + 1) == L and isdigit(part.at(j + 2))) { degree = part.at(j + 2) - L; if (j < (ptrdiff_t)part.size() - 3) if (isdigit(part.at(j + 3))) degree = 10 * degree + part.at(j + 3) - L; } mono.exp[VariableIndex] = degree; } out << mono; } return out; } static polynomial<big> GetMonomialsRedirector(wstring pol) { auto copy{ pol }; if (copy.size() >= 2) { if (copy.at(0) == L) copy.erase(0, 1); if (Last(copy) == L) copy.pop_back(); } if (copy.find(L) == wstring::npos and copy.find(L) == wstring::npos) return polynomial<big>{ PolynomialSum<big>(GetMonomials(copy)) }; int ParenthesisBalance{}; for (const auto& c : copy) { switch (c) { case L: ParenthesisBalance++; break; case L: ParenthesisBalance--; break; } if (ParenthesisBalance < 0) break; } if (ParenthesisBalance == 0) pol = copy; auto fact{ FractPolynomial(pol) }; tensor<int> null(Variables.size(), 0); tensor<polynomial<big>> Union; for (const auto& adder : fact) { polynomial<big> UnionElement(adder.size()); tensor<long double> ExpPos, ExpVal; for (size_t i = 0; i < adder; ++i) { if (adder[i].at(0) == L) { int value{ adder[i].at(1) - L }; if (adder[i].size() > 2) value = 10 * value + adder[i].at(2) - L; ExpPos << i; ExpVal << value; } else UnionElement[i] = PolynomialMultiply<big>(GetMonomialsRedirector(adder[i])); } for (size_t i = 0; i < ExpPos; ++i) UnionElement[ExpPos[i]] = { { ExpVal[i], {-1} } }; Union << UnionElement; } for (size_t i = 0; i < Union; ++i) for (size_t j = 0; j < Union[i]; ++j) { for (size_t k = 0; k < Union[i][j]; ++k) Union[i][j][k].exp(Variables.size(), 0); Union[i][j] = PolynomialSum(Union[i][j]); } size_t sizemax{}; for (auto P : Union) if (P > sizemax) sizemax = P.size(); for (auto& P : Union) { big NewLcm = LCM ^ int(sizemax - P.size()); for (auto& mon : P[0]) mon.coefficient *= NewLcm; } tensor<big> numbers; for (size_t i = 0; i < Union; ++i) { Union[i].open(); int sign{ 1 }; for (size_t j = 0; j < Union[i]; ++j) { Union[i][j].SortByExponents(); if (Union[i][j][0].coefficient < 0) { sign *= -1; for (size_t k = 0; k < Union[i][j]; ++k) Union[i][j][k].coefficient.invert(); } } big Coeff = sign; for (ptrdiff_t j = Union[i].size() - 1; j >= 0; --j) if (Union[i][j] == 1) { bool IsACoefficient{ true }; for (size_t k = 0; k < Variables.size(); ++k) if (Union[i][j][0].exp[k] != 0) IsACoefficient = false; if (IsACoefficient) { Coeff *= Union[i][j][0].coefficient; Union[i].erase(Union[i].begin() + j); } } Union[i] >> factor<big>{ { Coeff, null } }; numbers << Coeff; } auto gcd{ Gcd(numbers).fabs() }; if (gcd == 0) return polynomial<big>{ { { 0, null } } }; if (gcd != 1) for (size_t i = 0; i < Union; ++i) Union[i][0][0].coefficient /= gcd; auto ListCommonFactors{ Union[0] }; --ListCommonFactors; for (ptrdiff_t i = ListCommonFactors.size() - 1; i >= 0; --i) { bool IsCommon{ true }; for (size_t j = 1; j < Union; ++j) { ool common{ false }; for (size_t k = 0; k < Union[j]; ++k) if (ListCommonFactors[i] == Union[j][k]) common = true; if (!common) { IsCommon = false; break; } } if (!IsCommon) ListCommonFactors.erase(ListCommonFactors.begin() + i); else for (size_t j = 0; j < Union; ++j) for (ptrdiff_t k = Union[j].size() - 1; k >= 0; --k) if (Union[j][k] == ListCommonFactors[i]) { Union[j].erase(Union[j].begin() + k); break; } } ListCommonFactors >> factor<big>{ { gcd, null } }; tensor<factor<big>> products; for (const auto& Adder : Union) products << PolynomialMultiply<big>(Adder); factor<big> Sum; for (const auto& product : products) Sum += product; ListCommonFactors << PolynomialSum(Sum); if (ListCommonFactors.last() == factor<big>{ { 1, null } }) ListCommonFactors--; for (size_t i = 0; i < ListCommonFactors; ++i) if (ListCommonFactors[i] == 1) if (ListCommonFactors[i][0].coefficient < 0) { ListCommonFactors[i][0].coefficient.invert(); ListCommonFactors[0][0].coefficient.invert(); } if (ListCommonFactors[0] == factor<big>{ { 1, null } } and ListCommonFactors > 1) --ListCommonFactors; else if (ListCommonFactors[0] == factor<big>{ { -1, null } } and ListCommonFactors > 1) { --ListCommonFactors; for (size_t i = 0; i < ListCommonFactors[0]; ++i) ListCommonFactors[0][i].coefficient.invert(); } if (ListCommonFactors.last() == factor<big>{ { 1, null } } and ListCommonFactors > 1) ListCommonFactors--; big GeneralCoeff = 1; for (ptrdiff_t i = ListCommonFactors.size() - 1; i >= 0; --i) if (ListCommonFactors[i] == 1 and ListCommonFactors[i][0].exp == null) { GeneralCoeff *= ListCommonFactors[i][0].coefficient; ListCommonFactors.erase(ListCommonFactors.begin() + i); } ListCommonFactors >> factor<big>{ { GeneralCoeff, null } }; LCM ^= (int)sizemax; ListCommonFactors.close(); return ListCommonFactors; } static polynomial<big> GetMonomialsAssister(wstring pol) { for (ptrdiff_t index = pol.size() - 2; index > 0; --index) if (pol.at(index) == L and pol.at(index - 1) != and pol.at(index + 1) != ) { bool AssignedStart{ false }, AssignedEnd{ false }; ptrdiff_t startIndex{}, endIndex = pol.size() - 1; int StartBalance{}, EndBalance{}; for (ptrdiff_t i = index - 1; i >= 0; --i) { if (pol.at(i) == ) StartBalance--; if (pol.at(i) == ) StartBalance++; if (issign(pol.at(i)) or StartBalance == 1) { startIndex = i; AssignedStart = true; break; } } for (size_t i = index + 1; i < pol.size() - 1; ++i) { if (pol.at(i) == ) EndBalance--; if (pol.at(i) == ) EndBalance++; if (issign(pol.at(i)) or EndBalance == 1) { endIndex = i; AssignedEnd = true; break; } } wstring start{ pol }, first{ pol }, Last{ pol }, end{ pol }; if (AssignedEnd) end.erase(0, endIndex + (pol.at(endIndex) == L)); else end.clear(); if (AssignedStart) start.erase(startIndex + (pol.at(startIndex) != L)); else start.clear(); if (AssignedEnd) Last.erase(endIndex); Last.erase(0, index + 1); first.erase(index); if (AssignedStart) first.erase(0, startIndex + 1); pol = start + L + first + L + Last + L + end; } for (ptrdiff_t i = pol.size() - 1; i >= 0; --i) if (pol.at(i) == L) pol.erase(i, 1); Variables.clear(); for (const auto& c : pol) if (isalpha(c)) { bool IsTheVariableSet{ false }; for (const auto& Variable : Variables) if (Variable == c) IsTheVariableSet = true; if (!IsTheVariableSet) Variables += c; } if (Variables.empty()) Variables = L; LCM = 1; for (size_t i = 0; i < pol.size(); ++i) if (pol.at(i) == L) { auto bigger{ pol }; int J{ -1 }; if (i < bigger.size() - 2) for (size_t j = i; j < bigger.size(); ++j) { auto ch{ bigger.at(j) }; if (issign(ch) or ch == L or ch == L) { J = j; break; } } if (J >= 0) bigger.erase(J); bigger.erase(0, i + 1); big second = bigger; LCM = (LCM * second).fabs() / Gcd(LCM, second); } return GetMonomialsRedirector(pol); } template<typename T> T ObjectOperations (wstring& errcode, tensor<T> list, tensor<wstring> ops, wstring disposition) { if (list.empty()) { errcode = L; return T(); } auto shape{ list[0] }; if (disposition.empty()) { for (size_t i = 0; i < ops; ++i) disposition += ops[i] + L; if (disposition.empty()) { errcode = L; return T(); } if (ops.size() != list.size()) disposition.pop_back(); } bool stay{ true }; int TemporaryBalance{}; for (size_t i = 0; i < disposition.size(); ++i) switch (disposition.at(i)) { case L: TemporaryBalance++; break; case L: TemporaryBalance--; break; } if (TemporaryBalance < 0) { errcode = L; return T(); } if (TemporaryBalance > 0) disposition += wstring(TemporaryBalance, L); int occurrences{}; for (const auto& ch : disposition) { if (ch == L) occurrences++; if (occurrences > 1) { errcode = L; return T(); } } if (occurrences > 0) { auto position{ disposition.find(L) }; disposition.erase(position, 1); disposition.insert(disposition.begin() + position, L); disposition.insert(disposition.begin() + position, L); disposition += L; } if (!disposition.empty()) { if (disposition.at(0) == L) { errcode = L; return T(); } if (Last(disposition) == L) { errcode = L; return T(); } } for (ptrdiff_t i = 1; i < (ptrdiff_t)disposition.size() - 1; ++i) { if (disposition.at(i) == L) { if (disposition.at(i - 1) != L) { errcode = L; return T(); } int exp = disposition.at(i + 1) - L, balance{}; ptrdiff_t I{ -1 }; for (ptrdiff_t j = i - 1; j >= 0; --j) { switch (disposition.at(j)) { case L: balance--; break; case L: balance++; break; } if (balance == 0) { I = j; break; } } if (I < 0) { errcode = L; return T(); } if (i - I <= 2) { errcode = L; return T(); } bool StopUpdatingFirst{ false }; size_t FirstPointer{}, LastPointer{}; for (size_t j = 0; j < i - 1; ++j) { if (disposition.at(j) != L) continue; tPointer++; if (StopUpdatingFirst) continue; FirstPointer++; if (j > I) StopUpdatingFirst = true; } FirstPointer--; LastPointer--; disposition.erase(i, 2); i--;  (exp == 0) { disposition.erase(I, i - I + 1); disposition.insert(disposition.begin() + I, L); list.erase(FirstPointer, LastPointer - FirstPointer + 1); list.insert(list.begin() + FirstPointer, EmptyProduct<T>(shape)); i = I; continue; } if (exp == 1) continue; auto StringRepeater{ disposition.substr(I, i - I + 1) }; tensor<T> TensorRepeater( list.begin() + FirstPointer, list.begin() + LastPointer + 1 ); size_t StrIndex = i + 1, TnsIndex{ LastPointer + 1 }; for (int j = 0; j < exp - 1; ++j) { for (size_t k = 0; k < StringRepeater.size(); ++k) disposition.insert( disposition.begin() + StrIndex, StringRepeater.at(StringRepeater.size() - k - 1) );  (size_t k = 0; k < TensorRepeater.size(); ++k) list.insert( list.begin() + TnsIndex, TensorRepeater.at(TensorRepeater.size() - k - 1) ); StrIndex += StringRepeater.size(); TnsIndex += TensorRepeater.size(); } i = StrIndex - 1; } } for (;;) { int Apostrophes{}, apostrophes{}; T final; wstring part; if (disposition.find(L) == wstring::npos and disposition.find(L) == wstring::npos) stay = false; bool Break{ false }; int balance{}, start{ -1 }, end = disposition.size(); if (stay) for (size_t i = 0; i < disposition.size(); ++i) { switch (disposition.at(i)) { case L: apostrophes = Apostrophes; start = i; balance++; break; case L: if (balance == 0) { errcode = L; return T(); } end = i; Break = true; break; case L: Apostrophes++; } if (Break) { part = disposition.substr(start + 1, end - start - 1); break; } } else part = disposition; if (start + 1 == end) { errcode = L; return T(); } if (Last(part) != L) { errcode = L; return T(); } if (part.at(0) == L or part.at(0) == L) { errcode = L; return T(); } if (part.at(0) == L) part = L + part; for (size_t i = 1; i < part.size(); ++i) if (part.at(i - 1) != L and part.at(i) != L) { errcode = L; return T(); } int LocalApostrophes{ apostrophes - 1 }; for (ptrdiff_t i = part.size() - 1; i >= 0; --i) switch (part.at(i)) { case L: part.erase(i, 1); break; case L: LocalApostrophes++; } auto local_apostrophes{ LocalApostrophes }; for (ptrdiff_t i = part.size() - 1; i >= 0; --i) switch (part.at(i)) { case L: part.erase(i, 1); list[local_apostrophes + 1] = list[local_apostrophes + 1].invert(); if (isnan(list[local_apostrophes + 1])) { errcode = L; return T(); } break; case L: local_apostrophes--; } local_apostrophes = LocalApostrophes + 1; for (ptrdiff_t i = part.size() - 1; i >= 0; --i) switch (part.at(i)) { case L: { part.at(i) = L; auto& obj{ list[local_apostrophes] }; obj = T() - obj; break; } case L: local_apostrophes--; } tensor<tensor<T>> AddAndMultiply; tensor<T> Add; auto index{ apostrophes }; for (size_t i = 0; i < part.size(); ++i) switch (part.at(i)) { case L: AddAndMultiply << tensor<T>{}; break; case L: AddAndMultiply.last() << list[index++]; } for (auto& Multiply : AddAndMultiply) { if (Multiply.empty()) continue; auto product{ Multiply[0] }; for (size_t i = 1; i < Multiply; ++i) product *= Multiply[i]; Add << product; } final = Add[0]; for (size_t i = 1; i < Add; ++i) final += Add[i]; if (disposition.find(L) != wstring::npos or disposition.find(L) != wstring::npos) { disposition.erase(start, end - start + 1); disposition.insert(disposition.begin() + start, L); } list.erase( (size_t)apostrophes, size_t(LocalApostrophes - apostrophes + 1) ); list.insert(list.begin() + apostrophes, final); if (!stay) { errcode.clear(); return final; } } } static tensor<tensor<long double>> FromPolynomialToPos( factor<> vect, int& StartIndex, tensor<int>& CorrectSizes, tensor<int>& VDirectorTerm, tensor<int>& VKnownTerm, tensor<tensor<int>>& VDirectorSeq, tensor<tensor<int>>& VKnownSeq ) { vect.SortByExponents(); tensor<int> null(Variables.size(), 0); auto DirectorDegSequence{ vect[0].exp }; auto KnownDegSequence{ vect.last().exp }; StartIndex = 0; for (size_t i = 0; i < Variables.size(); ++i) if (DirectorDegSequence[i] > 0 and KnownDegSequence[i] > 0) return {}; for (ptrdiff_t i = Variables.size() - 1; i >= 0; --i) if (DirectorDegSequence[i] > 0 or KnownDegSequence[i] > 0) StartIndex = i; int Size{ Gcd(vect[0].exp + vect.last().exp) }; auto listSizes{ DivisorCounter(Size) }; for (const auto& size : listSizes) { bool keep{ false }; if (size + 1 < vect) continue; auto DirectorSeq{ DirectorDegSequence }; auto KnownSeq{ KnownDegSequence }; for (size_t i = 0; i < Variables.size(); ++i) { DirectorSeq[i] /= size; KnownSeq[i] /= size; } for (size_t i = 1; i + 1 < vect; ++i) { double Dquot{ -1 }, Kquot{ -1 }; for (size_t j = 0; j < Variables.size(); ++j) { double vexp = vect[i].exp[j]; if (!DirectorSeq[j] and !KnownSeq[j] and vexp) return {}; bool primary = DirectorSeq[j]; double quot = primary ? vexp / DirectorSeq[j] : vexp / KnownSeq[j]; if (!integer(quot)) { keep = true; break; } if (primary) { if (Dquot == -1) Dquot = quot; else if (Dquot != quot) keep = true; } else { if (Kquot == -1) Kquot = quot; else if (Kquot != quot) keep = true; } } if (keep) break; } if (keep) continue; if (size > 1) CorrectSizes << size; } tensor<tensor<long double>> result; for (const auto& CorrectSize : CorrectSizes) { auto DirectorSeq{ DirectorDegSequence }; auto KnownSeq{ KnownDegSequence }; for (size_t i = StartIndex; i < Variables.size(); ++i) { DirectorSeq[i] /= CorrectSize; KnownSeq[i] /= CorrectSize; } int DirectorTerm = vect[0].coefficient; int KnownTerm = vect.last().coefficient; if (abs(DirectorTerm) >= GlobalMax or abs(KnownTerm) >= GlobalMax) continue; int KnVarPos{ -1 }; tensor<long double> position(CorrectSize + 1, 0); for (size_t i = StartIndex; i < Variables.size(); ++i) if (KnownSeq[i] > 0) { KnVarPos = i; break; } bool skip{ false }; for (size_t i = 0; i < vect; ++i) { int index; if (KnVarPos >= 0) index = vect[i].exp[KnVarPos] / KnownSeq[KnVarPos]; else index = CorrectSize - vect[i].exp[StartIndex] / DirectorSeq[StartIndex]; if (index < 0) { skip = true; break; } position[index] = vect[i].coefficient; } if (skip) continue; result << position; VDirectorTerm << DirectorTerm; VKnownTerm << KnownTerm; VDirectorSeq << DirectorSeq; VKnownSeq << KnownSeq; } for (size_t i = 0; i < result; ++i) for (size_t j = i + 1; j < result; ++j) if (result[i] < result[j]) { swap(result[i], result[j]); swap(CorrectSizes[i], CorrectSizes[j]); swap(VDirectorTerm[i], VDirectorTerm[j]); swap(VKnownTerm[i], VKnownTerm[j]); swap(VDirectorSeq[i], VDirectorSeq[j]); swap(VKnownSeq[i], VKnownSeq[j]); } return result; } template<typename T_int = long double> static factor<T_int> PolynomialSum(factor<T_int> vect) { int ImgUnitPos = Variables.find(L); if (ImgUnitPos != wstring::npos) for (auto& mon : vect) { mon.exp[ImgUnitPos] %= 4; if (mon.exp[ImgUnitPos] > 1) { mon.coefficient *= -1; mon.exp[ImgUnitPos] -= 2; } } for (ptrdiff_t i = vect.size() - 1; i >= 0; --i) for (ptrdiff_t j = i - 1; j >= 0; --j) if (vect[i].exp[0] >= 0 and vect[j].exp[0] >= 0) { bool AreTheMonomialsSimiliar{ true }; for (int k = 0; k < Variables.size(); ++k) if (vect[i].exp[k] != vect[j].exp[k]) AreTheMonomialsSimiliar = false; if (AreTheMonomialsSimiliar) { vect[i].coefficient += vect[j].coefficient; vect[j].coefficient = 0; } } for (ptrdiff_t i = vect.size() - 1; i >= 0; --i) if (vect[i].coefficient == 0) vect[i].exp.clear(); auto it = remove(vect.begin(), vect.end(), monomial<T_int>{ 0, {} }); vect.erase(it, vect.end()); if (vect.empty()) return factor<T_int>{ { 0, tensor<int>(Variables.size(), 0) } }; return vect; } template<typename T_int = long double> static factor<T_int> PolynomialMultiply(polynomial<T_int> Polynomial) { bool Empty{ Polynomial.empty() }; if (!Empty) for (const auto& term : Polynomial) if (term.empty()) { Empty = true; break; } if (Empty) return { { 1, tensor<int>(Variables.size(), 0) } }; Polynomial.open(); while (Polynomial > 1) { factor<T_int> Temp; monomial<T_int> temp; for (auto A : Polynomial[0]) for (auto B : Polynomial[1]) { temp.coefficient = A.coefficient * B.coefficient; temp.exp.clear(); for (size_t i = 0; i < Variables.size(); ++i) temp.exp << A.exp[i] + B.exp[i]; Temp << temp; } --(--Polynomial); Polynomial >> Temp; } return PolynomialSum(Polynomial[0]); } static void PolynomialDivide ( FACTOR<> dividend, FACTOR<> divisor, FACTOR<>& quotient, FACTOR<>& rest ) { dividend.sort(); divisor.sort(); dividend.complete(dividend[0].degree); divisor.complete(divisor[0].degree); dividend.sort(); divisor.sort(); quotient.clear(); while (dividend[0].degree >= divisor[0].degree) { auto divide{ divisor }; int deg = dividend[0].degree, _deg = divisor[0].degree; long double rest_element{ dividend[0].coefficient }; rest_element /= divisor[0].coefficient; CORRECTION_RATIO *= divisor[0].coefficient; for (size_t i = 0; i < divide; ++i) { divide[i].coefficient *= -rest_element; divide[i].degree += deg - _deg; } dividend = dividend - divide.neg(); dividend.complete(deg); dividend.sort(); quotient << MONOMIAL<>{ deg - _deg, rest_element }; } rest = dividend; for (size_t i = 0; i < quotient; ++i) quotient[i].coefficient *= CORRECTION_RATIO; for (size_t i = 0; i < rest; ++i) rest[i].coefficient *= CORRECTION_RATIO; int gcd{ abs(Gcd(quotient + rest)) }; for (size_t i = 0; i < quotient; ++i) quotient[i].coefficient /= gcd; for (size_t i = 0; i < rest; ++i) rest[i].coefficient /= gcd; } static polynomial<> Total(factor<> vect) { polynomial<> output; output << vect; if (vect <= 1) return output; bool positive_min{ false }; int GCD{ Gcd(vect) }; tensor<int> exponents; for (size_t i = 0; i < Variables.size(); ++i) { int min{ vect[0].exp[i] }; for (const auto& t : vect) if (t.exp[i] < min) min = t.exp[i]; exponents << min; if (min > 0) positive_min = 1; } if (abs(GCD) != 1 or positive_min) { output.clear(); output << factor<>{ { (long double)GCD, exponents } }; for (size_t i = 0; i < vect; ++i) { vect[i].coefficient /= GCD; for (size_t j = 0; j < Variables.size(); ++j) vect[i].exp[j] -= exponents[j]; } } if (abs(GCD) != 1 or positive_min) { output.clear(); output << factor<>{ { (long double)GCD, exponents } } << vect; return output; } return { vect }; } static polynomial<> Partial(factor<> vect) { polynomial<> outp; outp << vect; if (vect != 4) return outp; tensor<int> null(Variables.size(), 0); factor<> part_1{ vect[0], vect[1] }, part_2{ vect[2], vect[3] }; auto Part1{ Total(part_1) }; auto Part2{ Total(part_2) }; if ((Part1.last() - Part2.last().neg()).empty()) { if (Part1 == 1) swap(Part1, Part2); Part2 >> factor<>{ { -1, null } }; Part2[1] = Part2[1].neg(); } part_1 = Part1.last(); part_2 = Part2.last(); if (part_1 != part_2) return outp; outp.clear(); polynomial<> mon_1, mon_2; if (Part1 == 1) mon_1 << factor<>{ { 1, null } }; else mon_1 << Part1[0]; if (Part2 == 1) mon_2 << factor<>{ { 1, null } }; else mon_2 << Part2[0]; mon_1 << part_1; mon_2 << part_2; part_1.SortByExponents(); part_2 = mon_1[0] - mon_2[0].neg(); part_2.SortByExponents(); outp << part_1 << part_2; return outp; } static polynomial<> Binomial(factor<> vect) { polynomial<> outp; outp << vect; int exponent = vect.size() - 1, sign{ 1 }; if (exponent <= 1) return outp; bool reassigne{ false }; vect.SortByDegree(); tensor<int> modifier(Variables.size(), 0); modifier[0] = -1; auto A{ vect[0] }; auto B{ vect.last() }; if (exponent % 2 == 0 and (A.coefficient < 0 or B.coefficient < 0)) return outp; double Sq_A, Sq_B; if (A.coefficient > 0) Sq_A = pow(A.coefficient, 1.0 / exponent); else Sq_A = -pow(-A.coefficient, 1.0 / exponent); if (B.coefficient > 0) Sq_B = pow(B.coefficient, 1.0 / exponent); else Sq_B = -pow(-B.coefficient, 1.0 / exponent); if (!integer(Sq_A)) return outp; if (!integer(Sq_B)) return outp; for (size_t i = 0; i < Variables.size(); ++i) if (A.exp[i] % exponent != 0) return outp; for (size_t i = 0; i < Variables.size(); ++i) if (B.exp[i] % exponent != 0) return outp; auto Aexps{ A.exp }; auto Bexps{ B.exp }; for (size_t i = 0; i < Variables.size(); ++i) { Aexps[i] /= exponent; Bexps[i] /= exponent; } for (size_t i = 1; i < exponent; ++i) { for (size_t j = 0; j < Variables.size(); ++j) if (vect[i].exp[j] != Aexps[j] * (exponent - i) + Bexps[j] * i) return outp; int coeff = BinomialCoeff(exponent, i); if (vect[i].coefficient == -coeff * (int)pow(Sq_A, exponent - i) * (int)pow(Sq_B, i) ) { if (!reassigne) { sign = -1; reassigne = 1; } else if (sign == 1) return outp; } else if (vect[i].coefficient == coeff * (int)pow(Sq_A, exponent - i) * (int)pow(Sq_B, i) ) { if (!reassigne) { sign = 1; reassigne = 1; } else if (sign == -1) return outp; } else return outp; } outp.clear(); outp << factor<>{ { (long double)exponent, modifier } }; outp++; outp[1] << monomial<>{ Sq_A, Aexps } << monomial<>{ sign * Sq_B, Bexps }; return outp; } static polynomial<> Trinomial(factor<> vect) { polynomial<> outp; outp << vect; if (vect != 3) return outp; vect.SortByDegree(); int A, B, C; for (size_t i = 0; i < Variables.size(); ++i) if (vect[0].exp[i] % 2 == 1 or vect[2].exp[i] % 2 == 1) return outp; auto Aexps{ vect[0].exp }; auto Cexps{ vect[2].exp }; for (size_t i = 0; i < Variables.size(); ++i) { if (2 * vect[1].exp[i] != vect[0].exp[i] + vect[2].exp[i]) return outp; Aexps[i] /= 2; Cexps[i] /= 2; } A = vect[0].coefficient; B = vect[1].coefficient; C = vect[2].coefficient; double firstX, secondX, delta; delta = B * B - 4 * A * C; if (delta <= 0) return outp; if (!integer(sqrt(delta))) return outp; firstX = (-B - sqrt(delta)) / (2 * A); secondX = (-B + sqrt(delta)) / (2 * A); if (!integer(A * firstX * secondX)) return outp; outp.clear(); int I, J; for (I = 1; I <= abs(A); ++I) if (integer(firstX * I)) break; if (I == abs(A) + 1) I--; if (A < 0) I *= -1; for (J = 1; J <= abs(A); ++J) if (integer(secondX * J)) break; if (J == abs(A) + 1) J--; outp = { {}, {} }; outp[0] << monomial<>{ -I * firstX, Cexps }; outp[0] << monomial<>{ (long double)I, Aexps }; outp[1] << monomial<>{ -J * secondX, Cexps }; outp[1] << monomial<>{ (long double)J, Aexps }; outp[0].SortByExponents(); outp[1].SortByExponents(); return outp; } static polynomial<> SquareDifference(factor<> vect) { polynomial<> outp; outp << vect; if (vect != 2) return outp; if (!vect[0].IsSquare()) return outp; if (!vect[1].IsSquare()) return outp; bool Sign_A{ vect[0].coefficient > 0 }; bool Sign_B{ vect[1].coefficient > 0 }; if (Sign_A == Sign_B) return outp; auto Aexps{ vect[0].exp }; auto Bexps{ vect[1].exp }; for (size_t i = 0; i < Variables.size(); ++i) { Aexps[i] /= 2; Bexps[i] /= 2; } outp = { {}, {} }; outp[0] << monomial<>{ +sqrt(fabs(vect[1].coefficient)), Bexps }; outp[0] << monomial<>{ +sqrt(fabs(vect[0].coefficient)), Aexps }; outp[1] << monomial<>{ +sqrt(fabs(vect[1].coefficient)), Bexps }; outp[1] << monomial<>{ -sqrt(fabs(vect[0].coefficient)), Aexps }; if (Sign_A) { outp[1][0].coefficient *= -1; outp[1][1].coefficient *= -1; } return outp; } static polynomial<> Ruffini(factor<> vect) { polynomial<> output; output << vect; if (vect < 2) return output; vect.SortByExponents(); tensor<int> null(Variables.size(), 0); int StartIndex; tensor<int> CorrectSizes; tensor<int> VDirectorTerm; tensor<int> VKnownTerm; tensor<tensor<int>> VDirectorSeq; tensor<tensor<int>> VKnownSeq; auto ListPos{ FromPolynomialToPos( vect, StartIndex, CorrectSizes, VDirectorTerm, VKnownTerm, VDirectorSeq, VKnownSeq ) }; for (size_t i = 0; i < ListPos; ++i) { auto position{ ListPos[i] }; auto DirectorTerm{ VDirectorTerm[i] }; auto KnownTerm{ VKnownTerm[i] }; auto DirectorSeq{ VDirectorSeq[i] }; auto KnownSeq{ VKnownSeq[i] }; auto CorrectSize{ CorrectSizes[i] }; auto P{ DivisorCounter(abs(KnownTerm)) }; auto Q{ DivisorCounter(abs(DirectorTerm)) }; tensor<int> PossibleRoots; for (auto p : P) for (auto q : Q) PossibleRoots.push_back(p / q); for (ptrdiff_t j = PossibleRoots.size() - 1; j >= 0; --j) for (ptrdiff_t k = j - 1; k >= 0 and j < PossibleRoots; --k) if (PossibleRoots[j] == PossibleRoots[k]) PossibleRoots.erase(PossibleRoots.begin() + j); int SetRoot{}, Root; for (int n = 1; n < CorrectSize; ++n) { tensor<long double> temp; for (const auto& root : PossibleRoots) { Root = root; do { temp = position; for (size_t j = 1; j < position; ++j) temp[j] = Root * temp[j - 1] + temp[j]; if (temp.last() == 0) { temp--; SetRoot = Root; position = temp; break; } Root *= -1; } while (Root != root); if (SetRoot != 0) break; } if (SetRoot != 0) { output.clear(); output++; output[0] << monomial<>{ 1, DirectorSeq }; output[0] << monomial<>{ -(long double)SetRoot, KnownSeq }; output++; for (int j = 0; j < CorrectSize; ++j) { if (position[CorrectSize - 1 - j] == 0) continue; tensor<int> VariableExp(Variables.size(), 0); size_t index{ Variables.size() }; if (DirectorSeq[StartIndex] == 0) swap(DirectorSeq, KnownSeq); for (size_t k = StartIndex; k < Variables.size(); ++k) { if (DirectorSeq[k] == 0) { index = k; break; } VariableExp[k] = j * DirectorSeq[k]; } for (size_t k = index; k < Variables.size(); ++k) VariableExp[k] = (CorrectSize - 1 - j) * KnownSeq[k]; output[1] << monomial<>{ (long double)position[CorrectSize - j - 1], VariableExp }; } output[1].SortByExponents(); return output; } } } return { vect }; } static polynomial<> CompleteTheSquare(factor<> vect) { polynomial<> outp; outp << vect; if (vect != 3) return outp; vect.SortByDegree(); auto A{ vect[0] }; auto B{ vect[2] }; if (A.coefficient < 0 or B.coefficient < 0) return outp; double Sq_A = sqrt(A.coefficient); double Sq_B = sqrt(B.coefficient); if (!A.IsSquare()) return outp; if (!B.IsSquare()) return outp; for (size_t i = 0; i < Variables.size(); ++i) if (A.exp[i] % 4 != 0) return outp; for (size_t i = 0; i < Variables.size(); ++i) { if (vect[1].exp[i] != A.exp[i] / 2 + B.exp[i] / 2) return outp; if (!integer(A.exp[i] / 4 + B.exp[i] / 4)) return outp; } monomial<> DiffSquare, Diffneg; for (size_t i = 0; i < Variables.size(); ++i) DiffSquare.exp << A.exp[i] / 4 + B.exp[i] / 4; int middleterm{ 2 * (int)Sq_A * (int)Sq_B }, sign; int CasePlus = middleterm - vect[1].coefficient; int CaseMinus = -middleterm - vect[1].coefficient; if (CasePlus > 0 and integer(sqrt(CasePlus))) { DiffSquare.coefficient = sqrt(CasePlus); sign = 1; } else if (CaseMinus > 0 and integer(sqrt(CaseMinus))) { DiffSquare.coefficient = sqrt(CaseMinus); sign = -1; } else return outp; Diffneg.coefficient = -DiffSquare.coefficient; Diffneg.exp = DiffSquare.exp; for (size_t i = 0; i < Variables.size(); ++i) { A.exp[i] /= 2; B.exp[i] /= 2; } outp << vect; outp[0].clear(); outp[1].clear(); outp[0] << monomial<>{ Sq_A, A.exp } << DiffSquare << monomial<>{ Sq_B, B.exp }; outp[1] << monomial<>{ Sq_A, A.exp } << Diffneg << monomial<>{ Sq_B, B.exp }; return outp; } static polynomial<> TrinomialSquare(factor<> vect) { polynomial<> output; output << vect; if (vect != 5 and vect != 6) return output; tensor<int> modifier(Variables.size(), 0); modifier[0] = -1; if (vect == 5) { vect.SortByDegree(); bool AB2, AC2, BC2; long double A{ sqrt(vect[0].coefficient) }; if (!integer(A)) return output; long double C{ sqrt(vect[4].coefficient) }; if (!integer(C)) return output; long double B{ (long double)vect[3].coefficient / (2 * C) }; if (!integer(B)) return output; if (fabs(B) != fabs((double)vect[1].coefficient / (2 * A))) return output; for (size_t i = 0; i < Variables.size(); ++i) for (int j = 0; j < 5; ++j) if (vect[4 - j].exp[i] != j * vect[3].exp[i]) return output; AB2 = vect[1].coefficient < 0; BC2 = vect[3].coefficient < 0; if (fabs(vect[2].coefficient) == fabs(2 * A * C + B * B)) AC2 = vect[2].coefficient - B * B < 0; else if (fabs(vect[2].coefficient) == fabs(2 * A * C - B * B)) AC2 = vect[2].coefficient + B * B < 0; else return output; if (AB2 + AC2 + BC2 > 1) { AB2 = !AB2; AC2 = !AC2; BC2 = !BC2; } A = A >= 0 ? A : -A; B = B >= 0 ? B : -B; C = C >= 0 ? C : -C; if (AB2) C = -C; if (AC2) B = -B; if (BC2) A = -A; output.clear(); output << factor<>{ { 2, modifier } }; output++; output[1] << monomial<>{ A, vect[2].exp }; output[1] << monomial<>{ B, vect[3].exp }; output[1] << monomial<>{ C, vect[4].exp }; } else if (vect == 6) { factor<> squares; for (int i = 0; i < 6; ++i) if (vect[i].IsSquare()) squares << vect[i]; if (squares < 3) return output; tensor<int> _pos{ 1, 2, 2 }; int IndexAccesser{ 2 }; monomial<> A, B, C; bool AB2{ true }, AC2{ true }, BC2{ true }; while (IndexAccesser >= 0) { A = {}; B = {}; C = {}; auto backup{ _pos }; for (int i = IndexAccesser; i < 3; ++i) backup[i]++; if (backup.last() > squares) { IndexAccesser--; continue; } IndexAccesser = 2; _pos = backup; factor<> NewSquares(3); for (int i = 0; i < 3; ++i) NewSquares[i] = squares[_pos[i] - 1]; A = NewSquares[0].Root(2); B = NewSquares[1].Root(2); C = NewSquares[2].Root(2); monomial<> AB, AC, BC; AB.coefficient = 2 * A.coefficient * B.coefficient; AC.coefficient = 2 * A.coefficient * C.coefficient; BC.coefficient = 2 * B.coefficient * C.coefficient; for (size_t i = 0; i < Variables.size(); ++i) { AB.exp << A.exp[i] + B.exp[i]; AC.exp << A.exp[i] + C.exp[i]; BC.exp << B.exp[i] + C.exp[i]; } monomial<> ABterm, ACterm, BCterm; for (const auto& v : vect) { if (v == AB) ABterm = v; if (v == AC) ACterm = v; if (v == BC) BCterm = v; auto v2{ v }; v2.coefficient *= -1; if (v2 == AB) ABterm = v; if (v2 == AC) ACterm = v; if (v2 == BC) BCterm = v; } if ( ABterm == monomial<>{} or ACterm == monomial<>{} or BCterm == monomial<>{} ) continue; AB2 = ABterm.coefficient >= 0; AC2 = ACterm.coefficient >= 0; BC2 = BCterm.coefficient >= 0; if (AB2 + AC2 + BC2 > 1) { AB2 = !AB2; AC2 = !AC2; BC2 = !BC2; } break; } if (BC2) A.coefficient *= -1; if (AC2) B.coefficient *= -1; if (AB2) C.coefficient *= -1; output.clear(); output << factor<>{ { 2, modifier } }; output++; output[1] << A << B << C; } return output; } static tensor<Fraction<big>> GetManyFractions (tensor<wstring> numerators, tensor<wstring> denominators, wstring& errcode) { if (numerators % denominators) return {}; Variables.clear(); tensor<Fraction<big>> fractions; auto un{ numerators + denominators }; for (auto& str : un) for (const auto& c : str) if (isalpha(c) and Variables.find(c) == wstring::npos) Variables += c; auto savx{ Variables }; tensor<int> null(Variables.size(), 0); for (size_t i = 0; i < un; ++i) { bool isnum{ i % 2 == 0 }; if (isnum) fractions << Fraction<big>{}; auto str = isnum ? numerators[i / 2] : denominators[i / 2]; if (!(errcode = PolynomialSyntaxDirector(str)).empty()) return {}; auto old{ PolynomialMultiply<big>(GetMonomialsAssister(str)) }; if (Variables == savx or savx.empty()) { savx = Variables; isnum ? fractions.last().num = { old } : fractions.last().den = { old }; continue; } for (auto& mon : old) mon.exp(savx.size(), 0); factor<big> correct; for (const auto& mono : old) correct << monomial<big>{ mono.coefficient, null }; for (size_t j = 0; j < Variables.size(); ++j) { auto pos{ savx.find(Variables.at(j)) }; if (pos == wstring::npos) continue; for (size_t k = 0; k < correct; ++k) correct[k].exp[pos] = old[k].exp[j]; } isnum ? fractions.last().num = { correct } : fractions.last().den = { correct }; Variables = savx; } return fractions; } static FACTOR<> Complementary(POLYNOMIAL<> Polynomial, FACTOR<> factor, int exp) { if (Polynomial[0] == factor) --Polynomial; else for (ptrdiff_t i = Polynomial.size() - 1; i > 0 and i < Polynomial; --i) if (Polynomial[i] == factor) { if (Polynomial[i - 1][0].degree >= 0) { Polynomial.erase(Polynomial.begin() + i); break; } if (Polynomial[i - 1][0].coefficient - exp > 1) { Polynomial[i - 1][0].coefficient -= exp; break; } if (Polynomial[i - 1][0].coefficient - exp < 1) { Polynomial.erase(Polynomial.begin() + i); Polynomial.erase(Polynomial.begin() + (i - 1)); break; } Polynomial.erase(Polynomial.begin() + (i - 1)); break; } return V1converter(PolynomialMultiply, Polynomial); } static void Simplify(Fraction<>& fr, int& ncoeff, int& dcoeff) { tensor<int> null(Variables.size(), 0); auto& num{ fr.num }; auto& den{ fr.den }; num.open(); den.open(); for (size_t i = 0; i < num; ++i) num[i].SortByExponents(); for (size_t i = 0; i < den; ++i) den[i].SortByExponents(); int sign{ 1 }; for (ptrdiff_t i = num.size() - 1; i >= 0; --i) { if (num[i] == 1 and num[i][0].exp == null) continue; for (ptrdiff_t j = den.size() - 1; j >= 0; --j) { if (i >= num or j >= den) continue; if (den[j] == 1 and den[j][0].exp == null) continue; if (num[i] == den[j]) { num.erase(num.begin() + i); den.erase(den.begin() + j); continue; } for (size_t k = 0; k < den[j]; ++k) den[j][k].coefficient *= -1; if (num[i] == den[j]) { num.erase(num.begin() + i); den.erase(den.begin() + j); sign = -1; continue; } else for (size_t k = 0; k < den[j]; ++k) den[j][k].coefficient *= -1; if (num[i] == 1 and den[j] == 1) for (size_t k = 0; k < Variables.size(); ++k) { int GradeDelta{ abs(num[i][0].exp[k] - den[j][0].exp[k]) }; if (num[i][0].exp[k] > den[j][0].exp[k]) { num[i][0].exp[k] = GradeDelta; den[j][0].exp[k] = 0; } else { num[i][0].exp[k] = 0; den[j][0].exp[k] = GradeDelta; } } } } int FindN{ -1 }, FindD{ -1 }; for (size_t i = 0; i < num; ++i) if (num[i] == 1) { ncoeff = num[i][0].coefficient * sign; if (num[i][0].exp == null and num != 1 and num[0] != 1) num.erase(num.begin() + i); else FindN = i; break; } for (size_t i = 0; i < den; ++i) if (den[i] == 1) { dcoeff = den[i][0].coefficient; if (den[i][0].exp == null and den != 1 and den[0] != 1) den.erase(den.begin() + i); else FindD = i; break; } int GCD = Gcd(abs(ncoeff), abs(dcoeff)); ncoeff /= GCD; dcoeff /= GCD; if (FindN >= 0) num[FindN][0].coefficient = 1; if (FindD >= 0) den[FindD][0].coefficient = 1; ncoeff *= sign; num.close(); den.close(); for (size_t i = 0; i < num.size(); ++i) if (num[i] == factor<>{ { 1, null } }) num.erase(num.begin() + i); for (size_t i = 0; i < den.size(); ++i) if (den[i] == factor<>{ { 1, null } }) den.erase(den.begin() + i); } static void PrintFraction (int NC, int DC, int& LINE, bool WritePlus, Fraction<> fract) { tensor<int> null(Variables.size(), 0); GetConsoleScreenBufferInfo(hConsole, &csbi)(); auto start{ csbi.dwCursorPosition }; wcout << wstring(10, L); GetConsoleScreenBufferInfo(hConsole, &csbi)(); if (csbi.dwCursorPosition.Y >= start.Y) start.Y -= 10 - csbi.dwCursorPosition.Y + start.Y; SetConsoleCursorPosition(hConsole, start); long double root{}; int I{ 1 }, Root{}; bool IsMinus{ false }; wstring den_, num_; if (fract.num == 1) if (fract.num[0] == 1) if (fract.num[0][0].exp == null) root = fract.num[0][0].coefficient; bool Empty{ fract.num.empty() }, dontreset{ false }; if (Empty) { fract.num = polynomial<>{ { { 1, null } } }; dontreset = true; } else { Empty = true; for (const auto& term : fract.num) if (!term.empty()) { Empty = false; break; } } if (Empty and !dontreset) { NC = 0; fract.num = polynomial<>{ { { 0, null } } }; } if (!(Empty = fract.den.empty())) { Empty = true; for (const auto& term : fract.den) if (!term.empty()) { Empty = false; break; } } if (Empty) fract.den = polynomial<>{ { { 1, null } } }; if (root != 0) { for (;;) { if (integer(I * root)) break; I++; } Root = root * I; DC *= I; if (NC * Root < 0 and DC < 0) { NC = -NC; DC = -DC; } else if (NC * Root < 0) { NC = -NC; IsMinus = true; } else if (DC < 0) { DC = -DC; IsMinus = true; } } bool HasACoefficient{ false }; if (fract.den >= 1) if (fract.den[0] == 1) if (fract.den[0][0].exp == null) HasACoefficient = true; if (HasACoefficient) fract.den[0][0].coefficient *= CORRECTION_RATIO; else fract.den >> factor<>{ monomial<>{ CORRECTION_RATIO, null } }; int gcd = Gcd(NC, DC); NC /= gcd; DC /= gcd; int Gcd{ 1 }; if (root == 0) Gcd = ::Gcd((int)fract.num[0][0].coefficient, (int)fract.den[0][0].coefficient); else Gcd = ::Gcd(Root, fract.den[0][0].coefficient); fract.den[0][0].coefficient /= Gcd; if (root != 0) Root /= Gcd; else fract.num[0][0].coefficient /= Gcd; if (fract.den[0] == 1 and fract.den[0][0] == monomial<>{ 1, null }) --fract.den; else if (fract.den[0][0] == monomial<>{ -1, null }) { --fract.den; if (root == 0) fract.num[0][0].coefficient *= -1; else Root *= -1; } if (root == 0) if (fract.num[0] == 1 and fract.num[0][0] == monomial<>{ 1, null }) --fract.num; if (root != 0) num_ = to_wstring(NC * Root); if (root == 0) { num_ = fract.num.str(); if (num_ == L) num_.clear(); else if (abs(NC) != 1 and (fract.num[0] > 1 and fract.num == 1)) num_ = L + num_ + L; if (abs(NC) != 1) num_ = to_wstring(NC) + num_; if (num_.empty()) num_ = L; if (NC == -1 and (num_.find(L) == wstring::npos and num_.find(L) == wstring::npos) or num_.find(L) != wstring::npos) num_ = L + num_; else if (NC == -1) num_ = L + num_ + L; } den_.clear(); auto tempden{ fract.den.str() }; if (tempden != L) den_ = tempden; if (den_ == L) den_.clear(); else if (abs(DC) != 1 and (fract.den[0] > 1 and fract.den == 1)) den_ = L + den_ + L; if (abs(DC) != 1) den_ = to_wstring(DC) + den_; if (den_.empty()) den_ = L; if (DC == -1 and (den_.find(L) == wstring::npos and den_.find(L) == wstring::npos) and den_.find(L) != wstring::npos) den_ = L + den_; else if (DC == -1) den_ = L + den_ + L; bool both{ true }; if (num_.at(0) == L and den_.at(0) == L and fract.num == 1 and fract.den == 1) if (fract.num[0] == 1 and fract.den[0] == 1) { num_.erase(0, 1); den_.erase(0, 1); both = false; } if (num_.at(0) == L and fract.num == 1 and both) if (fract.num[0] == 1) { num_.erase(0, 1); IsMinus = !IsMinus; both = false; } if (den_.at(0) == L and fract.den == 1 and both) if (fract.den[0] == 1) { den_.erase(0, 1); IsMinus = !IsMinus; } if (NC == 0) { num_ = L; den_ = L; } int sizemax = max(num_.size(), den_.size()); int spacing = num_.size() - den_.size(); spacing = abs(spacing) / 2; if (num_.size() > den_.size()) den_ = wstring(spacing, L) + den_; else num_ = wstring(spacing, L) + num_; if (LINE + spacing + WritePlus * 2 > csbi.dwSize.X) { LINE = 0; start.Y += 4; SetConsoleCursorPosition(hConsole, start); } if (WritePlus or IsMinus) { if (WritePlus) start.X++; start.Y++; SetConsoleCursorPosition(hConsole, start); IsMinus ? wcout << L : wcout << L; start.X += 2; LINE += 2; start.Y--; } SetConsoleCursorPosition(hConsole, start); wcout << num_; start.Y++; SetConsoleCursorPosition(hConsole, start); wcout << wstring(sizemax, L); start.Y++; SetConsoleCursorPosition(hConsole, start); wcout << den_; start.Y -= 2; start.X += sizemax; SetConsoleCursorPosition(hConsole, start); LINE += sizemax + 1; } static void PrintFractionaryResult ( int NC, int DC, int& lines, Fraction<> Fract, POLYNOMIAL<> NScomp, POLYNOMIAL<> DScomp, bool HasMoreVariables, bool correct, tensor<double> roots, tensor<POLYNOMIAL<>> Denominators ) { tensor<int> null(Variables.size(), 0); bool ShowPlus{ false }; Fraction<> Part; Part.num = HasMoreVariables ? Fract.num : ToXV(NScomp); Part.den = HasMoreVariables ? Fract.den : ToXV(DScomp); if (correct) { wcout << L; for (size_t i = 0; i < Denominators; ++i) { PrintFraction( NC, DC, lines, ShowPlus, { polynomial<>{ { { roots[i], null } } }, ToXV(Denominators[i]) } ); ShowPlus = true; } wcout << L; goto EndOfStatement; } if (!Part.den.empty()) { if (Part.den > 1 or Part.den[0] > 1 or Part.den[0][0].exp != null) { GetConsoleScreenBufferInfo(hConsole, &csbi)(); csbi.dwCursorPosition.Y--; SetConsoleCursorPosition(hConsole, csbi.dwCursorPosition); PrintFraction( NC, DC, lines, false, Part ); wcout << L; goto EndOfStatement; } } if (abs(DC) != 1 and !Part.num.empty()) { GetConsoleScreenBufferInfo(hConsole, &csbi)(); csbi.dwCursorPosition.Y--; SetConsoleCursorPosition(hConsole, csbi.dwCursorPosition); PrintFraction( NC, DC, lines, false, { Part.num, { { monomial<>{ 1, null } } } } ); wcout << L; } else if (abs(DC) != 1 and NScomp.empty()) { GetConsoleScreenBufferInfo(hConsole, &csbi)(); csbi.dwCursorPosition.Y--; SetConsoleCursorPosition(hConsole, csbi.dwCursorPosition); PrintFraction( NC, DC, lines, false, { { { { 1, null } } }, { { { 1, null } } } } ); wcout << L; } else if (NScomp.empty()) { if (DC == -1) NC *= -1; wcout << L << NC; } else if (NScomp == 1) { auto output = HasMoreVariables ? Fract.num[0].str() : NScomp[0].str(); ElabExponents(output); if (NScomp[0] > 1 and NC != 1) output = L + output + L; if (abs(NC) != 1) output = to_wstring(NC) + output; if (NC * DC == -1) output = L + output; wcout << L << output; } else wcout << L << (HasMoreVariables ? Fract.num.str() : NScomp.str()); EndOfStatement: GetConsoleScreenBufferInfo(hConsole, &csbi)(); auto cursorP{ csbi.dwCursorPosition }; cursorP.X = lines; cursorP.Y--; SetConsoleCursorPosition(hConsole, cursorP); } static void Approximator(tensor<long double>& Equation, long double& root) { FACTOR<> equation(Equation.size()); for (ptrdiff_t i = Equation.size() - 1; i >= 0; --i) { equation[i].coefficient = Equation[i]; equation[i].degree = Equation.size() - i - 1; } auto derivative{ equation.derivate() }; const double TOL{ 1e-06 }; for (int i = 0; i < 100; ++i) { long double fx{}, dfx{}; for (size_t j = 0; j < equation; ++j) fx += equation[j].coefficient * pow(root, equation[j].degree); for (size_t j = 0; j < derivative; ++j) dfx += derivative[j].coefficient * pow(root, derivative[j].degree); if (dfx == 0) dfx += TOL; long double next = root - fx / dfx; if (fabs(next - root) < TOL) { root = next; break; } root = next; } for (size_t i = 1; i < equation.size(); ++i) { equation[i].coefficient = root * equation[i - 1].coefficient + equation[i].coefficient; equation[i].degree--; } equation[0].degree--; equation--; for (size_t i = 0; i < equation; ++i) Equation[i] = equation[i].coefficient; Equation--; } static tensor<wstring> EquationSolver(factor<> Equation) { tensor<int> null(Variables.size() , 0); if (Equation.empty()) return {}; tensor<wstring> answer; if (Equation == 1) { if (Equation[0].exp[0] == -1) return {}; or (size_t i = 0; i < Variables.size(); ++i) if (Equation[0].exp[i] != 0) answer << wstring(1, Variables.at(i)) + L; return answer; } int StartIndex; tensor<int> CorrectSizes; tensor<int> VDirectorTerm; tensor<int> VKnownTerm; tensor<tensor<int>> VDirectorSeq; tensor<tensor<int>> VKnownSeq; auto equation{ FromPolynomialToPos( Equation, StartIndex, CorrectSizes, VDirectorTerm, VKnownTerm, VDirectorSeq, VKnownSeq ) }; if (equation.empty() and Variables.size() == 1) { FACTOR<> eq{ To1V(Equation) }; eq.sort(); eq.complete(eq[0].degree + 1); tensor<long double> _eq; for (const auto& term : eq) _eq << term.coefficient; equation = { _eq }; VDirectorSeq = { { 1 } }; VKnownSeq = { { 0 } }; } if (!equation.empty()) for (;;) { if (equation[0] == 2) break; if (equation[0] == 3) { long double A, B, C; A = equation[0][0]; B = equation[0][1]; C = equation[0][2]; long double delta_4{ (B * B - 4 * A * C) / (4 * A * A) }; long double half_root_sum{ -B / (2 * A) }; wstring _push; if (delta_4 >= 0) { _push = factor<>{ { 1, VDirectorSeq[0] } }.str() + L + to_wstring(half_root_sum + sqrt(delta_4)); if (VKnownSeq[0] != null) _push += factor<>{ { 1, VKnownSeq[0] } }.str(); answer << _push; _push = factor<>{ { 1, VDirectorSeq[0] } }.str() + L + to_wstring(half_root_sum - sqrt(delta_4)); if (VKnownSeq[0] != null) _push += factor<>{ { 1, VKnownSeq[0] } }.str(); answer << _push; } else { _push = factor<>{ { 1, VDirectorSeq[0] } }.str() + L + complex<double>(half_root_sum, sqrt(-delta_4)).str(); if (VKnownSeq[0] != null) _push += factor<>{ { 1, VKnownSeq[0] } }.str(); answer << _push; _push = factor<>{ { 1, VDirectorSeq[0] } }.str() + L + complex<double>(half_root_sum, -sqrt(-delta_4)).str(); if (VKnownSeq[0] != null) _push += factor<>{ { 1, VKnownSeq[0] } }.str(); answer << _push; } return answer; } long double root{}; Approximator(equation[0], root); auto push{ factor<>{ { 1, VDirectorSeq[0] } }.str() + L + to_wstring(root) }; if (VKnownSeq[0] != null) push += factor<>{ { 1, VKnownSeq[0] } }.str(); answer << push; } if (Equation == 2) { int gcd{ abs(Gcd(Equation)) }; Equation[0].coefficient /= gcd; Equation[1].coefficient /= gcd; for (size_t i = 0; i < Variables.size(); ++i) { int min{ ::min(Equation[0].exp[i], Equation[1].exp[i]) }; Equation[0].exp[i] -= min; Equation[1].exp[i] -= min; } Equation.SortByExponents(); auto coeff{ Equation[0].coefficient }; Equation[0].coefficient = 1; if (coeff < 0) coeff *= -1; else Equation[1].coefficient *= -1; wstring push{ factor<>{ Equation[0] }.str() + L }; push += factor<>{ Equation[1] }.str(); if (coeff != 1) push += L + to_wstring(coeff); return { push }; } factor<> top, bottom; size_t Vpos{ Variables.find(L) }; for (const auto& mon : Equation) if (mon.exp[Vpos] > 1) return { Equation.str() + L }; for (auto mon : Equation) { if (mon.exp[Vpos] == 1) { mon.exp[Vpos] = 0; bottom << mon; continue; } mon.coefficient *= -1; top << mon; } tensor<bool> Used(Variables.size(), false); for (const auto& mon : Equation) for (size_t i = 0; i < Variables.size(); ++i) if (mon.exp[i] > 0) Used[i] = true; uto D = bottom.empty() ? L : bottom.str(); auto DD{ D }; if (D == L) { D = L; for (auto& mon : top) mon.coefficient *= -1; } auto N = top.empty() ? L : top.str(); auto NN{ N }; if (issign(NN.at(0))) NN.erase(0, 1); if (issign(DD.at(0))) DD.erase(0, 1); if (NN.find(L) != wstring::npos or NN.find(L) != wstring::npos) N = L + N + L; if (DD.find(L) != wstring::npos or DD.find(L) != wstring::npos) D = L + D + L; auto str{ N }; if (D == L) { if (str.at(0) == L) str.erase(0, 1); if (str.find(L) == wstring::npos) str.pop_back(); else str = L + str; str.at(0) == L ? str.erase(0, 1) : str = L + str; } if (D != L) str += L + D; return Used[Vpos] ? tensor<wstring>{ L + str } : tensor<wstring>{ str + L }; } static tensor<tensor<long double>> SystemSolver(tensor<factor<>> functions) { const double TOL{ 1e-06 }; tensor<int> null(Variables.size(), 0); if (functions != Variables.size()) return {}; int degree{ 1 }; for (const auto& function : functions) { int max{ function[0].degree() }; for (size_t i = 1; i < function; ++i) { int deg{ function[i].degree() }; if (max < deg) max = deg; } degree *= max; } if (degree == 0) return {}; if (degree == 1) { tensor<tensor<long double>> solutions(1); tensor<int> KnownTerms(Variables.size(), 0); for (size_t i = 0; i < functions; ++i) for (size_t j = 0; j < functions[i]; ++j) if (functions[i][j].exp == null) KnownTerms[i] = -functions[i][j].coefficient; Matrix<int> system(Variables.size(), tensor<int>(Variables.size(), 0)); for (size_t i = 0; i < functions; ++i) for (size_t j = 0; j < functions[i]; ++j) for (size_t k = 0; k < Variables.size(); ++k) if (functions[i][j].exp[k] == 1) system[k][i] = functions[i][j].coefficient; auto D{ system.det<long double>() }; tensor<long double> dets; for (size_t i = 0; i < Variables.size(); ++i) { auto mx{ system }; mx[i] = KnownTerms; dets << mx.det<long double>(); } if (D == 0) { if (dets == tensor<long double>(dets.size(), 0)) return { { nan() } }; return { {} }; } for (const auto& det : dets) solutions[0] << det / D; return solutions; } tensor<Fraction<>> NewFunctions; for (const auto& funct : functions) NewFunctions << Fraction<>({ funct }); tensor<tensor<long double>> solutions; tensor<long double> StarterPoint; for (size_t i = 0; i < Variables.size(); ++i) StarterPoint << pow(5, 1.0 / (i + 2)); for (int i = 0; i < 100 and solutions < degree; ++i) { Matrix<Fraction<>> Jacobian(Variables.size()); for (size_t j = 0; j < Variables.size(); ++j) for (size_t k = 0; k < Variables.size(); ++k) Jacobian[j] << NewFunctions[j].derivate(k); auto solution{ StarterPoint }; for (int j = 0; j < 100; ++j) { trix<> JInvpoint(Variables.size()); for (size_t k = 0; k < Variables.size(); ++k) for (size_t l = 0; l < Variables.size(); ++l) JInvpoint[k] << Jacobian[k][l](solution); auto determinant{ JInvpoint.det<long double>() }; JInvpoint = determinant == 0 ? JInvpoint.invert(1e-03) : JInvpoint.invert(determinant); tensor<long double> vect; for (size_t k = 0; k < Variables.size(); ++k) vect << NewFunctions[k](solution); tensor<long double> updater{ JInvpoint * vect }; for (size_t k = 0; k < Variables.size(); ++k) solution[k] -= updater[k]; long double norm{}; for (size_t k = 0; k < Variables.size(); ++k) norm += updater[k] * updater[k]; if (norm < TOL) break; } bool present{ false }; for (auto& sol : solutions) { bool LocalPresent{ true }; for (size_t j = 0; j < sol; ++j) if (fabs(sol[j] - solution[j]) > 100 * TOL) { LocalPresent = false; break; } if (LocalPresent) { present = true; break; } } if (!present) solutions << solution; factor<> remover; for (size_t j = 0; j < Variables.size(); ++j) { tensor<int> exponent(Variables.size(), 0); remover << monomial<>{ solution[j] * solution[j], exponent }; exponent[j] = 1; remover << monomial<>{ -2 * solution[j], exponent }; exponent[j] = 2; remover << monomial<>{ 1, exponent }; } for (auto& newfunct : NewFunctions) newfunct.den[0] *= remover; } return solutions; } static tensor<long double> RootExtractor(polynomial<> vect) { bool repeat{ false }; tensor<long double> roots; for (const auto& fact : vect) { if (fact.empty()) continue; if (fact[0].exp[0] < 0) { repeat = true; continue; } auto solutions{ EquationSolver(fact) }; if (fact == 1 and fact[0].exp[Variables.find(L)] == 2) solutions += solutions; for (auto sol : solutions) if (sol.find(L) == wstring::npos) { sol.erase(0, 5); auto fden{ sol }; if (sol.find(L) != wstring::npos) { while (fden.at(0) != L) fden.erase(0, 1); fden.erase(0, 1); while (Last(sol) != L) sol.pop_back(); sol.pop_back(); } else fden = L; auto root{ stold(sol) / stold(fden) }; roots << root; if (repeat)	roots << root; } repeat = false; } return roots; } static void FractDisequationMain( polynomial<> Num, polynomial<> Den, tensor<wstring>& Roots, tensor<bool>& ItsFromDenominator, bool& InitSign, bool& Invert ) { polynomial<> Un{ Num + Den }; long double Coeff{ 1 }; for (size_t i = 0; i < Un; ++i) if (Un[i] == 1 and Un[i][0].exp == tensor<int>{ 0 }) Coeff *= Un[i][0].coefficient; Invert = Coeff < 0; auto roots{ RootExtractor(Num) }; ItsFromDenominator = tensor<bool>(roots.size(), false); roots += RootExtractor(Den); ItsFromDenominator += tensor<bool>( roots.size() - ItsFromDenominator.size(), true ); for (ptrdiff_t i = roots.size() - 1; i >= 0; --i) if (roots[i] <= -2'147'483'647 or roots[i] >= 2'147'483'647) roots.erase(roots.begin() + i); for (size_t i = 0; i < roots; ++i) for (size_t j = i + 1; j < roots; ++j) if (roots[i] > roots[j]) { swap(roots[i], roots[j]); swap(ItsFromDenominator[i], ItsFromDenominator[j]); } InitSign = false; for (auto& fact : Num) { if (fact.empty()) continue; fact.SortByExponents(); if (fact[0].coefficient < 0) InitSign = !InitSign; } for (auto& fact : Den) { if (fact.empty()) continue; fact.SortByExponents(); if (fact[0].coefficient < 0) InitSign = !InitSign; } for (const auto& root : roots) Roots << Handler(to_wstring(root)); } static ConsoleStream GetAlgebricSolution( tensor<wstring> roots, tensor<bool> ItsFromDenominator, bool InitialSign, bool ExpectedSign, bool CanBeNull ) { ConsoleStream text; bool condition{ ((InitialSign == (roots.size() % 2 == 0)) == ExpectedSign) }; for (ptrdiff_t i = 0; i < roots.size() - 1; ++i) { bool SamePart{ int(i % 2) == condition }; if (i >= roots) break; if (roots[i] == roots[i + 1]) { bool T0{ ItsFromDenominator[i] or !CanBeNull }; bool T1{ ItsFromDenominator[i + 1] or !CanBeNull }; if ( (T0 and T1 and SamePart) or !(T0 or T1 or SamePart) or (!SamePart and (T0 xor T1)) ) { roots.erase(roots.begin() + (i + 1)); roots.erase(roots.begin() + i); ItsFromDenominator.erase(ItsFromDenominator.begin() + (i + 1)); ItsFromDenominator.erase(ItsFromDenominator.begin() + i); i--; continue; } if ((T0 xor T1) and SamePart) { ItsFromDenominator[i] = true; ItsFromDenominator[i] = false; } } } if (roots.empty()) return InitialSign == ExpectedSign ? ConsoleStream{ Console(L, 11) } : ConsoleStream{ Console(L, 11) }; if (condition) { text = { Console(L) }; CanBeNull and !ItsFromDenominator[0] ? text << Console(L) : text << Console(L); text << Console(roots[0]); if (roots > 1) text << Console(L, 8); } for (size_t i = condition; i < roots; i += 2) { if (i + 1 == roots) { CanBeNull and !ItsFromDenominator[i] ? text << Console(L) : text << Console(L); text << Console(roots[i]); break; } text << Console(roots[i]); CanBeNull and !ItsFromDenominator[i] ? text << Console(L) : text << Console(L); CanBeNull and !ItsFromDenominator[i + 1] ? text << Console(L) : text << Console(L); text << Console(roots[i + 1]); if (i + 2 < roots) text << Console(L, 8); } for (auto& cons : text) ElabExponents(cons.Text); return text; } static bool ParamDisequationSetup( polynomial<>& Num, polynomial<>& Den, polynomial<>& Sum, tensor<bool>& FromDenominator, tensor<long double>& AdditionalRoots, factor<>& Parametric, tensor<factor<>>& tops, tensor<factor<>>& bottoms, bool& InitSign, bool& InvertSign ) { auto Vpos{ Variables.find(L) }; for (auto& fact : Num) if (fact[0].exp[0] < 0 and fact[0].coefficient > 2) fact[0].coefficient = (int)fact[0].coefficient % 2; for (auto& fact : Den) if (fact[0].exp[0] < 0 and fact[0].coefficient > 2) fact[0].coefficient = (int)fact[0].coefficient % 2; Num.open(); Den.open(); Sum = Num + Den; for (auto& fact : Sum) for (const auto& mon : fact) if (mon.exp[Vpos] > 1) return false; FromDenominator = tensor<bool>(Num.size(), false) + tensor<bool>(Den.size(), true); InitSign = false; for (auto& fact : Sum) { fact.SortByExponents(); if (fact[0].coefficient < 0) InitSign = !InitSign; } tensor<factor<>> Parametrics; for (ptrdiff_t i = Sum.size() - 1; i >= 0; --i) { bool IsACoefficient{ true }; for (const auto& mon : Sum[i]) if (mon.exp[Vpos] != 0) { IsACoefficient = false; break; } if (IsACoefficient) { Parametrics << Sum[i]; Sum.erase(Sum.begin() + i); FromDenominator.erase(FromDenominator.begin() + i); if (Sum.empty()) return false; } } AdditionalRoots = RootExtractor(Parametrics); Parametric = PolynomialMultiply<long double>(Parametrics); tops(Sum.size()), bottoms(Sum.size()); for (size_t i = 0; i < Sum; ++i) { auto fact{ Sum[i] }; for (auto mon : fact) { if (mon.exp[Vpos] == 1) { mon.exp[Vpos] = 0; bottoms[i] << mon; continue; } mon.coefficient *= -1; tops[i] << mon; } if (tops[i].empty()) tops[i] = factor<>{ { 1, { 0, 0 } } }; if (bottoms[i].empty()) bottoms[i] = factor<>{ { 1, { 0, 0 } } }; if (fact == 1 and fact[0].exp == tensor<int>{ 0, 0 }) { InvertSign = ((tops[i][0].coefficient < 0) xor (bottoms[i][0].coefficient < 0)); Sum.erase(Sum.begin() + i); tops.erase(tops.begin() + i); bottoms.erase(bottoms.begin() + i); i--; } } return true; } static void ParamDisequationMain( polynomial<> Un, tensor<factor<>> tops, tensor<factor<>> bottoms, tensor<long double> AdditionalRoots, size_t& Unisize, tensor<tensor<factor<>>>& TableOfMains, tensor<long double>& RootSet, tensor<long double>& RootExamples, tensor<wstring>& vals ) { Unisize = Un.size(); tensor<tensor<factor<>>> FirstTable( bottoms.size(), tensor<factor<>>(bottoms.size()) ); TableOfMains = FirstTable; if (Unisize > 1) for (int first = 0; first < TableOfMains; ++first) for (int second = first + 1; second < TableOfMains; ++second) TableOfMains[first][second] = tops[first] * bottoms[second] - tops[second] * bottoms[first]; if (FirstTable == TableOfMains) Unisize = 1; RootSet = tensor<long double>{ RootExtractor(bottoms) }; if (Unisize > 1) for (auto& F : TableOfMains) for (auto& S : F) RootSet += RootExtractor({ S }); RootSet += AdditionalRoots; if (!RootSet.empty()) { long double RepeatedValue{ RootSet.last() }; for (size_t i = 0; i < RootSet; ++i) for (size_t j = i + 1; j < RootSet; ++j) if (RootSet[i] > RootSet[j]) swap(RootSet[i], RootSet[j]); for (ptrdiff_t i = RootSet.size() - 2; i >= 0; --i) { if (RootSet[i] == RepeatedValue) { RootSet.erase(RootSet.begin() + i); continue; } RepeatedValue = RootSet[i]; } RootExamples << RootSet[0] - 1; for (ptrdiff_t i = 0; i < RootSet.size() - 1; ++i) RootExamples << (RootSet[i] + RootSet[i + 1]) / 2.0; RootExamples << RootSet.last() + 1; } else RootExamples = { 0 }; for (size_t i = 0; i < Un; ++i) { auto D = bottoms[i].empty() ? L : bottoms[i].str(); auto DD{ D }; auto top{ tops[i] }; if (D == L) { D = L; for (auto& mon : top) mon.coefficient *= -1; } auto N = top.empty() ? L : top.str(); auto NN{ N }; if (issign(NN.at(0))) NN.erase(0, 1); if (issign(DD.at(0))) DD.erase(0, 1); if (NN.find(L) != wstring::npos or NN.find(L) != wstring::npos) N = L + N + L; if (DD.find(L) != wstring::npos or DD.find(L) != wstring::npos) D = L + D + L; auto str{ N }; if (D != L) str += L + D; vals << str; } } static ConsoleStream GetParametricSolution( wchar_t parameter, size_t Unisize, size_t Vpos, bool InitialSign, bool ExpectedSign, bool CanBeNull, tensor<bool> TermsFromDenominator, polynomial<>& Num, polynomial<>& Den, factor<> Parametric, tensor<factor<>> tops, tensor<factor<>> bottoms, tensor<tensor<factor<>>> TableOfMains, tensor<long double> RootSet, tensor<long double> RootExamples, tensor<wstring> vals ) { ConsoleStream text; tensor<wstring> ParameterIntervals; tensor<ConsoleStream> UnknownIntervals; for (size_t index = 0; index < RootExamples; ++index) { auto interval{ RootExamples[index] }; auto values{ vals }; auto ItsFromDenominator{ TermsFromDenominator }; ConsoleStream line; tensor<int> SumOfGEQValues(bottoms.size(), 0); if (index == 0) { ParameterIntervals << wstring(1, parameter); ParameterIntervals[0] += L + Handler(to_wstring(RootSet[0])); UnknownIntervals << ConsoleStream{ Console(L) }; goto comparison; } if (index == RootSet) { ParameterIntervals << wstring(1, parameter); ParameterIntervals.last() += L + Handler(to_wstring(RootSet.last())); UnknownIntervals << ConsoleStream{ Console(L) }; goto comparison; } ParameterIntervals << Handler(to_wstring(RootSet[index - 1])); CanBeNull and index - 1 < bottoms ? ParameterIntervals.last() += L : ParameterIntervals.last() += L; ParameterIntervals.last() += wstring(1, parameter); CanBeNull and index < bottoms ? ParameterIntervals.last() += L : ParameterIntervals.last() += L; ParameterIntervals.last() += Handler(to_wstring(RootSet[index])); UnknownIntervals << ConsoleStream{ Console(L) }; comparison: if (Unisize == 1) goto add_line; for (size_t first = 0; first < SumOfGEQValues; ++first) for (size_t second = first + 1; second < SumOfGEQValues; ++second) { bool value{ (TableOfMains[first][second](interval, 1 - Vpos, true)) == ( bottoms[first](interval, 1 - Vpos, true) == bottoms[second](interval, 1 - Vpos, true) ) }; SumOfGEQValues[first] += value; SumOfGEQValues[second] += !value; } for (size_t i = 0; i < SumOfGEQValues; ++i) for (size_t j = i + 1; j < SumOfGEQValues; ++j) if (SumOfGEQValues[i] == SumOfGEQValues[j]) line = { Console(L, 8), Console(L, 11) }; for (size_t i = 0; i < SumOfGEQValues; ++i) for (size_t j = i + 1; j < SumOfGEQValues; ++j) if (SumOfGEQValues[i] > SumOfGEQValues[j]) { swap(SumOfGEQValues[i], SumOfGEQValues[j]); swap(values[i], values[j]); swap(ItsFromDenominator[i], ItsFromDenominator[j]); } add_line: line = ConsoleStream{ Console(L, 8) } + GetAlgebricSolution( values, ItsFromDenominator, InitialSign, ExpectedSign == Parametric(interval, 1 - Vpos, true), CanBeNull ); UnknownIntervals.last() = line + UnknownIntervals.last(); if (index == RootSet) break; ParameterIntervals << wstring(1, parameter) + L; ParameterIntervals.last() += Handler(to_wstring(RootSet[index])); auto numerator{ Num }; auto denominator{ Den }; for (auto& fact : numerator) fact = fact(RootSet[index], 1 - Vpos, 1); for (auto& fact : denominator) fact = fact(RootSet[index], 1 - Vpos, 1); if (Vpos == 1) { for (auto& fact : numerator) for (auto& mon : fact) mon.exp[0] = mon.exp[1]; for (auto& fact : denominator) for (auto& mon : fact) mon.exp[0] = mon.exp[1]; } auto save{ Variables }; Variables = L; UnknownIntervals << ConsoleStream{ Console(L, 8) }; if (numerator.empty()) numerator = polynomial<>{ { { 0, { 0 } } } }; if (denominator.empty()) denominator = polynomial<>{ { { 0, { 0 } } } }; UnknownIntervals.last() += DisequationSolutionPrinter( numerator, denominator, 1 << ( 2 * (ExpectedSign xor Parametric(RootSet[index], 1 - Vpos, true)) + CanBeNull ), false, false ) + ConsoleStream{ Console(L) }; Variables = save; } size_t sizemax{ ParameterIntervals[0].size() }; for (size_t i = 1; i < ParameterIntervals; ++i) if (sizemax < ParameterIntervals[i].size()) sizemax = ParameterIntervals[i].size(); for (auto& word : ParameterIntervals) if (word.size() < sizemax) word += wstring(sizemax - word.size(), L); for (size_t i = 0; i < ParameterIntervals; ++i) { text << Console(ParameterIntervals[i]); for (size_t j = 0; j < UnknownIntervals[i]; ++j) text << UnknownIntervals[i][j]; } for (auto& cons : text) ElabExponents(cons.Text); return text; } static ConsoleStream DisequationSolutionPrinter( polynomial<> Num, polynomial<> Den, int behaviour, bool ChangeSign, bool PrintCondition ) { auto Vpos{ Variables.find(L) }; if (Variables.size() > 2 or Vpos == wstring::npos) return {}; if (Num.empty() and Den.empty()) return {}; WORD wAttribute{ 6 }; wstring expr = Variables == L ? L : L + wstring(1, Variables.at(1 - Vpos)) + L; expr = L + expr; ConsoleStream dir{ Console(expr + L, wAttribute), Console(expr + L, wAttribute), Console(expr + L, wAttribute), Console(expr + L, wAttribute) }; if (Variables == L) { ensor<wstring> roots; tensor<bool> ItsFromTheDenominator; bool InitialSign, InvertTheSign; FractDisequationMain( Num, Den, roots, ItsFromTheDenominator, InitialSign, InvertTheSign ); ConsoleStream Output; for (int i = 0; i < 4; ++i) if ((behaviour | (1 << i)) == behaviour) { bool positive = i / 2; if (PrintCondition) Output << dir[i] << Console(L); Output += GetAlgebricSolution( roots, ItsFromTheDenominator, InitialSign, (positive == InvertTheSign) xor ChangeSign, i % 2 == 1 ); if (PrintCondition) Output << Console(L); } if (PrintCondition) { Output--; Output << Console(L); } return Output; } wchar_t parameter{ Variables.at(1 - Vpos) }; polynomial<> Un; tensor<bool> TermsFromDenominator; tensor<long double> AdditionalRoots; factor<> Parametric; tensor<factor<>> tops, bottoms; bool InitialSign, InvertSign{ true }; if ( !ParamDisequationSetup( Num, Den, Un, TermsFromDenominator, AdditionalRoots, Parametric, tops, bottoms, InitialSign, InvertSign ) ) return {}; if (Un == 1 and Parametric == factor<>{ { 1, { 0, 0 } } }) { ConsoleStream Output; tensor<wstring> vals{ EquationSolver(Un[0]) }; if (vals == 1) if (isalpha(vals[0].at(0)) and isalpha(vals[0].at(1))) { if (vals[0].find(L) == wstring::npos) vals[0] += L; vals[0] += parameter; } for (auto& val : vals) val.erase(0, 5); for (int i = 0; i < 4; ++i) if ((behaviour | (1 << i)) == behaviour) { bool positive = i / 2; if (PrintCondition) Output << dir[i] << Console(L); Output += GetAlgebricSolution( vals, tensor<bool>(vals.size(), TermsFromDenominator[0]), InitialSign, (positive == InvertSign) xor ChangeSign, i % 2 == 1 ); if (PrintCondition) Output << Console(L); } if (PrintCondition) { Output--; Output << Console(L); } return Output; } size_t Unisize; tensor<tensor<factor<>>> TableOfMains; tensor<long double> RootSet, RootExamples; tensor<wstring> vals; ParamDisequationMain( Un, tops, bottoms, AdditionalRoots, Unisize, TableOfMains, RootSet, RootExamples, vals ); ConsoleStream Output; for (int i = 0; i < 4; ++i) if ((behaviour | (1 << i)) == behaviour) { bool positive = i / 2; if (PrintCondition) Output << dir[i] << Console(L); Output += ( RootSet.empty() ? GetAlgebricSolution( vals, TermsFromDenominator, InitialSign, (positive xor InvertSign) xor ChangeSign, i % 2 == 1 ) + ConsoleStream{ Console(L) } : tParametricSolution( parameter, Unisize, Vpos, InitialSign, (positive xor InvertSign) xor ChangeSign, i % 2 == 1, TermsFromDenominator, Num, Den, Parametric, tops, bottoms, TableOfMains, RootSet, RootExamples, vals ) ); if (PrintCondition) Output << Console(L); } if (PrintCondition) { Output--; Output << Console(L); } return Output; } static void CodeToNumber(switchcase& argc) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); wstring to_evaluate, ToEvaluate, message; bool ShowErrors{ true }, NecessaryBoundary{ true }; SetConsoleTextAttribute(hConsole, 14); wcout << L; SetConsoleTextAttribute(hConsole, 12); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 9); wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); for (;;) { do { message.clear(); wcout << L; wcout << L; getline(wcin, ToEvaluate); if (ToEvaluate == L) { argc = NotAssigned; return; } argc = ConvertWStringToEnum(ToEvaluate); ReassigneEnum(argc); if (argc != NotAssigned) { system(); SetConsoleTitle(ToEvaluate.c_str()); return; } if (ToEvaluate == L) { argc = Random; return; } if (!ToEvaluate.empty()) { NecessaryBoundary = ToEvaluate.at(0) != L and ToEvaluate.at(0) != L; ShowErrors = ToEvaluate.at(0) != L and NecessaryBoundary; if (!NecessaryBoundary) ToEvaluate.erase(0, 1); } to_evaluate = ToEvaluate; if (NecessaryBoundary) message = UpdateString(ToEvaluate); if (message.empty()) message = NumberCodeSyntax(ToEvaluate); if (message.size() > 1) { lock_guard<mutex> lock(CoutMutex); SetConsoleTextAttribute(hConsole, 4); wcout << L << message << L; SetConsoleTextAttribute(hConsole, 15)(); } } while (message.size() > 1); for (ptrdiff_t space = ToEvaluate.size() - 1; space >= 0; --space) if (ToEvaluate.at(space) == L or ToEvaluate.at(space) == L) ToEvaluate.erase(space, 1); { lock_guard<mutex> lock(mtx); GlobalInterr = false; interrupted = false; computing = true; } Cv.notify_all(); R; thread ComputationThread([=]() { LongComputation(to_evaluate, message, ShowErrors, NecessaryBoundary); } ); thread InputThread(UserInputThread); unique_lock<mutex> lock(CoutMutex); Cv.wait(lock, [] { return !GlobalInterr; }); if (ComputationThread.joinable()) ComputationThread.join(); if (InputThread.joinable()) InputThread.join(); if (GlobalInterr) { SetConsoleTextAttribute(hConsole, 14); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); } SetConsoleCursorInfo(hConsole, &cursor); } } tensor<tensor<wstring>> Map(17); static wstring ExpandNumber( switchcase& argc, big Number,	int Base,	bool access	) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); bool code{ true }; wstring ToEvaluate; bool RetAccess{ false }; if (access) { SetConsoleTextAttribute(hConsole, 14); wcout << L; SetConsoleTextAttribute(hConsole, 12); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); } for (;;) { if (!RetAccess) code = true; if (access) { input: SetConsoleTextAttribute(hConsole, 11); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); getline(wcin, ToEvaluate); for (ptrdiff_t i = ToEvaluate.size() - 1; i >= 0; --i) if (ToEvaluate.at(i) == L or ToEvaluate.at(i) == L) ToEvaluate.erase(i, 1); if (ToEvaluate == L) { argc = NotAssigned; return L; } argc = ConvertWStringToEnum(ToEvaluate); ReassigneEnum(argc); if (argc != NotAssigned) { system(); SetConsoleTitle(ToEvaluate.c_str()); return L; } if (ToEvaluate == L) { argc = Random; return L; } if (regex_search(ToEvaluate, wregex(L))) goto input; if (ToEvaluate.size() > 2 and ( ToEvaluate.find(L) != wstring::npos and ToEvaluate.find(L) != wstring::npos )) { code = false; Base = 2; if (Last(ToEvaluate) != L) goto input; int pos = ToEvaluate.find(L); switch (pos) { case 0: Base = -1; break; case 1: if (!isdigit(ToEvaluate.at(0))) goto input; Base = ToEvaluate.at(0) - L; break; case 2: if (!isdigit(ToEvaluate.at(0)) or !isdigit(ToEvaluate.at(1))) goto input; Base = (ToEvaluate.at(0) - L) * 10 + ToEvaluate.at(1) - L; break; default: goto input; } if ((Base < 2 or Base > 16) and Base >= 0) goto input; ToEvaluate.erase(0, pos + 1); ToEvaluate.pop_back(); if (ToEvaluate.find(L) != wstring::npos and ToEvaluate.find(L) != wstring::npos) goto input; if (regex_search(ToEvaluate, wregex(L))) goto input; if (ToEvaluate.at(0) == L or Last(ToEvaluate) == L) goto input; for (size_t i = 1; i < ToEvaluate.size(); ++i) if (ToEvaluate.at(i - 1) == L and ToEvaluate.at(i) == L) goto input; int Parenthesis{}; for (const auto& ch : ToEvaluate) { switch (ch) { case L: Parenthesis++; break; case L: Parenthesis--; break; } if (Parenthesis < 0 or Parenthesis > 5) goto input; } if (regex_search(ToEvaluate, wregex(L))) goto input; if (regex_search(ToEvaluate, wregex(L))) goto input; for (size_t i = 1; i < ToEvaluate.size() - 1; ++i) if (ToEvaluate.at(i) == L and ( ToEvaluate.at(i - 1) == L or ToEvaluate.at(i + 1) == L) ) goto input; ToEvaluate.size() >= 2) if ( isdigit(Last(ToEvaluate)) and isdigit(ToEvaluate.at(ToEvaluate.size() - 2)) ) goto input; if (regex_search(ToEvaluate, wregex(L))) goto input; } if (ToEvaluate.size() > 50 and code) goto input; if (code) { if (regex_search(ToEvaluate, wregex(L))) goto input; Number = ToEvaluate; } if (Number == 0) goto input; if (!code and Base == -1) { access = false; RetAccess = true; Base = 1; } } if (RetAccess) Base++; if (Base == 17) { access = true; RetAccess = false; Base = 2; continue; } if (code) for (int base = 2; base <= 16; ++base) { if (!access and base != Base) continue; wstring output; big number = Number; tensor<int> coefficients; for (int i = 0;; ++i) { if (number < base) break; big quotient = number / base; coefficients << (number - quotient * base).Number<int>(); number = quotient; } coefficients << number.Number<int>(); Map[base](max(Map[base].size(), coefficients.size()), L); Map[base][0] = L; for (ptrdiff_t i = coefficients.size() - 1; i >= 0; --i) if (coefficients[i] > 0) { ring partial{ L }; bool recursion{ coefficients[i] > 1 }; if (recursion) partial += to_wstring(coefficients[i]); if (Map[base][i].empty()) Map[base][i] = ExpandNumber(argc, i, base, false); if (!recursion) recursion = Map[base][i].find(L) != wstring::npos or Map[base][i].find(L) != wstring::npos; if (recursion) partial += L + Map[base][i] + L; else partial += to_wstring(stoi(Map[base][i]) + 1); output += partial; } if (output.at(0) == L) output.erase(0, 1); if (!access) return output; SetConsoleTextAttribute(hConsole, 6); wcout << L << base << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L << output << L; } else { auto toevaluate{ ToEvaluate }; tensor<big> tetration{ 0, 1, Base }; big Last = Base; for (;;) { if (Last * log2(Base) >= 256) break; Last = big(Base) ^ Last; tetration << Last; } for (ptrdiff_t i = toevaluate.size() - 1; i >= 0; --i) if (isdigit(toevaluate.at(i))) { if (i != (int)toevaluate.size() - 1) if (toevaluate.at(i + 1) == L) continue; int dim = toevaluate.at(i) - L; if (dim < 2) continue; if (dim >= tetration) goto overflow; auto first{ toevaluate }; auto second{ toevaluate }; first.erase(i); second.erase(0, i + 1); toevaluate = toevaluate.substr(0, i) + tetration[dim].str() + toevaluate.substr(i + 1, toevaluate.size() - 1); } while (toevaluate.find(L) != wstring::npos) for (ptrdiff_t i = toevaluate.size() - 1; i >= 0; --i) if (toevaluate.at(i) == L) { size_t j = i; for (; j < toevaluate.size(); ++j) if (toevaluate.at(j) == L) break; auto part{ toevaluate }; part.erase(j); part.erase(0, i + 1); tensor<big> add; for (ptrdiff_t k = part.size() - 1; k >= 0; --k) if (part.at(k) == L) { auto NewPart{ part }; part.erase(k); NewPart.erase(0, k + 1); add << NewPart; } add << part; big sum; for (const auto& num : add) sum += num; int coefficient{ 1 }, size{}; if (i > 0) if (isdigit(toevaluate.at(i - 1))) { coefficient = toevaluate.at(i - 1) - L; size = 1; } if (i > 1) if ( isdigit(toevaluate.at(i - 1)) and isdigit(toevaluate.at(i - 2)) ) { coefficient = coefficient * 10 + toevaluate.at(i - 1) - L; size = 2; } if (sum * log2(Base) >= 256) goto overflow; big result = (big(Base) ^ sum) * coefficient; auto first{ toevaluate }; auto second{ toevaluate }; first.erase(i - size); second.erase(0, j + 1); toevaluate = toevaluate.substr(0, i - size) + result.str() + toevaluate.substr(j + 1, toevaluate.size() - 1); } tensor<big> add; for (ptrdiff_t j = toevaluate.size() - 1; j >= 0; --j) if (toevaluate.at(j) == L) { auto part{ toevaluate }; toevaluate.erase(j); part.erase(0, j + 1); add << part; } add << toevaluate; big LastSum; for (const auto& num : add) LastSum += num; SetConsoleTextAttribute(hConsole, 2); wcout << L << Base << L; wcout << LastSum << L; SetConsoleTextAttribute(hConsole, 15)(); } continue; overflow: if (!RetAccess) { SetConsoleTextAttribute(hConsole, 4); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); } continue; } argc = NotAssigned; return L; } static void Repeater( switchcase& argc, wstring message, NumberData CPU(ptrdiff_t input) ) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); wstring n_{ to_wstring(GlobalMax) }, Input; ptrdiff_t input; NumberData result; SetConsoleTextAttribute(hConsole, 14); wcout << message << L; SetConsoleTextAttribute(hConsole, 15)(); for (;;) { SetConsoleTextAttribute(hConsole, 14); wstring txt{ L + n_ + L }; SetConsoleTextAttribute(hConsole, 15)(); Input = GetUserNum(txt, 1, GlobalMax, true); if (!Input.empty()) { if (Input == L) { argc = Random; return; } argc = ConvertWStringToEnum(Input); ReassigneEnum(argc); if (argc != NotAssigned) { system(); SetConsoleTitle(Input.c_str()); return; } input = stoull(Input); } else { random_device rng; mt19937 gen(rng()); uniform_int_distribution<size_t> dis(2, GlobalMax); input = dis(gen); } if (input == 1) break; result = CPU(input); result.printf(); } argc = NotAssigned; return; } static void Loop( switchcase& argc, wstring message, NumberData CPU(ptrdiff_t input), bool select ) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); wstring n_{ to_wstring(GlobalMax) }, Input, txt; tensor<NumberData> data; ptrdiff_t LowerBound, UpperBound, datalenght; bool Return; wcout << L; SetConsoleTextAttribute(hConsole, 14); wcout << message << ; SetDebug(message, argc, Return, LowerBound, UpperBound, datalenght); if (Return) return; wstring instr; if (select) { PRINTN = false; items = { 0, 0, 0, 0 }; SetConsoleTextAttribute(hConsole, 9); wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); bool exit{ false }; do { wcout << L; instr = GetLine(Expressions); if (instr == L) { argc = Random; return; } for (ptrdiff_t i = instr.size() - 1; i >= 0; --i) if (instr.at(i) == L or instr.at(i) == L) instr.erase(i, 1); wstring sum_instr{ instr }, prod_instr{ instr }; int posP{}, posS{}; if (instr.empty()) { items = { 0, 0, 0, 0 }; break; } posS = instr.find(L); posP = instr.find(L); if (posS == wstring::npos) sum_instr.clear(); if (posP == wstring::npos) prod_instr.clear(); if (sum_instr.empty()) prod_instr.erase(0, posP + 1); else if (prod_instr.empty()) sum_instr.erase(0, posS + 1); else if (posS < posP) { prod_instr.erase(0, posP + 1); sum_instr.erase(posP); sum_instr.erase(0, posS + 1); } else { sum_instr.erase(0, posS + 1); prod_instr.erase(posS); prod_instr.erase(0, posP + 1); } int pos_p{}, pos_s{}; if (!sum_instr.empty()) pos_s = sum_instr.find(L); if (!prod_instr.empty()) pos_p = prod_instr.find(L); if (pos_s == wstring::npos or pos_p == wstring::npos) continue; wstring np, dp, ns, ds; bool Continue{ false }; if (!prod_instr.empty()) { np = prod_instr; dp = prod_instr; np.erase(pos_p); dp.erase(0, pos_p + 1); for (const auto& c : np) if (!isdigit(c)) Continue = true; for (const auto& c : dp) if (!isdigit(c)) Continue = true; if (Continue) continue; items.digitProductRatioNum = stoi(np); items.digitProductRatioDen = stoi(dp); exit = true; } if (!sum_instr.empty()) { ns = sum_instr; ds = sum_instr; ns.erase(pos_s); ds.erase(0, pos_s + 1); for (const auto& c : ns) if (!isdigit(c)) Continue = true; for (const auto& c : ds) if (!isdigit(c)) Continue = true; if (Continue) continue; items.digitSumRatioNum = stoi(ns); items.digitSumRatioDen = stoi(ds); exit = true; } if (!exit) wcout << L; } while (!exit); } system(); GetConsoleScreenBufferInfo(hConsole, &csbi)(); const int Barwidth{ csbi.dwSize.X - 11 }; R; if (datalenght >= 1'000) { int iter{}; atomic<long double> Progress{}; DECLARE_TIME_POINT(begin); parallel_for(ptrdiff_t(LowerBound), UpperBound, [&](ptrdiff_t set) { auto data_element{ CPU(set) }; mtx.lock(); data << data_element; if (iter % 200 == 0) { DECLARE_TIME_POINT(stop); SetConsoleTextAttribute(hConsole, 112); Progress = (long double)data.size() / datalenght; ProgressBar(Progress, Barwidth); time = 1'000 * static_cast<double>(stop.QuadPart - begin.QuadPart) / (ProgramFrequency.QuadPart); SetConsoleTextAttribute(hConsole, 15)(); long double time_rem{ (time / Progress) * (1 - Progress) }; long double time_seconds{ (long double)time_rem / 1'000 }; wostringstream stream; stream << fixed << setprecision(1) << time_seconds; wcout << L << stream.str(); wcout << L; } iter++; mtx.unlock(); } ); SetConsoleCursorPosition(hConsole, { 0, 0 }); wcout << wstring(Barwidth + 11, L) << L; thread t1([&data]() { GeneralizedHeapSort(data); lock_guard<mutex> lock(mtx); IsDone = true; cv.notify_one(); } ); thread t2(CS_CenterPrinter); if (t2.joinable()) t2.join(); if (t1.joinable()) t1.join(); system(); SetConsoleCursorInfo(hConsole, &cursor); for (auto& member : data) member.printf(); DECLARE_TIME_POINT(end); wcout << L; wcout << 1'000 * static_cast<double>(end.QuadPart - begin.QuadPart) / (ProgramFrequency.QuadPart); wcout << L; } else { SetConsoleCursorInfo(hConsole, &cursor); DECLARE_TIME_POINT(begin); for (ptrdiff_t set = LowerBound; set < UpperBound; ++set) data << NumberData{ CPU(set) }; for (auto& member : data) member.printf(); wcout << L; DECLARE_TIME_POINT(end); wcout << 1'000 * static_cast<double>(end.QuadPart - begin.QuadPart) / (ProgramFrequency.QuadPart); wcout << L; } PRINTN = true; Beep(750, 100); Beep(650, 75); Beep(550, 50); wcout << L; argc = _getch() == L ? Random : NotAssigned; return; } template<typename Type = wstring> static polynomial<> DecompPolynomial(switchcase& argc, Type Polynomial) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); SetConsoleTextAttribute(hConsole, 14); wstring pol; polynomial<> HT; bool empty{ true }, Xout{ false }, input{ Polynomial == Type() }; const constexpr bool CheckSafe{ is_same_v<Type, wstring> }; if constexpr (CheckSafe) if (input) { wcout << L; SetConsoleTextAttribute(hConsole, 12); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 4); wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); } do { bool draw{ false }; if (!RunMonitor) goto RETURN; if constexpr (CheckSafe) if (input) { empty = true; Xout = false; wstring Message; do { GetConsoleScreenBufferInfo(hConsole, &csbi)(); draw = false; bool wrong{ true }; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; wcout << L; do { Polynomial = GetLine(Polynomials); wcout << L; } while (Polynomial.empty()); if (Polynomial.at(0) == L) { Polynomial.erase(0, 1); draw = true; } if (Polynomial == L) { argc = Random; HT = {}; goto RETURN; } argc = ConvertWStringToEnum(Polynomial); ReassigneEnum(argc); if (argc != NotAssigned) { system(); SetConsoleTitle(Polynomial.c_str()); HT = {}; goto RETURN; } if (Polynomial == L) { BOOLALPHA = true; wrong = false; } if (Polynomial == L) { BOOLALPHA = false; wrong = false; } if (!wrong) wcout << Polynomial << L; for (ptrdiff_t i = Polynomial.size() - 1; i >= 0; --i) if (Polynomial.at(i) == L or Polynomial.at(i) == L) Polynomial.erase(i, 1); Message = Polynomial.empty() ? L : PolynomialSyntaxDirector(Polynomial); if (!Message.empty() and wrong) { SetConsoleTextAttribute(hConsole, 12); wcout << Message << L; SetConsoleTextAttribute(hConsole, 15)(); } } while (!Message.empty()); if (Polynomial == L) break; } polynomial<> BackT, Back_T{ HT }; polynomial<big> bigHT; tensor<int> null, Null; ptrdiff_t Coeff{ 1 }; int size; if constexpr (CheckSafe) { bigHT = GetMonomialsAssister(Polynomial); tensor<big> ListOfCoefficients; for (auto fact : bigHT) for (auto mon : fact) if (mon.exp[0] >= 0) ListOfCoefficients << mon.coefficient; big G{ Gcd(ListOfCoefficients + tensor<big>{ LCM }).fabs() }; for (auto& fact : bigHT) for (auto& mon : fact) if (mon.exp[0] >= 0) mon.coefficient /= G; LCM /= G; if (input) charVariable = Variables.at(0); HT = FromBigToDefault(bigHT); if (HT >= 1) if (HT[0] >= 1) if (HT[0][0].exp[0] == -2) { if (input) { SetConsoleTextAttribute(hConsole, 2); wcout << L << bigHT << L; SetConsoleTextAttribute(hConsole, 64); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; continue; } else return {}; } if (Variables.find(L) != wstring::npos) { if (!input) return {}; SetConsoleTextAttribute(hConsole, 2); wcout << L; wcout << PolynomialMultiply<big>(bigHT).str() << L; SetConsoleTextAttribute(hConsole, 64); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; continue; } } else if constexpr (is_same_v<Type, factor<>>) HT = { Polynomial }; else if constexpr (is_same_v<Type, polynomial<>>) HT = Polynomial; wstring _polynomial; if constexpr (CheckSafe) _polynomial = Polynomial; Null(Variables.size(), 0); null(Variables.size(), 0); null[0] = -1; for (const auto& poly_data : HT) if (poly_data.empty()) { _polynomial = L; break; } if (HT.empty()) _polynomial = L; else if (_polynomial != L) _polynomial = HT.str(); if (input) { SetConsoleTextAttribute(hConsole, 2); if (_polynomial.empty()) _polynomial = L; wcout << L << _polynomial << L; } size = HT.size(); if (_polynomial == L) { if (input) { SetConsoleTextAttribute(hConsole, 15)(); wcout << ; } goto EndOfDecomposition; } Back_T = HT; HT.clear(); for (const auto& polydata : Back_T) HT += Total(polydata); for (ptrdiff_t i = HT.size() - 1; i >= 0; --i) if (HT[i] == 1) if (HT[i][0].exp == Null) { Coeff *= HT[i][0].coefficient; HT.erase(HT.begin() + i); if (Coeff >= 2'147'483'647 or Coeff <= -2'147'483'647) { if (!input) return {}; SetConsoleTextAttribute(hConsole, 2); wcout << L << bigHT << L; SetConsoleTextAttribute(hConsole, 64); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; continue; } } if (HT.empty()) HT = polynomial<>{ { { (long double)Coeff, Null } } }; else if (abs(Coeff) != 1) HT >> factor<>{ { (long double)Coeff, Null } }; else if (Coeff == -1) for (auto& mon : HT[0]) mon.coefficient *= -1; HT.close(); _polynomial = HT.str(); if (HT != size and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 12); wcout << L << _polynomial << L; empty = false; } do { Back_T = HT; pol = _polynomial; auto polydata{ HT.last() }; polydata.SortByDegree(); HT--; HT += Partial(polydata); HT.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 4); wcout << L << _polynomial << L; empty = false; } HT.close(); Back_T = HT; HT.clear(); for (const auto& a : Back_T) HT += Binomial(a); HT.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 3); wcout << L; wcout << _polynomial << L; empty = false; } Back_T = HT; HT.clear(); for (const auto& a : Back_T) HT += Trinomial(a); HT.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 9); wcout << L; wcout << _polynomial << L; empty = false; } Back_T = HT; HT.clear(); int extend{ 1 }; for (const auto& a : Back_T) { if (a[0].exp[0] < 0) { extend = a[0].coefficient; continue; } BackT = SquareDifference(a); for (const auto& b : BackT) { if (extend > 1) HT << factor<>{ { (long double)extend, null } }; HT << b; } extend = 1; } HT.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 5); wcout << L; wcout << _polynomial << L; empty = false; } for (auto& poldata : HT) poldata.SortByExponents(); pol = HT.str(); Back_T = HT; HT.clear(); extend = 1; for (const auto& a : Back_T) { if (a[0].exp[0] < 0) { extend = a[0].coefficient; continue; } BackT = Ruffini(a); if (!a.empty() and BackT.empty()) { Xout = true; break; } for (const auto& b : BackT) { if (extend > 1) HT << factor<>{ { (long double)extend, null } }; HT << b; } extend = 1; } HT.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 6); wcout << L; wcout << _polynomial << L; empty = false; } } while (_polynomial != pol); Back_T = HT; HT.clear(); for (const auto& a : Back_T) HT += CompleteTheSquare(a); HT.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 79); wcout << L << _polynomial; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; empty = false; } Back_T = HT; HT.clear(); for (const auto& a : Back_T) HT += TrinomialSquare(a); T.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 79); wcout << L << _polynomial; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; empty = false; } if (empty and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 15)(); wcout << L; } if (Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 64); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; } if (CheckSafe and input and draw) switch (Variables.size()) { case 1: if (CreateGraph( { { PolynomialMultiply(HT) }, { { { 1, Null } } } } )) while (CreateGraph()); break; case 2: Project3DGraph( { { PolynomialMultiply(HT) }, { { { 1, { Null } } } } } ); break; } EndOfDecomposition: if (!(CheckSafe and input)) break; } while (CheckSafe and input); argc = NotAssigned; RETURN: if (CheckSafe and input) { { lock_guard<mutex> lk(MonitorMTX); RunMonitor = false; } MonitorCV.notify_all(); } return HT; } static void DecompAndSolve(switchcase& argc) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); SetConsoleTextAttribute(hConsole, 14); wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 12); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 10); wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); bool startover{ true }; tensor<wstring> VariablesDisposition; tensor<Fraction<>> Fractions; for (;;) { argc = NotAssigned; while (GetAsyncKeyState(VK_SHIFT) & 0x8000 or GetAsyncKeyState(VK_RETURN) & 0x8000); if (!RunMonitor) goto RETURN; insert: if (startover) { Variables = L; wcout << L; wcout << L; } startover = false; wstring err; bool _graph, _equation, skip{ false }; Fraction<big> inputed{ Expression().in(argc, err, _graph, _equation) }; Fraction<> it{ FromBigToDefault(inputed.num), FromBigToDefault(inputed.den) }; VariablesDisposition << Variables; if (argc != NotAssigned) { auto redirect{ ConvertEnumToWString(argc) }; if ( argc != FactorPolynomial and argc != FractElaborator and it != Fraction<>{} ) { tensor<long double> zero(Variables.size(), 0); ptrdiff_t Num{ 1 }, Den{ 1 }; for (size_t i = 0; i < it.num; ++i) Num *= it.num[i](zero); for (size_t i = 0; i < it.den; ++i) Den *= it.den[i](zero); if (Den == 0) { argc = NotAssigned; goto RETURN; } wchar_t sign = (Num > 0) xor (Den > 0) ? L : L; Num = abs(Num); Den = abs(Den); SendString( wstring(1, sign) + to_wstring(Num) + L + to_wstring(Den) ); INPUT inputs[2]{}; inputs[0].type = INPUT_KEYBOARD; inputs[0].ki.wVk = VK_RETURN; inputs[1] = inputs[0]; inputs[1].ki.dwFlags = KEYEVENTF_KEYUP; SendInput(2, inputs, sizeof(INPUT)); system(); SetConsoleTitle(redirect.c_str()); goto RETURN; } if (it.num != polynomial<>{ { { 0, tensor<int>(Variables.size(), 0) } } }) { bool saved{ BOOLALPHA }; BOOLALPHA = false; SendString(it.num.str()); if (argc != FactorPolynomial) { INPUT inputs[2]{}; inputs[0].type = INPUT_KEYBOARD; inputs[0].ki.wVk = VK_DOWN; inputs[0].ki.dwFlags = KEYEVENTF_EXTENDEDKEY; inputs[1] = inputs[0]; inputs[1].ki.dwFlags |= KEYEVENTF_KEYUP; SendInput(2, inputs, sizeof(INPUT)); SendString(it.den.str()); } BOOLALPHA = saved; INPUT inputs[2]{}; inputs[0].type = INPUT_KEYBOARD; inputs[0].ki.wVk = VK_RETURN; inputs[1] = inputs[0]; inputs[1].ki.dwFlags = KEYEVENTF_KEYUP; SendInput(2, inputs, sizeof(INPUT)); } system(); SetConsoleTitle(redirect.c_str()); goto RETURN; } if (it == Fraction<>{}) { if (err.empty()) break; if (err == L) { argc = Random; goto RETURN; } SetConsoleTextAttribute(hConsole, 4); wcout << L << err << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); startover = true; continue; } Fractions << it; if ((GetAsyncKeyState(VK_SHIFT) & 0x8000) and Fractions < 5) continue; bool Continue{ false }; wstring complete; for (auto& disp : VariablesDisposition) for (const auto& ch : disp) if (complete.find(ch) == wstring::npos) complete += ch; for (auto& disp : VariablesDisposition) for (const auto& ch : complete) if (disp.find(ch) == wstring::npos) disp += ch; or (auto& fraction : Fractions) { for (auto& fact : fraction.num) for (auto& mon : fact) mon.exp(complete.size()); for (auto& fact : fraction.den) for (auto& mon : fact) mon.exp(complete.size()); } tensor<int> ExpNull(complete.size(), 0); for (size_t i = 0; i < 2 * Fractions.size(); ++i) { if (VariablesDisposition[i / 2] == complete) continue; auto& old = i % 2 ? Fractions[i / 2].den : Fractions[i / 2].num; polynomial<> correct(old.size()); for (size_t j = 0; j < correct; ++j) for (const auto& mono : old[j]) correct[j] << monomial<>{ mono.coefficient, ExpNull }; for (size_t j = 0; j < VariablesDisposition[i / 2].size(); ++j) { auto pos{ complete.find(VariablesDisposition[i / 2].at(j)) }; if (pos == wstring::npos) continue; for (size_t k = 0; k < correct; ++k) for (size_t l = 0; l < correct[k]; ++l) correct[k][l].exp[pos] = old[k][l].exp[j]; } old = correct; } VariablesDisposition.clear(); if (Variables.size() > Fractions.size() + 1) { SetConsoleTextAttribute(hConsole, 12); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); startover = true; continue; } if (Fractions == 1 and !_equation) { auto It{ Fractions[0] }; f (!It.num.empty()) if (!It.num[0].empty()) if (It.num[0][0].coefficient == 0) break; if (!it.num.empty()) if (!it.num[0].empty()) if (it.num[0][0].coefficient == 0) break; CORRECTION_RATIO = 1; Fraction<> fraction; fraction.num = DecompPolynomial(usefree, it.num); big DenMultiplier = LCM; auto savx{ Variables }; fraction.den = DecompPolynomial(usefree, it.den); big NumMultiplier = LCM, GCD{ Gcd(NumMultiplier, DenMultiplier) }; NumMultiplier /= GCD; DenMultiplier /= GCD; auto nummultiplier{ NumMultiplier.Number<long double>() }; auto denmultiplier{ DenMultiplier.Number<long double>() }; if (!(fraction.num and fraction.den) or isnan(nummultiplier) or isnan(denmultiplier)) { wcout << L; SetConsoleTextAttribute(hConsole, 64); wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; goto insert; } auto Backup{ fraction }; int NCOEFF{ 1 }, DCOEFF{ 1 }; tensor<int> null(Variables.size(), 0); Simplify(fraction, NCOEFF, DCOEFF); NCOEFF *= nummultiplier; DCOEFF *= denmultiplier; LCM = 1; auto test{ fraction.num }; if (!(fraction.num or fraction.den)) charVariable = L; else if (fraction.num.empty()) test = fraction.den; if (fraction.num or fraction.den) for (size_t i = 0; i < Variables.size(); ++i) if (test[0][0].exp[i] != 0) charVariable = Variables.at(i); auto NScomp{ To1V(fraction.num) }; auto DScomp{ To1V(fraction.den) }; NScomp.close(); DScomp.close(); for (size_t i = 0; i < NScomp; ++i) NScomp[i].sort(); for (size_t i = 0; i < DScomp; ++i) DScomp[i].sort(); if (DScomp <= 1) skip = true; if (!skip) for (auto a : DScomp) for (auto b : a) if (a != 1 and b.degree > 1) skip = true; bool IsAModifier{ false }, HasMoreVariables{ false }; tensor<POLYNOMIAL<>> denominators; POLYNOMIAL<> complementaries; size_t index{}, size{}; int Det{ 1 }; Matrix<int> Matrix; tensor<int> results; tensor<double> roots; FACTOR<> Quotient, Rest; if (fraction.num != ToXV(NScomp) or fraction.den != ToXV(DScomp)) { skip = true; HasMoreVariables = true; goto PrintStatement; } if (!skip) for (size_t i = 0; i < DScomp; ++i) { if (DScomp[i][0].degree == -1) { IsAModifier = true; continue; } if (IsAModifier) for (ptrdiff_t j = DScomp[i - 1][0].coefficient; j > 0; --j) { denominators++; if (j > 1) denominators[index] << FACTOR<>{ { -1, (long double)j } }; denominators[index] << DScomp[i]; index++; complementaries << Complementary(DScomp, DScomp[i], j); } else if (DScomp[i] == 1) for (ptrdiff_t j = DScomp[i][0].degree; j > 0; --j) { denominators++; denominators[index] << FACTOR<>{ { (int)j, 1 } }; index++; auto NewScomp{ DScomp }; NewScomp.erase(NewScomp.begin() + i); NewScomp.insert(NewScomp.begin() + i, { { 1, 1 } }); NewScomp.insert(NewScomp.begin() + i, { { -1, (long double)DScomp[i][0].degree } }); complementaries << Complementary(NewScomp, NewScomp[i + 1], j); } else { denominators++; denominators[index] << DScomp[i]; index++; complementaries << Complementary(DScomp, DScomp[i], 1); } IsAModifier = false; } if (!skip) for (size_t i = 0; i < complementaries; ++i) complementaries[i].complete(complementaries.size()); if (!skip) { size = complementaries.size(); Matrix(size); for (size_t i = 0; i < complementaries; ++i) for (size_t j = 0; j < complementaries; ++j) Matrix[i] << complementaries[i][j].coefficient; } if (!skip) { PolynomialDivide( To1V(PolynomialMultiply, Polynomial(ToXV(PolynomialMultiply, NScomp))), V1converter(PolynomialMultiply, DScomp), Quotient, Rest ); Rest.complete(complementaries.size() - 1); Rest.sort(); for (const auto& R : Rest) results << R.coefficient; while (results.size() < complementaries.size()) results >> 0; Det = Matrix.det(); } if (!skip) for (size_t i = 0; i < results; ++i) { ::Matrix<int> MX{ Matrix }; MX[i] = results; roots << (double)MX.det() / Det; } for (ptrdiff_t i = denominators.size() - 1; i >= 0; --i) if (roots[i] == 0) { denominators.erase(denominators.begin() + i); roots.erase(roots.begin() + i); } if (roots.empty()) skip = true; PrintStatement: SetConsoleTextAttribute(hConsole, 11); wcout << L; SetConsoleTextAttribute(hConsole, 10); tensor<wstring> C_E_; bool HasBeenPrinted{ false }; COORD cursorPos; for (const auto& d : Backup.den) { auto Ctemp_{ EquationSolver(d) }; for (const auto& i : Ctemp_) C_E_ << i; } for (ptrdiff_t i = C_E_.size() - 1; i >= 0; --i) for (ptrdiff_t j = i - 1; j >= 0; --j) if (C_E_[i] == C_E_[j]) C_E_.erase(C_E_.begin() + i); for (auto I : C_E_) { wcout << Handler(I) << L; HasBeenPrinted = true; } if (!HasBeenPrinted) wcout << L; GetConsoleScreenBufferInfo(hConsole, &csbi)(); cursorPos = csbi.dwCursorPosition; if (!HasBeenPrinted) { cursorPos.X = 0; cursorPos.Y--; SetConsoleCursorPosition(hConsole, cursorPos); } else wcout << L; auto DiseqSol{ DisequationSolutionPrinter( fraction.num, fraction.den, 15, NCOEFF < 0 or DCOEFF < 0 ) }; if (!DiseqSol.empty()) wcout << L << DiseqSol << L; SetConsoleTextAttribute(hConsole, 10); wcout << L; SetConsoleTextAttribute(hConsole, 12); int lines{}; PrintFractionaryResult( NCOEFF, DCOEFF, lines, fraction, NScomp, DScomp, HasMoreVariables, !skip, roots, denominators ); if (!skip) for (const auto& a : Quotient) { auto rest{ POLYNOMIAL<>{ { a } } }; if (a.coefficient == 0) continue; if (integer(a.coefficient / CORRECTION_RATIO)) { rest[0][0].coefficient /= CORRECTION_RATIO; auto pol{ rest.str() }; ElabExponents(pol); bool IsMinus{ false }; if (pol.at(0) == L) { pol.erase(0, 1); IsMinus = true; } if (pol.size() >= 2) if (pol.at(0) == and Last(pol) == ) { pol.pop_back(); pol.erase(0, 1); } if (pol.at(0) == L) { pol.erase(0, 1); IsMinus = true; } else if (pol.at(0) == L) pol.erase(0, 1); IsMinus ? wcout << L : wcout << L; wcout << L << pol << L; lines += 2 + pol.size(); } else { GetConsoleScreenBufferInfo(hConsole, &csbi)(); COORD dwCursorPos{ csbi.dwCursorPosition }; dwCursorPos.Y--; SetConsoleCursorPosition(hConsole, dwCursorPos); PrintFraction( 1, 1, lines, true, { { { { a.coefficient, null } } }, { { { 1, null } } } } ); GetConsoleScreenBufferInfo(hConsole, &csbi)(); dwCursorPos = csbi.dwCursorPosition; dwCursorPos.Y++; SetConsoleCursorPosition(hConsole, dwCursorPos); wstring power; if (a.degree > 0) power += charVariable; if (a.degree > 1) { power += L + to_wstring(a.degree); ElabExponents(power); } wcout << L << power << L; } } wcout << L; if (_graph) switch (Variables.size()) { case 1: if (CreateGraph(Backup.extend())) while (CreateGraph()); break; case 2: Project3DGraph(Backup.extend()); break; } SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); startover = true; continue; } polynomial<> equations; for (const auto& eq : Fractions) equations << eq.num[0]; for (auto& equation : equations) for (auto& mono : equation) mono.exp(Variables.size(), 0); if (Variables.size() == Fractions and Fractions == 1) { charVariable = Variables.at(0); Variables = L; auto solutions{ RootExtractor(equations) }; Variables = wstring(1, charVariable); r (ptrdiff_t i = solutions.size() - 1; i >= 0; --i) for (ptrdiff_t j = i - 1; j >= 0; --j) if (solutions[i] == solutions[j]) solutions.erase(solutions.begin() + i); for (ptrdiff_t i = solutions.size() - 1; i >= 0; --i) for (const auto& fract : Fractions) if (fabs(fract.den[0]({ solutions[i] })) < 1e-05) solutions.erase(solutions.begin() + i); SetConsoleTextAttribute(hConsole, 11); wcout << L << solutions << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } if (Variables.size() <= equations) { to solutions{ SystemSolver(tensor<factor<>>( equations.begin(), equations.begin() + Variables.size() )) }; SetConsoleTextAttribute(hConsole, 11); if (isnan(solutions[0][0])) { wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } r (ptrdiff_t i = solutions.size() - 1; i >= 0; --i) { if (solutions[i].empty()) continue; for (const auto& fract : Fractions) if (fract.den[0](solutions[i]) < 1e-05) solutions.erase(solutions.begin() + i); } if (solutions.empty()) { wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } if (solutions[0].empty()) { wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } for (ptrdiff_t i = solutions.size() - 1; i >= 0; --i) for (size_t j = Variables.size(); j < equations; ++j) if (fabs(equations[j](solutions[i])) > 1e-05) { solutions.erase(solutions.begin() + i); break; }  (solutions.empty()) { wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } wcout << L; for (const auto& sol : solutions) { wcout << L; for (size_t i = 0; i < Variables.size(); ++i) { wcout << L << Variables.at(i); wcout << L << sol[i] << L; } wcout << L; } SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } int pIndex{ -1 }; wstring VarOrder; tensor<int> VariablePos; const wstring VariablePriority{ L }; for (const auto& var : VariablePriority) { auto pos{ Variables.find(var) }; if (pos != wstring::npos) { VarOrder += var; VariablePos << pos; } } ptrdiff_t ParameterIndex = VarOrder.size() - 1; for (; ParameterIndex >= 0; --ParameterIndex) { for (const auto& eq : equations) { for (size_t i = 0; i < eq; ++i) { int deg{}; for (size_t j = 0; j < VarOrder.size(); ++j) { if (j == ParameterIndex) continue; deg += eq[i].exp[VariablePos[j]]; } if (deg > 1) { Continue = true; break; } } if (Continue) break; } if (Continue) { Continue = false; continue; } pIndex = VariablePos[ParameterIndex]; charVariable = Variables.at(pIndex); break; } if (pIndex < 0) { Fractions.clear(); equations.clear(); startover = true; continue; } size_t Vsize{ Variables.size() }, I{}; tensor<int> null(Vsize, 0); tensor<factor<>> KnownTerms(Vsize); for (size_t i = 0; i < equations;) { if (I == pIndex) { I++; continue; } for (size_t j = 0; j < equations[i]; ++j) { auto exps{ equations[i][j].exp }; exps[pIndex] = 0; if (exps == null) { auto mon{ equations[i][j] }; mon.coefficient *= -1; KnownTerms[I] << mon; } } i++; I++; } I = 0; bool Break{ false }; Matrix<factor<>> system(Vsize, tensor<factor<>>(Vsize)); for (size_t i = 0; i < equations;) { for (size_t j = 0; j < equations[i]; ++j) { for (size_t k = 0; k < Vsize; ++k) { if (I == pIndex) { I++; Break = true; break; } if (k == pIndex) continue; auto mon{ equations[i][j] }; mon.exp[k] = 0; if (equations[i][j].exp[k] != 0) system[k][I] << mon; } if (Break) break; } if (Break) { Break = false; continue; } I++; i++; } KnownTerms.erase(KnownTerms.begin() + pIndex); system.erase(system.begin() + pIndex); for (auto& eq : system) eq.erase(eq.begin() + pIndex); tensor<Fraction<>> solve; tensor<polynomial<>> dets; auto D{ DecompPolynomial(usefree, system.det()) }; auto ProblematicPoints{ RootExtractor(D) }; tensor<long double> Zeros; for (size_t i = 0; i < Vsize - 1; ++i) { to mx{ system }; mx[i] = KnownTerms; dets << DecompPolynomial(usefree, mx.det()); to NewZeros{ RootExtractor(dets.last()) }; for (const auto& zero : NewZeros) { tinue = false; for (const auto& OtherZero : Zeros) if (fabs(OtherZero - zero) < 1e-05) { Continue = true; break; } if (Continue) continue; Zeros << zero; } } if (D.empty()) { SetConsoleTextAttribute(hConsole, 11);  (dets == tensor<polynomial<>>(dets.size())) { wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } for (const auto& det : dets) solve << Fraction<>{ det, D }; wcout << L; int line{}; bool skipped{ false }; for (size_t i = 0; i < Vsize; ++i) { if (i == pIndex) { skipped = true; continue; } int ncoeff{ 1 }, dcoeff{ 1 }; auto& resolution{ solve[i - skipped] }; Simplify(resolution, ncoeff, dcoeff); auto NScomp{ To1V(resolution.num) }; auto DScomp{ To1V(resolution.den) }; NScomp.close(); DScomp.close(); for (size_t j = 0; j < NScomp; ++j) NScomp[j].sort(); for (size_t j = 0; j < DScomp; ++j) DScomp[j].sort(); SetConsoleTextAttribute(hConsole, 11); wcout << Variables.at(i) << L; PrintFractionaryResult( ncoeff, dcoeff, line, resolution, NScomp, DScomp, resolution.num != ToXV(NScomp) or resolution.den != ToXV(DScomp) ); wcout << L; if (i != Vsize - 1) wcout << L; } ool starting{ true }; SetConsoleTextAttribute(hConsole, 6); for (const auto& p : ProblematicPoints) { Continue = false; for (const auto& zero : Zeros) if (fabs(p - zero) < 1e-05) { if (starting) { starting = false; wcout << L; } wcout << L << charVariable << L << Handler(to_wstring(p)); wcout << L; Continue = true; } if (Continue) continue; if (starting) { starting = false; wcout << L; } wcout << L << charVariable << L << Handler(to_wstring(p)); wcout << L; } SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; } argc = NotAssigned; RETURN: { lock_guard<mutex> lk(MonitorMTX); RunMonitor = false; } MonitorCV.notify_all(); } static void DecompMatrices(switchcase& argc) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); SetConsoleTextAttribute(hConsole, 14); wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 12); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Matrix<> matrix, Mx; for (;;) { SetConsoleTextAttribute(hConsole, 15)(); wcout << L; for (;;) { wstring err; if (matrix.input(err)) break; wcout << L; SetConsoleTextAttribute(hConsole, 4); wcout << err << L; SetConsoleTextAttribute(hConsole, 15)(); } size_t size{ matrix.size() }; if (size == 0) { argc = Random; goto RETURN; } if (matrix == Matrix<>(size, tensor<long double>(size, 0))) break; Mx = matrix; SetConsoleTextAttribute(hConsole, 2); wcout << L; matrix.output({ 0, -2 }, __NULL__, 2); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); auto Id{ Matrix<>(size, tensor<long double>(size, 0)) }; for (size_t i = 0; i < size; ++i) Id[i][i] = 1; auto permutator{ Id }; for (size_t i = 0; i + 1 < size; ++i) { int max = Mx[size - 1][i], IndexofMax = size - 1; for (ptrdiff_t j = size - 2; j >= i; --j) { if (j < 0) break; if (Mx[j][i] > max) { max = Mx[j][i]; IndexofMax = j; } } if (IndexofMax != i) { swap(Mx[IndexofMax], Mx[i]); swap(permutator[IndexofMax], permutator[i]); } } auto NewPermutator{ Matrix<>(size) }; for (size_t i = 0; i < size; ++i) for (size_t j = 0; j < size; ++j) NewPermutator[i] << permutator[j][i]; permutator = NewPermutator; auto lower{ Id }; auto upper{ Mx }; bool Break{ false }; for (size_t i = 0; i + 1 < size; ++i) { r (size_t j = i + 1; j < size; ++j) { (upper[i][i] == 0) { Break = true; break; } lower[j][i] = upper[j][i] / upper[i][i]; for (size_t k = 0; k < size; ++k) upper[j][k] -= lower[j][i] * upper[i][k]; } if (Break) break; } if (!Break) { wcout << L; permutator.DisplayWith(lower, upper); } Mx = matrix; auto ortogonal{ Id }; Break = false; for (size_t i = 0; i < size; ++i) { for (size_t j = i + 1; j < size; ++j) if (Mx[j][i] != 0) { long double norm{ hypot(Mx[j][i], Mx[j - 1][i]) }; if (norm == 0) { Break = true; break; } long double cosine{ Mx[j - 1][i] / norm }, sine{ Mx[j][i] / norm }; auto givens{ Id }; givens[i][i] = cosine; givens[i][j] = sine; givens[j][i] = -sine; givens[j][j] = cosine; Mx = givens * Mx; ortogonal *= givens; } if (Break) break; } if (!Break) { wcout << L; ortogonal.DisplayWith(Mx); } Mx = matrix; lower = Id; Break = false; for (size_t i = 0; i < size; ++i) { for (size_t j = 0; j <= i; ++j) { double sum{}; if (i == j) { for (size_t k = 0; k < i; ++k) sum += lower[i][k] * lower[i][k]; lower[i][i] = sqrt(Mx[i][i] - sum); } if (lower[i][i] == 0 or isnan(lower[i][i])) { Break = true; break; } if (i != j) { for (size_t k = 0; k < i; ++k) sum += lower[i][k] * lower[j][k]; lower[i][j] = (Mx[i][j] - sum) / lower[j][j]; } } if (Break) break; } auto lowerT{ Matrix<>(size) }; if (!Break) for (size_t i = 0; i < size; ++i) for (size_t j = 0; j < size; ++j) lowerT[i] << lower[j][i]; if (!Break) { wcout << L; lower.DisplayWith(lowerT); } Mx = matrix; auto MxT{ Id }; for (size_t i = 0; i < size; ++i) for (size_t j = 0; j < size; ++j) MxT[i][j] = Mx[j][i]; auto Mx_MxT{ Mx * MxT }; auto MxT_Mx{ MxT * Mx }; auto EigenV{ Mx_MxT.EigenValues() }; auto sigma{ Id }; Break = EigenV.size() != size; Matrix<> U, V; if (!Break) { for (size_t i = 0; i < size; ++i) sigma[i][i] = sqrt(EigenV[i]); U = Mx_MxT.EigenVectors(EigenV); V = MxT_Mx.EigenVectors(); if (V.empty()) Break = true; else { auto NewV{ Id }; for (size_t i = 0; i < size; ++i) for (size_t j = 0; j < size; ++j) NewV[i][j] = V[j][i]; V = NewV; } } if (!Break) { wcout << L; U.DisplayWith(sigma, V); } auto maindet{ matrix.det() }; wcout << L << maindet << L; auto eigenvalues{ matrix.EigenValues() }; wcout << L << eigenvalues << L; auto eigenvectors{ matrix.EigenVectors(eigenvalues) }; if (eigenvectors == size) { wcout << L; for (auto vector : eigenvectors) wcout << vector << L; wcout << L; } if (maindet == 0) { wstring varlist{ L }; tensor<double> solutionList; auto NewMatrix{ matrix }; for (auto& row : NewMatrix) row--; NewMatrix--; auto newdet{ NewMatrix.det() }; if (newdet == 0) continue; for (size_t i = 0; i < size - 1; ++i) { Mx = NewMatrix; for (size_t j = 0; j < size - 1; ++j) Mx[j][i] = matrix[j].last(); solutionList << Mx.det() / newdet; } wcout << L; for (size_t i = 0; i < size - 1; ++i) wcout << varlist[i] << L << solutionList[i] << L; wcout << L; } } argc = NotAssigned; RETURN: { lock_guard<mutex> lk(MonitorMTX); RunMonitor = false; } MonitorCV.notify_all(); } 