using namespace std; using namespace _STD chrono; using Concurrency::parallel_for, this_thread::sleep_for; int __NULL__ = 0; HANDLE hConsole = GetStdHandle(0); HANDLE hConsoleInput = GetStdHandle(0); CONSOLE_CURSOR_INFO cursorInfo{ 10, FALSE }; CONSOLE_CURSOR_INFO cursor{ 10, TRUE }; CONSOLE_SCREEN_BUFFER_INFO csbi; static wchar_t charVariable(0); ptrdiff_t GlobalMax(0); const ptrdiff_t GLOBAL_CAP(0); bool BOOLALPHA(0); bool PRINTN(0); double CORRECTION_RATIO(0); atomic_bool GlobalInterr(0); atomic_bool interrupted(0); atomic_bool computing(0); atomic_bool IsDone(0); atomic_bool RunMonitor(0); condition_variable cv, Cv, MonitorCV; mutex CoutMutex, mtx, MonitorMTX; COORD Min{ 25, 15 }; LARGE_INTEGER ProgramFrequency; struct compost { ptrdiff_t factors; int exp; }; struct divisor { ptrdiff_t DivNumber{ 1 }; ptrdiff_t DivSum{ 1 }; ptrdiff_t DivProduct{ 1 }; wstring Div_pr; }; struct digitRatio { int digitSumRatioNum{}; int digitSumRatioDen{}; int digitProductRatioNum{}; int digitProductRatioDen{}; }; digitRatio items; struct coord { double X; double Y; coord() : X(0), Y(0) {} coord(double _x, double _y) : X(_x), Y(_y) {} coord(COORD _coord) : X(_coord.X), Y(_coord.Y) {} operator COORD() const {} }; enum switchcase { DoSimpleCode , DoComplexCode , DoSimpleFactor , DoComplexFactor , DoCodeFactor , DoAll , DebugSimpleCode , DebugComplexCode , DebugSimpleFactor , DebugComplexFactor , DebugCodeFactor , DebugAll , DebugDigits , DebugDigitsAndCode , DebugDigitsAndFactor, DebugComplete , ConvertCodeInverse , SeriesExpansion , FactorPolynomial , FractElaborator , FactorMatrix , Random , NotAssigned }; switchcase usefree; unordered_map<wstring, switchcase> stringToEnumMap { { L , switchcase::DoSimpleCode }, { L, switchcase::DoComplexCode }, { L , switchcase::DoSimpleFactor }, { L, switchcase::DoComplexFactor }, { L, switchcase::DoCodeFactor }, { L , switchcase::DoAll }, { L , switchcase::DebugSimpleCode }, { L, switchcase::DebugComplexCode }, { L , switchcase::DebugSimpleFactor }, { L, switchcase::DebugComplexFactor }, { L, switchcase::DebugCodeFactor }, { L , switchcase::DebugAll }, { L , switchcase::DebugDigits }, { L, switchcase::DebugDigitsAndCode }, { L, switchcase::DebugDigitsAndFactor }, { L, switchcase::DebugComplete }, { L, switchcase::ConvertCodeInverse }, { L, switchcase::SeriesExpansion }, { L, switchcase::FactorPolynomial }, { L, switchcase::FractElaborator }, { L, switchcase::FactorMatrix }, { L, switchcase::Random } }; unordered_map<switchcase, wstring> enumToStringMap { { switchcase::DoSimpleCode , L }, { switchcase::DoComplexCode , L }, { switchcase::DoSimpleFactor , L }, { switchcase::DoComplexFactor , L }, { switchcase::DoCodeFactor , L }, { switchcase::DoAll , L }, { switchcase::DebugSimpleCode , L }, { switchcase::DebugComplexCode , L }, { switchcase::DebugSimpleFactor , L }, { switchcase::DebugComplexFactor , L }, { switchcase::DebugCodeFactor , L }, { switchcase::DebugAll , L }, { switchcase::DebugDigits , L }, { switchcase::DebugDigitsAndCode , L }, { switchcase::DebugDigitsAndFactor, L }, { switchcase::DebugComplete , L }, { switchcase::ConvertCodeInverse , L }, { switchcase::SeriesExpansion , L }, { switchcase::FactorPolynomial , L }, { switchcase::FractElaborator , L }, { switchcase::FactorMatrix , L }, { switchcase::Random , L } }; unordered_map<wstring, wstring> ConvertFromSuperScript { { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, }; wstring Variables{ L }; using _TENSOR tensor, _TENSOR tensor_t; template<typename T> static bool Smaller(const T& A, const T& B) {} template<typename T> static ptrdiff_t BinarySearch(const tensor<T>& arr, const T target) {} template<typename Ty> class complex { public: Ty RealPart; Ty ImaginaryPart; Ty norm() const {} complex() : RealPart(0), ImaginaryPart(0) {} complex(Ty real) : RealPart(real), ImaginaryPart(0) {} complex(Ty real, Ty imag) : RealPart(real), ImaginaryPart(imag) {} inline complex conjugate() const {} inline complex opposite() const {} complex operator+(complex value) const {} inline complex& operator+=(complex value) {} inline complex& operator++() {} inline complex& operator++(0) {} complex operator-(complex value) const {} inline complex& operator-=(complex value) {} inline complex& operator--() {} inline complex& operator--(0) {} complex operator*(complex value) const {} inline complex& operator*=(complex value) {} complex operator/(complex value) const {} inline complex operator/=(complex value) {} wstring str() const {} friend wostream& operator<<(wostream& os, const complex& obj) {} }; template<typename Ty> static complex<Ty> InitExponentialForm(Ty radius, Ty angle) {} tensor<complex<long double>> Omega; static void FFT(tensor<complex<long double>>& List, bool inverse) {} class big { private: tensor<int> Integer; bool sign; long double decimal; void construct(ptrdiff_t param) {} bool compare(const big& A, const big& B) const {} big Add(const big& __This, const big& __Val, bool changesign) const {} big Sub(const big& __This, const big& __Val, bool changesign) const {} big AlgebricOperation1(const big& A, const big& B, bool Sign) const {} big FFT_Multiplication(const big& value) const {} public: template<typename t> t Number() {} big() : sign(false), Integer(0), decimal(0) {} big(int param) : sign(param < 0), Integer(0), decimal(0) {} big(ptrdiff_t param) : sign(param < 0), Integer(0), decimal(0) {} big(double param) : sign(param < 0), Integer(0), decimal(0) {} big(long double param) : sign(param < 0), Integer(0), decimal(0) {} big(tensor<int> Big) : sign(false), Integer(Big), decimal(0) {} big(wstring wstr) : sign(false), Integer(0), decimal(0) {} big& operator=(const big& other) {} inline bool operator==(const big& other) const {} inline bool operator!=(const big& other) const {} bool operator<(const big& other) const {} inline bool operator<=(const big& other) const {} inline bool operator>=(const big& other) const {} inline bool operator>(const big& other) const {} big operator+(const big& value) const {} inline big& operator+=(const big& value) {} inline big& operator++() {} inline big& operator++(0) {} big operator-(const big& value) const {} inline big& operator-=(const big& value) {} inline big& operator--() {} inline big& operator--(0) {} big operator<<(int shift) const {} inline big& operator<<=(int shift) {} big operator>>(int shift) const {} inline big& operator>>=(int shift) {} big operator*(const big& value) const {} inline big& operator*=(const big& value) {} big operator/(const big& value) const {} inline big& operator/=(const big& value) {} big operator%(const big& value) const {} inline big& operator%=(const big& value) {} big operator^(const big& exp) const {} inline big& operator^=(const big& exp) {} inline bool intg() const {} inline big fabs() const {} inline big floor() {} inline big ceil() {} inline big round() {} inline big invert() {} inline int log(int base) {} wostringstream c_str(int precision) const {} inline wstring str() const {} friend wostream& operator<<(wostream& os, const big& obj) {} }; static big pow(big x, int y) {} big LCM(0); static void ClearArea(COORD WinCenter, COORD Dimensions); template<typename T> void GeneralizedHeapify(tensor<T>& arr, int n, int i) {} template<typename T> void GeneralizedHeapSort(tensor<T>& arr) {} static tensor<compost> DecomposeNumber(ptrdiff_t input); class radical { int coefficient; ptrdiff_t Arg; tensor<int> primes; public: radical() : coefficient(0), Arg(1), primes({ 1 }) {} radical(int coeff) : coefficient(coeff), Arg(1), primes({ 1 }) {} radical(int coeff, int arg) : coefficient(coeff), Arg(1), primes({ abs(arg) }) {} radical(int coeff, int arg, bool off) : coefficient(coeff), Arg(abs(arg)), primes({ abs(arg) }) {} int GetCoefficient() const {} void SetCoefficient(int NewCoefficient) {} void IncCoefficient(int increment) {} ptrdiff_t arg() const {} long double approximation() const {} void normalize() {} long double operator+(const radical& other) const {} long double operator-(const radical& other) const {} long double operator/(const radical& other) const {} radical operator*(const radical& other) const {} radical& operator*=(const radical& other) {} bool negative() const {} int len() const {} void write(WORD attrib, bool NoSign) const {} }; class RadicalSum { tensor<radical> elements; public: RadicalSum() : elements({ radical() }) {} RadicalSum(radical el) : elements({ el }) {} RadicalSum(tensor<radical> elems) : elements(elems) {} long double approximation() const {} void normalize() {} void NORMALIZE() {} long double operator/(const RadicalSum& other) const {} RadicalSum operator+(const RadicalSum& other) const {} RadicalSum& operator+=(const RadicalSum& other) {} RadicalSum operator-(const RadicalSum& other) const {} RadicalSum& operator-=(const RadicalSum& other) {} RadicalSum operator*(const RadicalSum& other) const {} RadicalSum& operator*=(const RadicalSum& other) {} int len() const {} void write(WORD attrib) const {} }; class RadicalFract { RadicalSum top, bottom; public: RadicalFract() : top(radical(0)), bottom(radical(1)) {} RadicalFract(RadicalSum Top) : top(Top), bottom(radical(1)) {} RadicalFract(RadicalSum Top, RadicalSum Bottom) : top(Top), bottom(Bottom) {} long double approximation() const {} RadicalFract operator+(const RadicalFract& other) const {} RadicalFract& operator+=(const RadicalFract& other) {} RadicalFract operator-(const RadicalFract& other) const {} RadicalFract& operator-=(const RadicalFract& other) {} RadicalFract operator*(const RadicalFract& other) const {} RadicalFract& operator*=(const RadicalFract& other) {} RadicalFract operator/(const RadicalFract& other) const {} RadicalFract& operator/=(const RadicalFract& other) {} void write(WORD wAttribute) const {} }; template<typename T_int = long double>struct MONOMIAL { int degree; T_int coefficient; bool operator == (const MONOMIAL& other) const {} }; template<typename T_int = long double>class monomial { public: T_int coefficient{}; tensor<int> exp; bool operator==(const monomial& other) const {} int degree() const {} bool IsSquare() const {} monomial Root(int order) const {} }; template<typename T_int = long double>class factor : public tensor<monomial<T_int>> { public: factor() {} factor(initializer_list<monomial<T_int>> init): tensor<monomial<T_int>>(init) {} factor(size_t size, const monomial<T_int>& initial_value) {} factor(size_t size) {} factor(tensor<monomial<T_int>> vect) {} void SortByDegree() {} void SortByExponents() {} factor derivate(size_t Vpos) const {} T_int operator()(tensor<long double> params) const {} factor operator()(T_int x, size_t Vpos, int) const; bool operator()(T_int x, size_t Vpos, bool) const {} inline factor neg() const {} inline factor operator-(const factor& other) const; inline factor operator*(const factor& other) const; inline factor& operator-=(const factor& other); inline factor& operator*=(const factor& other); _NODISCARD wstring str(int size) override {} friend wostream& operator<<(wostream& os, factor& obj) {} }; template<typename T_int = long double>class FACTOR : public tensor<MONOMIAL<T_int>> { public: FACTOR() {} FACTOR(initializer_list<MONOMIAL<T_int>> init): tensor<MONOMIAL<T_int>>(init) {} FACTOR(size_t size, const MONOMIAL<T_int>& initial_value) {} FACTOR(size_t size) {} FACTOR(tensor<MONOMIAL<T_int>> vect) {} void sort() {} void complete(int s) {} FACTOR derivate() const {} T_int operator()(T_int x) const {} inline FACTOR neg() const {} inline FACTOR operator-(const FACTOR& other) const; inline FACTOR operator*(const FACTOR& other) const; inline FACTOR& operator-=(const FACTOR& other); inline FACTOR& operator*=(const FACTOR& other); _NODISCARD wstring str(int size) override {} friend wostream& operator<<(wostream& os, const FACTOR& obj) {} }; static factor<> ToXV(FACTOR<> vect) {} static FACTOR<> To1V(factor<> vect) {} static wstring CTSuperScript(wchar_t input); static wstring CFSuperScript(wstring script); static wstring ElabExponents(wstring& str); static void DeduceFromExponents(wstring& str); template<typename T_int = long double>class polynomial : public tensor<factor<T_int>> { public: polynomial() {} polynomial(initializer_list<factor<T_int>> init): tensor<factor<T_int>>(init) {} polynomial(size_t size, const factor<T_int>& initial_value) {} polynomial(size_t size) {} polynomial(tensor<factor<T_int>> vect) {} void open() {} void close() {} _NODISCARD wstring str(int size) override {} friend wostream& operator<<(wostream& os, polynomial& obj) {} }; template<typename T_int = long double>class POLYNOMIAL : public tensor<FACTOR<T_int>> { public: POLYNOMIAL() {} POLYNOMIAL(initializer_list<FACTOR<T_int>> init): tensor<FACTOR<T_int>>(init) {} POLYNOMIAL(size_t size, const FACTOR<T_int>& initial_value) {} POLYNOMIAL(size_t size) {} POLYNOMIAL(tensor<FACTOR<T_int>> vect) {} void open() {} void close() {} _NODISCARD wstring str(int size) override {} friend wostream& operator<<(wostream& os, const POLYNOMIAL& obj) {} }; static polynomial<> ToXV(POLYNOMIAL<> vect) {} static POLYNOMIAL<> To1V(polynomial<> vect) {} static polynomial<> FromBigToDefault(polynomial<big> BigPolynomial) {} template<typename T_int = long double> static factor<T_int> PolynomialSum(factor<T_int> vect); template<typename T_int = long double> static factor<T_int> PolynomialMultiply(polynomial<T_int> Polynomial); template <class T_int> factor<T_int> factor<T_int>::operator()(T_int x, size_t Vpos, int) const {} template<class T_int> inline factor<T_int> factor<T_int>::operator-(const factor& other) const {} template<class T_int> inline factor<T_int> factor<T_int>::operator*(const factor& other) const {} template<class T_int> inline factor<T_int>& factor<T_int>::operator-=(const factor& other) {} template<class T_int> inline factor<T_int>& factor<T_int>::operator*=(const factor& other) {} template<class T_int> inline FACTOR<T_int> FACTOR<T_int>::operator-(const FACTOR& other) const {} template<class T_int> inline FACTOR<T_int> FACTOR<T_int>::operator*(const FACTOR& other) const {} template<class T_int> inline FACTOR<T_int>& FACTOR<T_int>::operator-=(const FACTOR& other) {} template<class T_int> inline FACTOR<T_int>& FACTOR<T_int>::operator*=(const FACTOR& other) {} template<typename T> T ObjectOperations (wstring& errcode, tensor<T> list, tensor<wstring> ops, wstring disposition); template<class T = long double>class Fraction { public: polynomial<T> num, den; Fraction() : num(polynomial<T>{ { { 0, tensor<int>(Variables.size(), 0) } } }), den(polynomial<T>{ { { 1, tensor<int>(Variables.size(), 0) } } }) {} Fraction(polynomial<T> numerator) : num(numerator), den(polynomial<T>{ { { 1, tensor<int>(Variables.size(), 0) } } }) {} Fraction(polynomial<T> numerator, polynomial<T> denominator) : num(numerator), den(denominator) {} Fraction extend() {} Fraction derivate(size_t Vpos) const {} Fraction operator+(const Fraction& other) const {} Fraction operator+=(const Fraction& other) {} Fraction operator-(const Fraction& other) const {} Fraction operator-=(const Fraction& other) {} Fraction operator*(const Fraction& other) const {} Fraction operator*=(const Fraction& other) {} Fraction invert() {} Fraction operator/(const Fraction& other) const {} Fraction operator/=(const Fraction& other) {} Fraction operator()(T x, size_t Vpos) const {} T operator()(tensor<long double> params) const {} bool operator==(const Fraction& other) const {} wstring str() {} friend wostream& operator<<(wostream& os, const Fraction& obj) {} }; static tensor<Fraction<big>> GetManyFractions (tensor<wstring> numerators, tensor<wstring> denominators, wstring& errcode); class key : public tensor<int> { public: using tensor<int>::tensor; key(tensor<int> val) {} key operator!() {} key operator~() const {} _NODISCARD inline bool operator<(const tensor& other) const override {} _NODISCARD inline bool operator<=(const tensor& other) const override {} _NODISCARD inline bool operator>(const tensor& other) const override {} _NODISCARD inline bool operator>=(const tensor& other) const override {} }; static wstring ConvertEnumToWString(switchcase Enum); static switchcase ConvertWStringToEnum(wstring str); tensor<wstring> commands { L, L , L, L, L , L, L, L , L, L , L, L, L , L, L , L, L, L, L , L, L, L }; class Expression; tensor<Expression> __Expr; class Expression { private: using ReturnedFractionType = big; bool activator; _STD map<key, wstring> terms{ { {}, L } }; tensor<key> lines, lister{ {} }; tensor<COORD> FractionLinesPos; tensor<short> FractionLinesLenght; _STD map<key, COORD> dimensions, positions; public: Expression() : activator(false) {}; Expression& operator=(const Expression& other) {} bool contains(key index) const {} void clean() {} tensor<key> underbranch(key node) const {} void Insert(key where, wstring Num, wstring Den) {} void Remove(key node) {} COORD GetDimensions(key node) {} void GetPositions() {} bool out(COORD& StarterCoord) {} COORD CursorPosition(key at) {} bool rewrite(COORD& Begin, key location, int phase) {} Fraction<ReturnedFractionType> in (switchcase& redirection, wstring& errorcode, bool& graph, bool& equate) {} Fraction<ReturnedFractionType> Export (switchcase& redirection, wstring& errorcode, bool& graph, bool& equate) {} }; tensor_t PrimeNumbers; _STD map<int, wstring> CalculatedData; struct Console { wstring Text; WORD Attribute{ 15 }; void log() const {} bool operator!=(const Console& other) const {} friend wostream& operator<<(wostream& wos, const Console& T) {} }; class ConsoleStream : public tensor<Console> { public: ConsoleStream() {} ConsoleStream(initializer_list<Console> init) {} ConsoleStream operator+(ConsoleStream other) const {} inline void output() const {} inline void log() {} friend wostream& operator<<(wostream& wos, const ConsoleStream& T) {} }; ConsoleStream ConsoleText; static void SendCtrlPlusMinus(bool plus); static ptrdiff_t intpow(ptrdiff_t base, int exp); template<typename _Ty = long double> class Matrix : public tensor<tensor<_Ty>> { public: Matrix() {} using tensor<tensor<_Ty>>::tensor; int output( COORD SelectedElement, int& extension, WORD Attribute) const {} bool input(wstring& errcode) {} void DisplayWith(const Matrix other) const {} void DisplayWith(const Matrix A, const Matrix B) const {} Matrix operator+(const Matrix other) const {} Matrix operator+=(const Matrix other) {} Matrix operator-(const Matrix other) const {} Matrix operator-=(const Matrix other) {} tensor<_Ty> operator*(const tensor<_Ty> vector) const {} Matrix operator*(const _Ty scalar) const {} Matrix& operator*=(const _Ty scalar) {} Matrix operator*(const Matrix other) const {} Matrix& operator*=(const Matrix other) {} template<typename T = _Ty> T det() {} Matrix invert(_Ty det) {} tensor<double> EigenValues() {} Matrix EigenVectors(tensor<double> EigenV) {} }; template<typename T> T EmptyProduct(T shape) {} HDC GHDC; static void DrawLine(int firstX, int firstY, int secondX, int secondY, HPEN Hpen); static void DrawLineToBuffer( HDC hdcmem, HBITMAP hbmem, int firstX, int firstY, int secondX, int secondY, HPEN Hpen ); static void ProjectPoint(tensor<long double> point, int& pointX, int& pointY); static void ProjectAndDrawLine (tensor<long double> start, tensor<long double> end, HPEN Hpen); class Point__ { private: int ScreenX, ScreenY; tensor<long double> Normal; public: long double x, y, z; Point__() : x(0), y(0), z(0), ScreenX(-1), ScreenY(-1), Normal(3) {} Point__(long double _x, long double _y, long double _z) : x(_x), y(_y), z(_z), ScreenX(-1), ScreenY(-1), Normal(3) {} Point__(factor<> funct, long double _x, long double _y) : x(_x), y(_y), z(funct({ x, y })), ScreenX(-1), ScreenY(-1), Normal(3) {} Point__(Fraction<> funct, long double _x, long double _y) : x(_x), y(_y), z(funct({ x, y })), ScreenX(-1), ScreenY(-1), Normal(3) {} int GetScreenX() {} int GetScreenY() {} tensor<long double> GetNormalVector() const {} bool Void() const {} Point__& operator=(const Point__& other) {} tensor<long double> SetNormalVector(Fraction<> dfx, Fraction<> dfy) {} void Display(int width, COLORREF color) {} void StdDisplay (Fraction<> fx, Fraction<> dfx, Fraction<> dfy, tensor<long double> light) {} }; static void DrawLine(Point__ P1, Point__ P2, HPEN hpen); static void DrawLineToBuffer (HDC hdcmem, HBITMAP hbmem, Point__ P1, Point__ P2, HPEN Hpen); template<typename T> bool isnan(Fraction<T> object) {} template<typename T> bool isnan(Matrix<T> object) {} class NumberData { public: ptrdiff_t number{}; wstring code; int degree{}; wstring expression; tensor<ptrdiff_t> sequence; divisor div; digitRatio digit; strong_ordering operator<=>(const NumberData& other) const {} NumberData() = default; NumberData( ptrdiff_t num, const wstring& c, int deg, const wstring& expr, const tensor<ptrdiff_t>& seq, const divisor& d, const digitRatio& dr ) : number(num), code(c), degree(deg), expression(expr), sequence(seq), div(d), digit(dr) {} void printf() {} }; tensor<wstring> Numbers, Polynomials, Expressions; tensor<tensor<wstring>> GlobalNumerators, GlobalDenominators, GlobalOperators; tensor<tensor<short>> ActionsList; static wstring Handler(wstring test); static size_t Factorial(size_t n); static size_t BinomialCoeff(size_t n, size_t k); static ptrdiff_t Gcd(ptrdiff_t A, ptrdiff_t B); template<typename T> static int Gcd(tensor<T> terms); static void ReassigneEnum(switchcase& option); static void WriteFraction (wstring Num, wstring Den, wstring& command, COORD START); static void PrintPFrame (double deg, int sides, double radius, COORD WinCenter); static void DrawFrame (int arc, double __i, int centerX, int centerY, double DIM); static void DrawCircleSquare(COORD CircleCenter); static void CS_CenterPrinter(); static void CS_CornerPrinter(); static void ProgressBar(long double ratio, double barWidth); static long double WaitingScreen(auto begin, auto end); static wstring GetLine(tensor<wstring>& sugg, bool ShowSuggestions); static wstring GetUserNum (wstring txt, ptrdiff_t low, ptrdiff_t high, bool ShowSuggestions); static void SetDebug(wstring message, switchcase& opt, bool& Return, ptrdiff_t& LowerBound, ptrdiff_t& UpperBound, ptrdiff_t& datalenght ); static void MonitorConsoleSize(COORD min, atomic_bool& runMonitor); static void UserInputThread(); static void DrawAxis(HDC hdcmem, HBITMAP hbmem, double pInc, double vInc); static LRESULT CALLBACK WindowProcessor2D( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ); static BOOL CreateGraph(Fraction<> funct); static LRESULT CALLBACK WindowProcessor3D( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ); static void Project3DGraph(Fraction<> funct); static bool Prime(ptrdiff_t number); static void PrimeNCalculator(ptrdiff_t max, ptrdiff_t min); static tensor<wstring> Fractioner(wstring polinomial); static tensor<int> DecomposeStrings(wstring Terminal); static wstring Cript(ptrdiff_t input); static wstring FactNumber(ptrdiff_t input); static int ExeStrings(wstring input); static divisor DivisorCalculator(wstring factor); static digitRatio DigitRationalizer(ptrdiff_t inpt); static tensor<int> DivisorCounter(int num); static NumberData ExecuteSimpledeg(ptrdiff_t input); static NumberData ExecuteDegree(ptrdiff_t input); static NumberData ExecuteSimpleFact(ptrdiff_t input); static NumberData ExecuteFactor(ptrdiff_t input); static NumberData ExecuteSimpleDF(ptrdiff_t input); static NumberData ExecuteDigit(ptrdiff_t input); static NumberData ExecuteDegFactor(ptrdiff_t input); static NumberData ExecuteDegDigit(ptrdiff_t input); static NumberData ExecuteFactDigit(ptrdiff_t input); static NumberData ExecuteAll(ptrdiff_t input); static wstring PolynomialSyntax(wstring pol); static wstring PolynomialSyntaxDirector(wstring pol); static wstring UpdateString(wstring& ToEvaluate); static wstring NumberCodeSyntax(wstring ToEvaluate); static ptrdiff_t NumberConverter(size_t root, wstring M); static ptrdiff_t StringConverter(wstring ToEvaluate); static void CodeConverter (wstring ToEvaluate, wstring message, bool ShowErrors, bool NecBoundary); static void LongComputation (wstring ToEvaluate, wstring message, bool ShowErrors, bool NecBoundary); static factor<big> GetMonomials(wstring pol); static polynomial<big> GetMonomialsRedirector(wstring pol); static polynomial<big> GetMonomialsAssister(wstring pol); static tensor<tensor<long double>> FromPolynomialToPos( factor<> vect, int& StartIndex, tensor<int>& CorrectSizes, tensor<int>& VDirectorTerm, tensor<int>& VKnownTerm, tensor<tensor<int>>& VDirectorSeq, tensor<tensor<int>>& VKnownSeq ); static void PolynomialDivide ( FACTOR<> dividend, FACTOR<> divisor, FACTOR<>& quotient, FACTOR<>& rest ); static polynomial<> Total(factor<> vect); static polynomial<> Partial(factor<> vect); static polynomial<> Binomial(factor<> vect); static polynomial<> Trinomial(factor<> vect); static polynomial<> SquareDifference(factor<> vect); static polynomial<> Ruffini(factor<> vect); static polynomial<> CompleteTheSquare(factor<> vect); static polynomial<> TrinomialSquare(factor<> vect); static FACTOR<> Complementary(POLYNOMIAL<> Polynomial, FACTOR<> factor, int exp); static void Simplify(Fraction<>& fr, int& ncoeff, int& dcoeff); static void Approximator(tensor<long double>& Equation, long double& root); static tensor<wstring> EquationSolver(factor<> equation); static tensor<long double> RootExtractor(polynomial<> vect); static tensor<tensor<long double>> SystemSolver(tensor<factor<>> functions); static void FractDisequationMain( polynomial<> Num, polynomial<> Den, tensor<wstring>& Roots, tensor<bool>& ItsFromDenominator, bool& InitSign, bool& Invert ); static ConsoleStream GetAlgebricSolution( tensor<wstring> roots, tensor<bool> ItsFromDenominator, bool InitialSign, bool ExpectedSign, bool CanBeNull); static bool ParamDisequationSetup( polynomial<>& Num, polynomial<>& Den, polynomial<>& Sum, tensor<bool>& FromDenominator, tensor<long double>& AdditionalRoots, factor<>& Parametric, tensor<factor<>>& tops, tensor<factor<>>& bottoms, bool& InitSign, bool& InvertSign ); static void ParamDisequationMain( polynomial<> Un, tensor<factor<>> tops, tensor<factor<>> bottoms, tensor<long double> AdditionalRoots, size_t& Unisize, tensor<tensor<factor<>>>& TableOfMains, tensor<long double>& RootSet, tensor<long double>& RootExamples, tensor<wstring>& vals ); static ConsoleStream GetParametricSolution( wchar_t parameter, size_t Unisize, size_t Vpos, bool InitialSign, bool ExpectedSign, bool CanBeNull, tensor<bool> TermsFromDenominator, polynomial<>& Num, polynomial<>& Den, factor<> Parametric, tensor<factor<>> tops, tensor<factor<>> bottoms, tensor<tensor<factor<>>> TableOfMains, tensor<long double> RootSet, tensor<long double> RootExamples, tensor<wstring> vals ); static ConsoleStream DisequationSolutionPrinter( polynomial<> Num, polynomial<> Den, int behaviour, bool ChangeSign, bool PrintCondition); static void PrintFraction (int NC, int DC, int& LINE, bool WritePlus, Fraction<> fract); static void PrintFractionaryResult ( int NC, int DC, int& lines, Fraction<> Fract, POLYNOMIAL<> NScomp, POLYNOMIAL<> DScomp, bool HasMoreVariables, bool correct, tensor<double> roots, tensor<POLYNOMIAL<>> Denominators); static void CodeToNumber(switchcase& argc); static wstring ExpandNumber( switchcase& argc, big Number, int Base, bool access); static void Repeater( switchcase& argc, wstring message, NumberData CPU ); static void Loop( switchcase& argc, wstring message, NumberData CPU, bool select); static void DecompAndSolve(switchcase& argc); template<typename Type> static polynomial<> DecompPolynomial(switchcase& argc, Type Polynomial); static void DecompMatrices(switchcase& argc); int main() {} static wstring Handler(wstring test) {} static size_t Factorial(size_t n) {} static size_t BinomialCoeff(size_t n, size_t k) {} static ptrdiff_t Gcd(ptrdiff_t A, ptrdiff_t B) {} static big Gcd(big A, big B) {} template<typename T>static int Gcd(tensor<T> terms) {} static big Gcd(tensor<big> terms) {} static ptrdiff_t intpow(ptrdiff_t base, int exp) {} inline static wstring ConvertEnumToWString(switchcase Enum) {} inline static switchcase ConvertWStringToEnum(wstring str) {} static void ReassigneEnum(switchcase& option) {} namespace ConsoleLogData { int RotAngle{ 270 }, PolygDegree{}, PolygonSides{ 4 }; int CircleCenterX, CircleCenterY, CircleRotDegreeAngle{}; bool DecreaseAngle{ true }, DecreaseWidth{ true }; double DWidth{ 1.9 }; const tensor<int> spectrum{ 9, 9, 9, 11, 11, 3, 3, 12, 4 }; }; static void ClearArea(COORD WinCenter, COORD Dimensions) {} static void WriteFraction(wstring Num, wstring Den, wstring& command, COORD START) {} static void PrintPFrame (double deg, int sides, double radius, COORD WinCenter) {} static void DrawFrame (int arc, double __i, int centerX, int centerY, double DIM) {} static void DrawCircleSquare(COORD CircleCenter) {} inline static void CS_CenterPrinter() {} inline static void CS_CornerPrinter() {} static void ProgressBar(long double ratio, double barWidth) {} static long double WaitingScreen(auto begin, auto end) {} static wstring CTSuperScript(wchar_t input) {} static wstring CFSuperScript(wstring script) {} static wstring ElabExponents(wstring& str) {} static void DeduceFromExponents(wstring& str) {} static wstring GetLine(tensor<wstring>& sugg, bool ShowSuggestions) {} static wstring GetUserNum (wstring txt, ptrdiff_t low, ptrdiff_t high, bool ShowSuggestions) {} static void SetDebug(wstring message, switchcase& opt, bool& Return, ptrdiff_t& LowerBound, ptrdiff_t& UpperBound, ptrdiff_t& datalenght ) {} static void SendCtrlPlusMinus(bool plus) {} static void SendString(wstring str) {} static void MonitorConsoleSize(COORD min, atomic_bool& runMonitor) {} static void UserInputThread() {} RECT ClientRect; namespace WindowData { bool redo{ false }; enum states { MIN, MAX, H_FLX, A_FLX, D_FLX }; LPARAM Coords{}, Current{}; bool enable{ false }; double Zoom{ 1 }; wchar_t __save; int gIndex{}; tensor<int> Indexlist; int shiftX{}, shiftY{}; tensor<tensor<int>> memory{ {} }; class DATA { public: COLORREF Color; Fraction<> Function; wstring ID; tensor<int> States; tensor<long double> StatX, StatY; DATA() : Color(0) {} DATA(Fraction<> funct); bool operator==(DATA other) {} }; tensor<DATA> List; DATA::DATA(Fraction<> funct) : Function(funct), ID(funct.str()) {} }; namespace Window3Data { enum states { MINIMUM, MAXIMUM, SADDLE, UNKNOWN, }; tensor<int> def; tensor<int> Light{ 0, 0, -1 }; double Zoom{ 1 }; bool enable{ false }; LPARAM Coords{}, Current{}; tensor<long double> StatX, StatY, StatZ; Fraction<> Function, PartialXder, PartialYder; auto Theta{ M_PI / 4 }; auto Phi{ M_PI / 3 }; }; static void DrawLine(int firstX, int firstY, int secondX, int secondY, HPEN Hpen) {} static void DrawLineToBuffer( HDC hdcmem, HBITMAP hbmem, int firstX, int firstY, int secondX, int secondY, HPEN Hpen ) {} static void DrawLine(Point__ P1, Point__ P2, HPEN hpen) {} static void DrawLineToBuffer (HDC hdcmem, HBITMAP hbmem, Point__ P1, Point__ P2, HPEN Hpen) {} static void IncrementCalculator(double zoom, double& pInc, double& vInc) {} static void ProjectPoint(tensor<long double> point, int& pointX, int& pointY) {} static void ProjectAndDrawLine (tensor<long double> start, tensor<long double> end, HPEN Hpen) {} static void DrawAxis(HDC hdcmem, HBITMAP hbmem, double pInc, double vInc) {} static LRESULT CALLBACK WindowProcessor2D( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) {} static BOOL CreateGraph(Fraction<> funct) {} static LRESULT CALLBACK WindowProcessor3D( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) {} static void Project3DGraph(Fraction<> funct) {} static bool Prime(ptrdiff_t number) {} static void PrimeNCalculator(ptrdiff_t max, ptrdiff_t min) {} static tensor<compost> DecomposeNumber(ptrdiff_t input) {} static tensor<int> DecomposeStrings(wstring terminal) {} static tensor<wstring> Fractioner(wstring str) {} static tensor<tensor<wstring>> FractPolynomial(wstring pol) {} static wstring Cript(ptrdiff_t input) {} static wstring FactNumber(ptrdiff_t input) {} static int ExeStrings(wstring input) {} static divisor DivisorCalculator(wstring factor) {} static digitRatio DigitRationalizer(ptrdiff_t inpt) {} static tensor<int> DivisorCounter(int num) {} static NumberData ExecuteSimpledeg(ptrdiff_t input) {} static NumberData ExecuteDegree(ptrdiff_t input) {} static NumberData ExecuteSimpleFact(ptrdiff_t input) {} static NumberData ExecuteFactor(ptrdiff_t input) {} static NumberData ExecuteSimpleDF(ptrdiff_t input) {} static NumberData ExecuteDigit(ptrdiff_t input) {} static NumberData ExecuteDegFactor(ptrdiff_t input) {} static NumberData ExecuteDegDigit(ptrdiff_t input) {} static NumberData ExecuteFactDigit(ptrdiff_t input) {} static NumberData ExecuteAll(ptrdiff_t input) {} static wstring PolynomialSyntax(wstring pol) {} static wstring PolynomialSyntaxDirector(wstring pol) {} static wstring UpdateString(wstring& ToEvaluate) {} static wstring NumberCodeSyntax(wstring ToEvaluate) {} static ptrdiff_t NumberConverter(size_t root, wstring M) {} static ptrdiff_t StringConverter(wstring ToEvaluate) {} static void CodeConverter (wstring ToEvaluate, wstring message, bool ShowErrors, bool NecBoundary) {} static void LongComputation (wstring ToEvaluate, wstring message, bool ShowErrors, bool NecBoundary) {} static factor<big> GetMonomials(wstring pol) {} static polynomial<big> GetMonomialsRedirector(wstring pol) {} static polynomial<big> GetMonomialsAssister(wstring pol) {} template<typename T> T ObjectOperations (wstring& errcode, tensor<T> list, tensor<wstring> ops, wstring disposition) {} static tensor<tensor<long double>> FromPolynomialToPos( factor<> vect, int& StartIndex, tensor<int>& CorrectSizes, tensor<int>& VDirectorTerm, tensor<int>& VKnownTerm, tensor<tensor<int>>& VDirectorSeq, tensor<tensor<int>>& VKnownSeq ) {} template<typename T_int = long double> static factor<T_int> PolynomialSum(factor<T_int> vect) {} template<typename T_int = long double> static factor<T_int> PolynomialMultiply(polynomial<T_int> Polynomial) {} static void PolynomialDivide ( FACTOR<> dividend, FACTOR<> divisor, FACTOR<>& quotient, FACTOR<>& rest ) {} static polynomial<> Total(factor<> vect) {} static polynomial<> Partial(factor<> vect) {} static polynomial<> Binomial(factor<> vect) {} static polynomial<> Trinomial(factor<> vect) {} static polynomial<> SquareDifference(factor<> vect) {} static polynomial<> Ruffini(factor<> vect) {} static polynomial<> CompleteTheSquare(factor<> vect) {} static polynomial<> TrinomialSquare(factor<> vect) {} static tensor<Fraction<big>> GetManyFractions (tensor<wstring> numerators, tensor<wstring> denominators, wstring& errcode) {} static FACTOR<> Complementary(POLYNOMIAL<> Polynomial, FACTOR<> factor, int exp) {} static void Simplify(Fraction<>& fr, int& ncoeff, int& dcoeff) {} static void PrintFraction (int NC, int DC, int& LINE, bool WritePlus, Fraction<> fract) {} static void PrintFractionaryResult ( int NC, int DC, int& lines, Fraction<> Fract, POLYNOMIAL<> NScomp, POLYNOMIAL<> DScomp, bool HasMoreVariables, bool correct, tensor<double> roots, tensor<POLYNOMIAL<>> Denominators ) {} static void Approximator(tensor<long double>& Equation, long double& root) {} static tensor<wstring> EquationSolver(factor<> Equation) {} static tensor<tensor<long double>> SystemSolver(tensor<factor<>> functions) {} static tensor<long double> RootExtractor(polynomial<> vect) {} static void FractDisequationMain( polynomial<> Num, polynomial<> Den, tensor<wstring>& Roots, tensor<bool>& ItsFromDenominator, bool& InitSign, bool& Invert ) {} static ConsoleStream GetAlgebricSolution( tensor<wstring> roots, tensor<bool> ItsFromDenominator, bool InitialSign, bool ExpectedSign, bool CanBeNull ) {} static bool ParamDisequationSetup( polynomial<>& Num, polynomial<>& Den, polynomial<>& Sum, tensor<bool>& FromDenominator, tensor<long double>& AdditionalRoots, factor<>& Parametric, tensor<factor<>>& tops, tensor<factor<>>& bottoms, bool& InitSign, bool& InvertSign ) {} static void ParamDisequationMain( polynomial<> Un, tensor<factor<>> tops, tensor<factor<>> bottoms, tensor<long double> AdditionalRoots, size_t& Unisize, tensor<tensor<factor<>>>& TableOfMains, tensor<long double>& RootSet, tensor<long double>& RootExamples, tensor<wstring>& vals ) {} static ConsoleStream GetParametricSolution( wchar_t parameter, size_t Unisize, size_t Vpos, bool InitialSign, bool ExpectedSign, bool CanBeNull, tensor<bool> TermsFromDenominator, polynomial<>& Num, polynomial<>& Den, factor<> Parametric, tensor<factor<>> tops, tensor<factor<>> bottoms, tensor<tensor<factor<>>> TableOfMains, tensor<long double> RootSet, tensor<long double> RootExamples, tensor<wstring> vals ) {} static ConsoleStream DisequationSolutionPrinter( polynomial<> Num, polynomial<> Den, int behaviour, bool ChangeSign, bool PrintCondition ) {} static void CodeToNumber(switchcase& argc) {} tensor<tensor<wstring>> Map(0); static wstring ExpandNumber( switchcase& argc, big Number,	int Base,	bool access	) {} static void Repeater( switchcase& argc, wstring message, NumberData CPU ) {} static void Loop( switchcase& argc, wstring message, NumberData CPU, bool select ) {} template<typename Type = wstring> static polynomial<> DecompPolynomial(switchcase& argc, Type Polynomial) {} static void DecompAndSolve(switchcase& argc) {} static void DecompMatrices(switchcase& argc) {} 