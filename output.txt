using namespace std; using namespace _STD chrono; using Concurrency::parallel_for, this_thread::sleep_for; int __NULL__ = 0; HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE); HANDLE hConsoleInput = GetStdHandle(STD_INPUT_HANDLE); CONSOLE_CURSOR_INFO cursorInfo{ 10, FALSE }; CONSOLE_CURSOR_INFO cursor{ 10, TRUE }; CONSOLE_SCREEN_BUFFER_INFO csbi; static wchar_t charVariable(L); ptrdiff_t GlobalMax(0); const ptrdiff_t GLOBAL_CAP(5e10); bool BOOLALPHA(true); bool PRINTN(true); double CORRECTION_RATIO(1.0); atomic_bool GlobalInterr(false); atomic_bool interrupted(false); atomic_bool computing(false); atomic_bool IsDone(false); atomic_bool RunMonitor(true); condition_variable cv, Cv, MonitorCV; mutex CoutMutex, mtx, MonitorMTX; COORD Min{ 25, 15 }; LARGE_INTEGER ProgramFrequency; struct compost { ptrdiff_t factors; int exp; }; struct divisor { ptrdiff_t DivNumber{ 1 }; ptrdiff_t DivSum{ 1 }; ptrdiff_t DivProduct{ 1 }; wstring Div_pr; }; struct digitRatio { int digitSumRatioNum{}; int digitSumRatioDen{}; int digitProductRatioNum{}; int digitProductRatioDen{}; }; digitRatio items; struct coord { double X; double Y; coord() : X(0), Y(0) {} coord(double _x, double _y) : X(_x), Y(_y) {} coord(COORD _coord) : X(_coord.X), Y(_coord.Y) {} operator COORD() const { return { static_cast<short>(X), static_cast<short>(Y) }; } }; enum switchcase { DoSimpleCode , DoComplexCode , DoSimpleFactor , DoComplexFactor , DoCodeFactor , DoAll , DebugSimpleCode , DebugComplexCode , DebugSimpleFactor , DebugComplexFactor , DebugCodeFactor , DebugAll , DebugDigits , DebugDigitsAndCode , DebugDigitsAndFactor, DebugComplete , ConvertCodeInverse , SeriesExpansion , FactorPolynomial , FractElaborator , FactorMatrix , Random , NotAssigned }; switchcase usefree; unordered_map<wstring, switchcase> stringToEnumMap { { L , switchcase::DoSimpleCode }, { L, switchcase::DoComplexCode }, { L , switchcase::DoSimpleFactor }, { L, switchcase::DoComplexFactor }, { L, switchcase::DoCodeFactor }, { L , switchcase::DoAll }, { L , switchcase::DebugSimpleCode }, { L, switchcase::DebugComplexCode }, { L , switchcase::DebugSimpleFactor }, { L, switchcase::DebugComplexFactor }, { L, switchcase::DebugCodeFactor }, { L , switchcase::DebugAll }, { L , switchcase::DebugDigits }, { L, switchcase::DebugDigitsAndCode }, { L, switchcase::DebugDigitsAndFactor }, { L, switchcase::DebugComplete }, { L, switchcase::ConvertCodeInverse }, { L, switchcase::SeriesExpansion }, { L, switchcase::FactorPolynomial }, { L, switchcase::FractElaborator }, { L, switchcase::FactorMatrix }, { L, switchcase::Random } }; unordered_map<switchcase, wstring> enumToStringMap { { switchcase::DoSimpleCode , L }, { switchcase::DoComplexCode , L }, { switchcase::DoSimpleFactor , L }, { switchcase::DoComplexFactor , L }, { switchcase::DoCodeFactor , L }, { switchcase::DoAll , L }, { switchcase::DebugSimpleCode , L }, { switchcase::DebugComplexCode , L }, { switchcase::DebugSimpleFactor , L }, { switchcase::DebugComplexFactor , L }, { switchcase::DebugCodeFactor , L }, { switchcase::DebugAll , L }, { switchcase::DebugDigits , L }, { switchcase::DebugDigitsAndCode , L }, { switchcase::DebugDigitsAndFactor, L }, { switchcase::DebugComplete , L }, { switchcase::ConvertCodeInverse , L }, { switchcase::SeriesExpansion , L }, { switchcase::FactorPolynomial , L }, { switchcase::FractElaborator , L }, { switchcase::FactorMatrix , L }, { switchcase::Random , L } }; unordered_map<wstring, wstring> ConvertFromSuperScript { { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, { L, L }, }; wstring Variables{ L }; using _TENSOR tensor, _TENSOR tensor_t; template<typename T> static bool Smaller(const T& A, const T& B) { if constexpr (is_same_v<T, wstring>) { if (A == B) { return false; } auto min_size{ min(A.size(), B.size()) }; for (size_t i = 0; i < min_size; ++i) { if (A.at(i) != B.at(i)) { return A.at(i) < B.at(i);; } } return A.size() < B.size(); } else { return A < B; } } template<typename T> static ptrdiff_t BinarySearch(const tensor<T>& arr, const T target) { ptrdiff_t left = 0, right = ptrdiff_t(arr.size()) - 1; while (left <= right) { ptrdiff_t mid = left + (right - left) / 2; if (arr[mid] == target) { return mid; } if (Smaller(arr[mid], target)) { left = mid + 1; continue; } right = mid - 1; } return -1; } template<typename Ty> class complex { public: Ty RealPart; Ty ImaginaryPart; Ty norm() const { return sqrt(RealPart * RealPart + ImaginaryPart * ImaginaryPart); } complex() : RealPart(0), ImaginaryPart(0) {} complex(Ty real) : RealPart(real), ImaginaryPart(0) {} complex(Ty real, Ty imag) : RealPart(real), ImaginaryPart(imag) {} inline complex conjugate() const { return complex(RealPart, -ImaginaryPart); } inline complex opposite() const { return complex(-RealPart, -ImaginaryPart); } complex operator+(complex value) const { return complex( RealPart + value.RealPart, ImaginaryPart + value.ImaginaryPart ); } inline complex& operator+=(complex value) { *this = *this + value; return *this; } inline complex& operator++() { *this = *this + 1; return *this; } inline complex& operator++(int) { *this = *this + 1; return *this; } complex operator-(complex value) const { return complex( RealPart - value.RealPart, ImaginaryPart - value.ImaginaryPart ); } inline complex& operator-=(complex value) { *this = *this - value; return *this; } inline complex& operator--() { *this = *this - 1; return *this; } inline complex& operator--(int) { *this = *this - 1; return *this; } complex operator*(complex value) const { Ty a{ RealPart }, b{ ImaginaryPart }; Ty c{ value.RealPart }, d{ value.ImaginaryPart }; return complex( a * c - b * d, b * c + a * d ); } inline complex& operator*=(complex value) { *this = *this * value; return *this; } complex operator/(complex value) const { Ty a{ RealPart }, b{ ImaginaryPart }; Ty c{ value.RealPart }, d{ value.ImaginaryPart }; return complex( (a * c + b * d) / (c * c + d * d), (b * c - a * d) / (c * c + d * d) ); } inline complex operator/=(complex value) { *this = *this / value; return *this; } wstring str() const { wostringstream output; if (ImaginaryPart) { output << setprecision(10) << L; } output << RealPart; if (ImaginaryPart) { ImaginaryPart > 0 ? output << L : output << L; if (!(::std::fabs(ImaginaryPart - ::std::round(ImaginaryPart)) < 1e-9)) { output << L; } if (fabs(ImaginaryPart) != 1) { output << fabs(ImaginaryPart); } if (integer(ImaginaryPart)) { output << L; } output << L; } return output.str(); } friend wostream& operator<<(wostream& os, const complex& obj) { os << obj.str(); return os; } }; template<typename Ty> static complex<Ty> InitExponentialForm(Ty radius, Ty angle) { return complex<Ty>(radius * cos(angle), radius * sin(angle)); } tensor<complex<long double>> Omega; static void FFT(tensor<complex<long double>>& List, bool inverse = false) { if (List == 1) { return; } auto N{ List.size() }; tensor<complex<long double>> Helper(N); if (Omega < N) { auto omega{ Omega }; Omega.clear(); size_t Ratio = omega.empty() ? 1 : N / (2 * omega.size()); for (size_t i = 0; i < N / 2; ++i) { Omega << (i % Ratio == 0 and !omega.empty() ? omega[i / Ratio] : InitExponentialForm<long double>(1, -2 * M_PI * i / N)); } } for (size_t ind = 0; ind < N; ++ind) { size_t shifter{ 1 }, k{ 1 }; do { k <<= 1; if ((ind | shifter) == ind) { k |= 1; } } while ((shifter <<= 1) < N); k -= N; if (k > ind) { swap(List[k], List[ind]); } } for (size_t Size = 2; Size <= N; Size <<= 1) { auto OmegaStep = 2 * Omega.size() / Size; for (size_t i = 0; i < N; i += Size) { for (size_t j = 0; j < Size / 2; ++j) { auto k{ i + j }; auto product = ( inverse ? Omega[OmegaStep * j].conjugate() : Omega[OmegaStep * j] ) * List[k + Size / 2]; Helper[k] = List[k] + product; Helper[k + Size / 2] = List[k] - product; } for (size_t j = 0; j < Size; ++j) { auto k{ i + j }; List[k] = Helper[k]; } } } } class big { private: tensor<int> Integer; bool sign; long double decimal; void construct(ptrdiff_t param) { tensor<int> temp; while (param > 0) { temp << param % 10; param /= 10; } if (temp.empty()) { temp = { 0 }; } auto size{ temp.size() }; for (ptrdiff_t i = size - 1; i >= 0; --i) { Integer << temp[i]; } } bool compare(const big& A, const big& B) const { auto integ{ A.Integer }; auto oth_integ{ B.Integer }; while (integ > 1 and integ[0] == 0) { --integ; } while (oth_integ > 1 and oth_integ[0] == 0) { --oth_integ; } if (integ % oth_integ) { return integ < oth_integ; } for (size_t i = 0; i < integ; ++i) { if (integ[i] != oth_integ[i]) { return integ[i] < oth_integ[i]; } } return A.decimal < B.decimal; } big Add(const big& __This, const big& __Val, bool changesign) const { big This = __This, Val = __Val; if (changesign) { This.sign = !This.sign; } bool carry; if (This.Integer < Val.Integer) { swap(This, Val); } Val.Integer.insert( Val.Integer.begin(), This.Integer.size() - Val.Integer.size(), 0 ); This.decimal += Val.decimal; This.decimal -= (carry = This.decimal >= 1); for (ptrdiff_t i = This.Integer.size() - 1; i >= 0; --i) { This.Integer[i] += Val.Integer[i] + carry; This.Integer[i] -= 10 * (carry = This.Integer[i] >= 10); } if (carry) { This.Integer >> 1; } return This; } big Sub(const big& __This, const big& __Val, bool changesign) const { big This = __This, Val = __Val; if (changesign) { This.sign = !This.sign; } bool carry; Val.Integer.insert( Val.Integer.begin(), This.Integer.size() - Val.Integer.size(), 0 ); This.decimal -= Val.decimal; This.decimal += (carry = This.decimal < 0); for (ptrdiff_t i = This.Integer.size() - 1; i >= 0; --i) { This.Integer[i] -= Val.Integer[i] + carry; This.Integer[i] += 10 * (carry = This.Integer[i] < 0); } while (This.Integer > 1 and This.Integer[0] == 0) { --This.Integer; } return This; } big AlgebricOperation1(const big& A, const big& B, bool Sign) const { if (B == 0) { return A; } if (A == 0) { auto result{ B }; result.sign = Sign; return result; } if (!(A.sign xor B.sign xor Sign)) { return Add(A, B, false); } if (A.Integer == B.Integer and A.decimal == B.decimal) { return 0; } return compare(A, B) ? Sub(B, A, Sign) : Sub(A, B, !Sign); } big FFT_Multiplication(const big& value) const { tensor<int> decA, decB; auto decimalA{ decimal }; auto decimalB{ value.decimal }; while (decimalA != 0) { decimalA *= 10; decA << decimalA; decimalA -= decA.last(); } while (decimalB != 0) { decimalB *= 10; decB << decimalB; decimalB -= decB.last(); } auto DA{ decA.size() }; auto DB{ decB.size() }; auto sizeA{ Integer.size() }; auto sizeB{ value.Integer.size() }; auto sumA{ sizeA + DA }; auto sumB{ sizeB + DB }; auto sizeT{ sumA + sumB }; size_t N{ 1 }; while (N < sizeT) { N <<= 1; } tensor<complex<long double>> A(N), B(N); for (size_t i = 0; i < DA; ++i) { A[i] = complex<long double>(decA[DA - i - 1]); } for (size_t i = 0; i < DB; ++i) { B[i] = complex<long double>(decB[DB - i - 1]); } for (size_t i = DA; i < sumA; ++i) { A[i] = complex<long double>(Integer[sumA - i - 1]); } for (size_t i = DB; i < sumB; ++i) { B[i] = complex<long double>(value.Integer[sumB - i - 1]); } FFT(A); FFT(B); for (size_t i = 0; i < N; ++i) { A[i] *= B[i]; } FFT(A, true); for (auto& num : A) { num /= N; } big result; ptrdiff_t carry{}; result.Integer(N); for (size_t i = 0; i < N; ++i) { ptrdiff_t cur = _STD round(A[i].RealPart) + carry; carry = (cur += 10 * (cur < 0)) / 10; result.Integer[N - i - 1] = cur % 10; } auto& Int{ result.Integer }; auto& Dec{ result.decimal }; size_t decprecision{ DA + DB }; if (decprecision != 0) { for (ptrdiff_t i = 1; i <= decprecision; ++i) { Dec = (Dec + Int[N - i]) / 10; } Int.erase(N - decprecision); } auto it{ Int.begin() }; auto rend{ Int.end() }; while (*it == 0 and it != rend) { ++it; } Int.erase(Int.begin(), it); if (Int.empty()) { Int = { 0 }; } result.sign = sign xor value.sign; return result; } public: template<typename t> t Number() { if constexpr (is_same_v<t, size_t>) { return nan(); } ptrdiff_t val{}; for (size_t i = 0; i < Integer; ++i) { val += Integer[i] * pow(10, Integer.size() - i - 1); if (val != 0 and (val < numeric_limits<t>::min() or val > numeric_limits<t>::max())) { return nan(); } } t res = val; if constexpr (is_floating_point_v<t>) { res += decimal; } if constexpr (is_signed_v<t>) { if (sign == true) { res *= -1; } } return res; } big() : sign(false), Integer(0), decimal(0) {} big(int param) : sign(param < 0), Integer(0), decimal(0) { construct(abs(param)); } big(ptrdiff_t param) : sign(param < 0), Integer(0), decimal(0) { construct(abs(param)); } big(double param) : sign(param < 0), Integer(0), decimal(0) { param = _STD fabs(param); auto Intpart{ static_cast<ptrdiff_t>(param) }; decimal = param - Intpart; construct(Intpart); } big(long double param) : sign(param < 0), Integer(0), decimal(0) { param = _STD fabs(param); auto Intpart{ static_cast<ptrdiff_t>(param) }; decimal = param - Intpart; construct(Intpart); } big(tensor<int> Big) : sign(false), Integer(Big), decimal(0) { if (Integer.empty()) { Integer = { 0 }; } while (Integer > 1 and Integer[0] == 0) { --Integer; } } big(wstring wstr) : sign(false), Integer(0), decimal(0) { tensor<int> Big; for (auto c : wstr) { if (iswdigit(c)) { Integer << c - L; } } } big& operator=(const big& other) { if (this == &other) { return *this; } sign = other.sign; Integer = other.Integer; decimal = other.decimal; return *this; } inline bool operator==(const big& other) const { return sign == other.sign and Integer == other.Integer and decimal == other.decimal; } inline bool operator!=(const big& other) const { return !(*this == other); } bool operator<(const big& other) const { return(sign xor other.sign) ? sign : (compare(*this, other) xor sign); } inline bool operator<=(const big& other) const { return *this < other or *this == other; } inline bool operator>=(const big& other) const { return !(*this < other); } inline bool operator>(const big& other) const { return !(*this == other or *this < other); } big operator+(const big& value) const { return AlgebricOperation1(*this, value, false); } inline big& operator+=(const big& value) { *this = *this + value; return *this; } inline big& operator++() { *this = *this + 1; return *this; } inline big& operator++(int) { *this = *this + 1; return *this; } big operator-(const big& value) const { return AlgebricOperation1(*this, value, true); } inline big& operator-=(const big& value) { *this = *this - value; return *this; } inline big& operator--() { *this = *this - 1; return *this; } inline big& operator--(int) { *this = *this - 1; return *this; } big operator<<(int shift) const { big result = *this; for (ptrdiff_t i = 0; i < shift; ++i) { result.decimal *= 10; result.Integer << result.decimal; result.decimal -= result.Integer.last(); } return result; } inline big& operator<<=(int shift) { for (ptrdiff_t i = 0; i < shift; ++i) { decimal *= 10; Integer << decimal; decimal -= Integer.last(); } return *this; } big operator>>(int shift) const { big result = *this; for (ptrdiff_t i = 0; i < shift; ++i) { result.decimal += Integer.last(); result.decimal /= 10; } shift >= result.Integer.size() ? result.Integer = { 0 } : result.Integer -= shift; return result; } inline big& operator>>=(int shift) { for (ptrdiff_t i = 0; i < shift; ++i) { decimal += Integer.last(); decimal /= 10; } shift >= Integer.size() ? Integer = { 0 } : Integer -= shift; return* this; } big operator*(const big& value) const { if (value == 0 or *this == 0) { big result; result.sign = false; result.Integer = { 0 }; result.decimal = 0; return result; } return FFT_Multiplication(value); } inline big& operator*=(const big& value) { *this = *this * value; return *this; } big operator/(const big& value) const { if (value == 0) { throw invalid_argument(); } if (value == 1) { return *this; } if (value == *this) { return 1; } big result; if (value.Integer > 10) { big This = *this, current; result.sign = This.sign xor value.sign; for (size_t i = 0; i < This.Integer; ++i) { int quotient{}; current.Integer << This.Integer[i]; auto it{ current.Integer.begin() }; auto rend{ current.Integer.end() }; while (*it == 0 and it != rend) { ++it; } current.Integer.erase(current.Integer.begin(), it); if (current.Integer.empty()) { current.Integer = { 0 }; } while (current >= value.fabs()) { current -= value.fabs(); quotient++; } result.Integer << quotient; } } else { big old, New = 1; for (;;) { bool FirstIter{ true }; old = result = New; do { if (!FirstIter) { result >>= 1; } New = result * 2 - value * result * result; FirstIter = false; } while (New.sign or New == 0);  ((New - old).fabs() < 1e-15) { break; } } } uto it{ result.Integer.begin() }; auto rend{ result.Integer.end() }; while (*it == 0 and it != rend) { ++it; } result.Integer.erase(result.Integer.begin(), it); if (result.Integer.empty()) { result.Integer = { 0 }; } result.sign = sign xor value.sign; auto output = value.Integer > 10 ? result : (*this) * result; if (_STD round(output.decimal) == 1) { output.Integer.last()++; } for (ptrdiff_t i = output.Integer.size() - 1; i > 0; --i) { if (output.Integer[i] < 10) { break; } output.Integer[i] = 0; output.Integer[i - 1]++; } if (output.Integer[0] == 10) { output.Integer[0] = 0; output.Integer >> 1; } return output; } inline big& operator/=(const big& value) { *this = *this / value; return *this; } big operator%(const big& value) const { if (value == 0) { throw invalid_argument(); } big This = *this, Val = value; Val.sign = This.sign = false; while (This >= Val) { big temp = Val, factor = 1; while ((temp << 1) <= This) { factor <<= 1; temp <<= 1; } This -= temp; } return This; } inline big& operator%=(const big& value) { *this = *this % value; return *this; } big operator^(const big& exp) const { big power = 1, NewExp = exp + 1, NewBase = *this; if (*this < 0) { NewBase.invert(); } while (--NewExp > 0) { power *= NewBase; if (power < 0) { return - 1; } } if (exp % 2 == 1 and *this < 0) { power.invert(); } return power; } inline big& operator^=(const big& exp) { *this = *this ^ exp; return *this; } inline bool intg() const { return decimal == 0; } inline big fabs() const { big other = *this; other.sign = false; return other; } inline big floor() { decimal = 0; return *this; } inline big ceil() { bool integ = decimal == 0; decimal = 0; if (integ) { (*this)++; } return *this; } inline big round() { *this += _STD round(decimal); decimal = 0; return *this; } inline big invert() { sign = !sign; return *this; } inline int log(int base) { for (int i = 0;; ++i) { if (*this < base) { return i; } *this /= base; } } wostringstream c_str(int precision) const { wostringstream oss, result; if (sign) { result << L; } for (size_t i = 0; i < Integer; ++i) { result << Integer[i]; } if (precision > 0) { oss << setprecision(precision) << decimal; } auto str{ oss.str() }; str.erase(0, 1); if (!str.empty()) { result << str; } return result; } inline wstring str() const { return c_str(6).str(); } friend wostream& operator<<(wostream& os, const big& obj) { os << obj.str(); return os; } }; static big pow(big x, int y) { return x ^ y; } big LCM(1); static void ClearArea(COORD WinCenter, COORD Dimensions); template<typename T> void GeneralizedHeapify(tensor<T>& arr, int n, int i) { int largest{ i }, left{ 2 * i + 1 }, right{ 2 * i + 2 }; if (left < n and arr[left] > arr[largest]) { largest = left; } if (right < n and arr[right] > arr[largest]) { largest = right; } if (largest != i) { swap(arr[i], arr[largest]); GeneralizedHeapify(arr, n, largest); } } template<typename T> void GeneralizedHeapSort(tensor<T>& arr) { auto n{ arr.size() }; for (ptrdiff_t i = n / 2 - 1; i >= 0; --i) { GeneralizedHeapify(arr, n, i); } for (ptrdiff_t i = n - 1; i > 0; --i) { swap(arr[0], arr[i]); GeneralizedHeapify(arr, i, 0); } } static tensor<compost> DecomposeNumber(ptrdiff_t input); class radical { int coefficient; ptrdiff_t Arg; tensor<int> primes; public: radical() : coefficient(0), Arg(1), primes({ 1 }) {} radical(int coeff) : coefficient(coeff), Arg(1), primes({ 1 }) {} radical(int coeff, int arg) : coefficient(coeff), Arg(1), primes({ abs(arg) }) { if (arg < 0) { coefficient *= -1; } normalize(); } radical(int coeff, int arg, bool off) : coefficient(coeff), Arg(abs(arg)), primes({ abs(arg) }) { if (arg < 0) { coefficient *= -1; } } int GetCoefficient() const { return coefficient; } void SetCoefficient(int NewCoefficient) { coefficient = NewCoefficient; } void IncCoefficient(int increment) { coefficient += increment; } ptrdiff_t arg() const { return Arg; } long double approximation() const { return coefficient * sqrt(Arg); } void normalize() { Arg = 1; if (coefficient == 0) { *this = radical(); return; } auto decomposition{ DecomposeNumber(pow(approximation(), 2)) }; for (auto& fact : decomposition) { if (fact.exp > 1) { coefficient *= pow(fact.factors, fact.exp / 2); } if (fact.exp % 2 == 0) { Arg *= fact.factors; primes << fact.factors; } } } long double operator+(const radical& other) const { return approximation() + other.approximation(); } long double operator-(const radical& other) const { return approximation() - other.approximation(); } long double operator/(const radical& other) const { return approximation() / other.approximation(); } radical operator*(const radical& other) const { auto This{ *this }; This.coefficient *= other.coefficient; auto factors{ This.primes + other.primes }; GeneralizedHeapSort(factors); for (ptrdiff_t i = factors.size() - 1; i > 0; --i) { if (factors[i] == factors[i - 1]) { This.coefficient *= factors[i]; factors.erase(factors.begin() + i); factors.erase(factors.begin() + i); i--; } } return This; } radical& operator*=(const radical& other) { *this = *this * other; return *this; } bool negative() const { return coefficient < 0; } int len() const { int line{}; if (Arg != 1) { line += to_wstring(Arg).size() + 2; } if (abs(coefficient) != 1 or Arg == 1) { auto Coeff{ to_wstring(coefficient) }; if (Coeff.at(0) == L) { Coeff.erase(0, 1); } line += Coeff.size(); } return Arg != 1 and abs(coefficient) != 1 ? line + 1 : line; } void write(WORD attrib = 15, bool NoSign = false) const { GetConsoleScreenBufferInfo(hConsole, &csbi)(); if (csbi.dwCursorPosition.Y == 0) { wcout << L; } SetConsoleTextAttribute(hConsole, attrib); if (primes == tensor<int>{ 1 }) { GetConsoleScreenBufferInfo(hConsole, &csbi)(); auto coeff = NoSign ? to_wstring(abs(coefficient)) : to_wstring(coefficient); if (coeff.size() > csbi.dwSize.X - csbi.dwCursorPosition.X) { wcout << L; } wcout << coeff; return; } GetConsoleScreenBufferInfo(hConsole, &csbi)(); auto coeff = NoSign ? to_wstring(abs(coefficient)) : to_wstring(coefficient); auto argument{ to_wstring(arg()) }; int len = coeff.size() + argument.size() + 3; if (len > csbi.dwSize.X - csbi.dwCursorPosition.X) { wcout << L; } if (abs(coefficient) != 1) { wcout << coeff << L; } SetConsoleTextAttribute(hConsole, 14); wcout << L; GetConsoleScreenBufferInfo(hConsole, &csbi)(); wcout << L << argument << L; SetConsoleCursorPosition( hConsole, { csbi.dwCursorPosition.X, short(csbi.dwCursorPosition.Y - 1) } ); wcout << L << wstring(argument.size(), L); COORD SetCursor{ 0, csbi.dwCursorPosition.Y }; GetConsoleScreenBufferInfo(hConsole, &csbi)(); SetCursor.X = csbi.dwCursorPosition.X; SetConsoleCursorPosition(hConsole, SetCursor); SetConsoleTextAttribute(hConsole, 15)(); } }; class RadicalSum { tensor<radical> elements; public: RadicalSum() : elements({ radical() }) {} RadicalSum(radical el) : elements({ el }) {} RadicalSum(tensor<radical> elems) : elements(elems) { if (elements.empty()) { elements = { radical() }; } while (elements > 1 and elements[0].GetCoefficient() == 0) { --elements; } } long double approximation() const { long double result{}; for (size_t i = 0; i < elements; ++i) { result += elements[i].approximation(); } return result; } void normalize() { tensor<int> args; for (const auto& rad : elements) { args << rad.arg(); } for (size_t i = 0; i < args; ++i) { for (size_t j = i + 1; j < args; ++j) { if (args[i] > args[j]) { swap(args[i], args[j]); swap(elements[i], elements[j]); } } } for (ptrdiff_t i = args.size() - 1; i > 0; --i) { if (args[i] == args[i - 1]) { elements[i - 1].IncCoefficient(elements[i].GetCoefficient()); elements.erase(elements.begin() + i); args.erase(args.begin() + i); } } } void NORMALIZE() { for (auto& rad : elements) { rad.normalize(); } normalize(); } long double operator/(const RadicalSum& other) const { return approximation() / other.approximation(); } RadicalSum operator+(const RadicalSum& other) const { auto This{ *this }; This.elements += other.elements; This.normalize(); return This; } RadicalSum& operator+=(const RadicalSum& other) { *this = *this + other; return *this; } RadicalSum operator-(const RadicalSum& other) const { auto Other{ other }; for (auto& rad : Other.elements) { rad *= radical(-1, 1, true); } return *this + Other; } RadicalSum& operator-=(const RadicalSum& other) { *this = *this - other; return *this; } RadicalSum operator*(const RadicalSum& other) const { RadicalSum result(tensor<radical>{}); for (size_t i = 0; i < elements; ++i) { for (size_t j = 0; j < other.elements; ++j) { result += elements[i] * other.elements[j]; } } return result; } RadicalSum& operator*=(const RadicalSum& other) { *this = *this * other; return *this; } int len() const { int line{ elements[0].len() }; for (size_t i = 1; i < elements; ++i) { line += elements[i].len() + 3; } return line; } void write(WORD attrib = 15) const { elements[0].write(attrib); for (size_t i = 1; i < elements.size(); ++i) { SetConsoleTextAttribute(hConsole, attrib); wcout << L << (elements[i].negative() ? L : L) << L; SetConsoleTextAttribute(hConsole, 15)(); elements[i].write(attrib, true); } } }; class RadicalFract { RadicalSum top, bottom; public: RadicalFract() : top(radical(0)), bottom(radical(1)) {} RadicalFract(RadicalSum Top) : top(Top), bottom(radical(1)) {} RadicalFract(RadicalSum Top, RadicalSum Bottom) : top(Top), bottom(Bottom) {} long double approximation() const { auto Bottom{ bottom.approximation() }; if (Bottom == 0) { return nan(); } return top.approximation() / Bottom; } RadicalFract operator+(const RadicalFract& other) const { auto This{ *this }; This.top = top * other.bottom + bottom * other.top; This.bottom = bottom * other.bottom; return This; } RadicalFract& operator+=(const RadicalFract& other) { *this = *this + other; return *this; } RadicalFract operator-(const RadicalFract& other) const { auto This{ *this }; This.top = top * other.bottom - bottom * other.top; This.bottom = bottom * other.bottom; return This; } RadicalFract& operator-=(const RadicalFract& other) { *this = *this - other; return *this; } RadicalFract operator*(const RadicalFract& other) const { auto This{ *this }; This.top = top * other.top; This.bottom = bottom * other.bottom; return This; } RadicalFract& operator*=(const RadicalFract& other) { *this = *this * other; return *this; } RadicalFract operator/(const RadicalFract& other) const { auto This{ *this }; This.top = top * other.bottom; This.bottom = bottom * other.top; return This; } RadicalFract& operator/=(const RadicalFract& other) { *this = *this / other; return* this; } void write(WORD wAttribute = 15) const { int toplen{ top.len() }; int bottomlen{ bottom.len() }; int maxlen = toplen > bottomlen ? toplen : bottomlen; SetConsoleTextAttribute(hConsole, wAttribute); GetConsoleScreenBufferInfo(hConsole, &csbi)(); auto CursorPos{ csbi.dwCursorPosition }; if (maxlen > csbi.dwSize.X - CursorPos.X) { wcout << approximation(); return; } wcout << wstring(maxlen, L) << ; SetConsoleTextAttribute(hConsole, 15)(); int diff = fabs(toplen - bottomlen) / 2; SetConsoleCursorPosition( hConsole, { CursorPos.X, short(CursorPos.Y - 2) } ); if (toplen != maxlen) { wcout << wstring(diff, L); } top.write(wAttribute); SetConsoleCursorPosition( hConsole, { CursorPos.X, short(CursorPos.Y + 2) } ); if (bottomlen != maxlen) { wcout << wstring(diff, L); } bottom.write(wAttribute); } }; template<typename T_int = long double>struct MONOMIAL { int degree; T_int coefficient; bool operator == (const MONOMIAL& other) const { return coefficient == other.coefficient and degree == other.degree; } }; template<typename T_int = long double>class monomial { public: T_int coefficient{}; tensor<int> exp; bool operator==(const monomial& other) const { return coefficient == other.coefficient and exp == other.exp; } int degree() const { int sum{}; for (size_t i = 0; i < exp; ++i) { sum += exp[i]; } return sum; } bool IsSquare() const { if (!integer(sqrt(fabs(this->coefficient)))) { return false; } for (size_t i = 0; i < exp; ++i) { if (exp[i] % 2 == 1) { return false; } } return true; } monomial Root(int order) const { monomial result; result.coefficient = pow(this->coefficient, 1.0 / order); for (size_t i = 0; i < exp; ++i) { result.exp << (exp[i] / order); } return result; } }; template<typename T_int = long double>class factor : public tensor<monomial<T_int>> { public: factor() {} factor(initializer_list<monomial<T_int>> init): tensor<monomial<T_int>>(init) {} factor(size_t size, const monomial<T_int>& initial_value) { this->resize(size); count = size; fill(data, data + count, initial_value); } factor(size_t size) { this->resize(size); this->count = size; } factor(tensor<monomial<T_int>> vect) { for (const auto& value : vect) { this->push_back(value); } } void SortByDegree() { for (size_t i = 0; i < this->size(); ++i) { for (size_t j = i + 1; j < this->size(); ++j) { if (this->at(i).degree() < this->at(j).degree()) { swap(this->at(i), this->at(j)); } } } } void SortByExponents() { if (this->empty()) { return; } size_t size{ Variables.size() }; for (size_t i = 0; i < this->size(); ++i) { for (size_t j = i + 1; j < this->size(); ++j) { bool swap{ false }; for (size_t k = 0; k < size; ++k) { if (this->at(i).exp[k] > this->at(j).exp[k]) { break; } if (this->at(i).exp[k] == this->at(j).exp[k]) { continue; } swap = true; break; } if (swap) { ::swap(this->at(i), this->at(j)); } } } } factor derivate(size_t Vpos) const { tensor<int> null(Variables.size(), 0); if (this->empty()) { return { { 0, null } }; } auto Derivative{ *this }; for (ptrdiff_t i = Derivative.size() - 1; i >= 0; --i) { if (Derivative[i].exp[Vpos] == 0) { Derivative.erase(Derivative.begin() + i); continue; } Derivative[i].coefficient *= Derivative[i].exp[Vpos]--; } if (Derivative.empty()) { return { { 0, null } }; } return Derivative; } T_int operator()(tensor<long double> params) const { if (params > Variables.size()) { throw out_of_range(); } while (params < Variables.size()) { params << 0; } auto This{ *this }; for (size_t i = 0; i < Variables.size(); ++i) { This = This(params[i], i, 0); } if (This.empty()) { return 0; } return This[0].coefficient / LCM.Number<T_int>(); } factor operator()(T_int x, size_t Vpos, int) const; bool operator()(T_int x, size_t Vpos, bool) const { big X = x, y; for (size_t i = 0; i < this->size(); ++i) { y += (X ^ (*this)[i].exp[Vpos]) * (*this)[i].coefficient; } return y >= 0; } inline factor neg() const { auto This{ *this }; for (auto& mon : This) { mon.coefficient *= -1; } return This; } inline factor operator-(const factor& other) const; inline factor operator*(const factor& other) const; inline factor& operator-=(const factor& other); inline factor& operator*=(const factor& other); _NODISCARD wstring str(int size = Variables.size()) override { wstring polynomial; for (auto data : *this) { if (data.coefficient == 0) { continue; } wstring Monomial; Monomial = data.coefficient > 0 ? L : L; if ((data.coefficient != 1 and data.coefficient != -1) or data.exp == tensor<int>(data.exp.size(), 0)) { if constexpr (is_same_v<T_int, long double>) { Monomial += to_wstring((int)fabs(data.coefficient)); } else if constexpr (is_same_v<T_int, big>) { Monomial += data.coefficient.fabs().str(); } } for (size_t i = 0; i < Variables.size(); ++i) { if (data.exp[i] != 0) { Monomial += size == Variables.size() ? Variables.at(i) : Variables.at(Variables.find(charVariable)); if (data.exp[i] > 1) { Monomial += L + to_wstring((int)data.exp[i]); } } } polynomial += Monomial; } f (polynomial.empty()) { return L; } if (polynomial.at(0) == L) { polynomial.erase(0, 1); } return polynomial; } friend wostream& operator<<(wostream& os, factor& obj) { os << obj.str(); return os; } }; template<typename T_int = long double>class FACTOR : public tensor<MONOMIAL<T_int>> { public: FACTOR() {} FACTOR(initializer_list<MONOMIAL<T_int>> init): tensor<MONOMIAL<T_int>>(init) {} FACTOR(size_t size, const MONOMIAL<T_int>& initial_value) { this->resize(size); count = size; fill(data, data + count, initial_value); } FACTOR(size_t size) { this->resize(size); this->count = size; } FACTOR(tensor<MONOMIAL<T_int>> vect) { for (const auto& value : vect) { this->push_back(value); } } void sort() { for (size_t i = 0; i < this->size(); ++i) { for (size_t j = i + 1; j < this->size(); ++j) { if (this->at(i).degree < this->at(j).degree) { swap(this->at(i), this->at(j)); } } } } void complete(int s) { for (ptrdiff_t i = this->size() - 1; i > 0; --i) { for (int j = 1; j < (*this)[i - 1].degree - (*this)[i].degree; ++j) { this->insert(this->begin() + i, { (*this)[i - 1].degree - j, 0 }); } } if (this->empty()) { for (size_t i = 0; i < s; ++i) { this->push_back({ (int)i, 0 }); } } if (this->size() < s) { while ((*this)[0].degree < s - 1) { this->insert(this->begin(), { (*this)[0].degree + 1, 0 }); } while ((*this)[this->size() - 1].degree > 0) { this->push_back({ (*this)[this->size() - 1].degree - 1, 0 }); } } } FACTOR derivate() const { if (this->size() == 0) { return { { 0, 0 } }; } auto Derivative{ *this }; Derivative.sort(); Derivative.complete(Derivative[0].degree + 1); if (Derivative.size() == 1 and Derivative[0].degree == 0) { return { { 0, 0 } }; } for (size_t j = 0; j < Derivative; ++j) { Derivative[j].coefficient *= Derivative[j].degree--; } Derivative--; if (Derivative.empty()) { Derivative = { { 0, (*this)[0].coefficient } }; } return Derivative; } T_int operator()(T_int x) const { T_int fx{}; for (size_t i = 0; i < this->size(); ++i) { fx += ( (*this)[i].coefficient * pow(x, (*this)[i].degree) ) / LCM.Number<long double>(); } return fx; } inline FACTOR neg() const { auto This{ *this }; for (auto& mon : This) { mon.coefficient *= -1; } return This; } inline FACTOR operator-(const FACTOR& other) const; inline FACTOR operator*(const FACTOR& other) const; inline FACTOR& operator-=(const FACTOR& other); inline FACTOR& operator*=(const FACTOR& other); _NODISCARD wstring str(int size = Variables.size()) override { factor<T_int> traduction; int _FirstPos = Variables.find(charVariable); for (const auto& Monomial : *this) { monomial<T_int> element; element.coefficient = Monomial.coefficient; element.exp(Variables.size(), 0); element.exp[_FirstPos] = Monomial.degree; traduction << element; } return traduction.str(1); } friend wostream& operator<<(wostream& os, const FACTOR& obj) { os << obj.str(); return os; } }; static factor<> ToXV(FACTOR<> vect) { factor<> output; int _FirstPos = Variables.find(charVariable); for (const auto& Monomial : vect) { monomial<> element; element.coefficient = Monomial.coefficient; element.exp(Variables.size(), 0); element.exp[_FirstPos] = Monomial.degree; output << element; } return output; } static FACTOR<> To1V(factor<> vect) { FACTOR<> output; int _FirstPos = Variables.find(charVariable); for (const auto& Monomial : vect) { MONOMIAL<> element{ 0, 0 }; element.coefficient = Monomial.coefficient; if (_FirstPos != wstring::npos) { element.degree = Monomial.exp[_FirstPos]; } output << element; } return output; } static wstring CTSuperScript(wchar_t input); static wstring CFSuperScript(wstring script); static wstring ElabExponents(wstring& str); static void DeduceFromExponents(wstring& str); template<typename T_int = long double>class polynomial : public tensor<factor<T_int>> { public: polynomial() {} polynomial(initializer_list<factor<T_int>> init): tensor<factor<T_int>>(init) {} polynomial(size_t size, const factor<T_int>& initial_value) { this->resize(size); count = size; fill(data, data + count, initial_value); } polynomial(size_t size) { this->resize(size); this->count = size; } polynomial(tensor<factor<T_int>> vect) { for (const auto& value : vect) { this->push_back(value); } } void open() { for (size_t i = 0; i < this->count; ++i) { if ((*this)[i][0].exp[0] == -1) { auto repeat = (*this)[i][0].coefficient; this->erase(this->begin() + i); auto push{ (*this)[i] }; for (big j = 0; j < repeat - 1; ++j) { this->push_front(push); } } } } void close() { tensor<int> modifier(Variables.size()); modifier[0] = -1; factor<T_int> CommonFactor; if (this->count == 0) { return; } for (size_t i = 0; i < this->count; ++i) { for (ptrdiff_t j = this->count - 1; j > i; --j) { if ((*this)[i] == (*this)[j] and (*this)[i][0].exp[0] >= 0) { CommonFactor = (*this)[i]; i <= 0) { this->push_front({ { 2, modifier } }); this->erase(this->begin() + j + 1); continue; } if ((*this)[i - 1].size() == 1 and (*this)[i - 1][0].exp[0] < 0) { (*this)[i - 1][0].coefficient++; this->erase(this->begin() + j); continue; } int setK = 0; this->erase(this->begin() + j); this->insert(this->begin() + i, { { 2, modifier } }); for (size_t k = 0; k < this->size(); ++k) { if ((*this)[k] == CommonFactor) { setK = k; break; } } if ((*this)[i + 1] != CommonFactor) { swap((*this)[i + 1], (*this)[setK]); } } } } } _NODISCARD wstring str(int size = Variables.size()) override { if (this->count == 0) { return L; } wstring output, exp, coeffstr{ L }; bool IsAModifier{ false }; for (auto T : *this) { if (!T[0].exp.empty()) if (T[0].exp[0] < 0) { if constexpr (is_same_v<T_int, long double>) { exp = to_wstring((int)T[0].coefficient); } else if constexpr (is_same_v<T_int, big>) { exp = T[0].coefficient.str(); } IsAModifier = true; continue; } auto xout{ T.str(size) }; if (IsAModifier) { xout = L + xout + L + exp; IsAModifier = false; output += xout; continue; } if (T == 1) { coeffstr = xout; continue; } else if ((int)this->size() - (coeffstr != L) > 1) { xout = L + xout + L; } output += xout; } f (!output.empty()) { output = L + output + L; } else if (LCM != 1) { output.clear(); } else { return ElabExponents(coeffstr); } if (LCM.fabs() != 1 or coeffstr != L) { if constexpr (is_same_v<T_int, long double>) { if (LCM.fabs() != 1) { output = L + LCM.str() + L + output; } output = coeffstr + output; if (LCM.fabs() != 1) { output = L + output; } } else if constexpr (is_same_v<T_int, big>) { if (LCM.fabs() != 1) { if (!output.empty()) { output += L; } output = output + L + LCM.str() + L; } output = coeffstr + output; } } if (LCM < 0) { output = L + output; } if (output == L and coeffstr == L) { output = L; } else if (output.at(0) == L and (output).at((output).size() - 1) == L) { output.erase(0, 1); output.pop_back(); if (output.find(L) != wstring::npos and output.find(L) != wstring::npos) { output = L + output + L; } } return ElabExponents(output); } friend wostream& operator<<(wostream& os, polynomial& obj) { os << obj.str(); return os; } }; template<typename T_int = long double>class POLYNOMIAL : public tensor<FACTOR<T_int>> { public: POLYNOMIAL() {} POLYNOMIAL(initializer_list<FACTOR<T_int>> init): tensor<FACTOR<T_int>>(init) {} POLYNOMIAL(size_t size, const FACTOR<T_int>& initial_value) { this->resize(size); count = size; fill(data, data + count, initial_value); } POLYNOMIAL(size_t size) { this->resize(size); this->count = size; } POLYNOMIAL(tensor<FACTOR<T_int>> vect) { for (const auto& value : vect) { push_back(value); } } void open() { polynomial<T_int> NewClass; for (size_t i = 0; i < this->count; ++i) { NewClass << ToXV((*this)[i]); } NewClass.open(); this->clear(); for (size_t i = 0; i < NewClass; ++i) { this->push_back(To1V(NewClass[i])); } } void close() { polynomial<T_int> NewClass; for (size_t i = 0; i < this->count; ++i) { NewClass.push_back(ToXV((*this)[i])); } NewClass.close(); this->clear(); for (size_t i = 0; i < NewClass; ++i) { this->push_back(To1V(NewClass[i])); } } _NODISCARD wstring str(int size = Variables.size()) override { polynomial<T_int> traduction; for (const auto& vector : *this) { traduction << ToXV(vector); } return traduction.str(1); } friend wostream& operator<<(wostream& os, const POLYNOMIAL& obj) { os << obj.str(); return os; } }; static polynomial<> ToXV(POLYNOMIAL<> vect) { polynomial<> output; for (const auto& vector : vect) { output << ToXV(vector); } return output; } static POLYNOMIAL<> To1V(polynomial<> vect) { POLYNOMIAL<> output; for (const auto& vector : vect) { output << To1V(vector); } return output; } static polynomial<> FromBigToDefault(polynomial<big> BigPolynomial) { polynomial<> traduction; for (auto fact : BigPolynomial) { factor<> element; for (auto mon : fact) { monomial<> unity; unity.coefficient = mon.coefficient.Number<long double>(); if (isnan(unity.coefficient)) { return polynomial<>{ { { 1, tensor<int>(1, -2) } } }; } unity.exp = mon.exp; element << unity; } traduction << element; } return traduction; } template<typename T_int = long double> static factor<T_int> PolynomialSum(factor<T_int> vect); template<typename T_int = long double> static factor<T_int> PolynomialMultiply(polynomial<T_int> Polynomial); template <class T_int> factor<T_int> factor<T_int>::operator()(T_int x, size_t Vpos, int) const { auto This{ *this }; for (size_t i = 0; i < this->size(); ++i) { This[i].coefficient *= pow(x, This[i].exp[Vpos]); This[i].exp[Vpos] = 0; } return PolynomialSum<T_int>(This); } template<class T_int> inline factor<T_int> factor<T_int>::operator-(const factor& other) const { return PolynomialSum<T_int>(*this + other.neg()); } template<class T_int> inline factor<T_int> factor<T_int>::operator*(const factor& other) const { return PolynomialMultiply<T_int>({ *this, other }); } template<class T_int> inline factor<T_int>& factor<T_int>::operator-=(const factor& other) { *this = *this - other; return *this; } template<class T_int> inline factor<T_int>& factor<T_int>::operator*=(const factor& other) { *this = *this * other; return *this; } template<class T_int> inline FACTOR<T_int> FACTOR<T_int>::operator-(const FACTOR& other) const { return To1V(ToXV(*this) - ToXV(other)); } template<class T_int> inline FACTOR<T_int> FACTOR<T_int>::operator*(const FACTOR& other) const { return To1V(ToXV(*this) * ToXV(other)); } template<class T_int> inline FACTOR<T_int>& FACTOR<T_int>::operator-=(const FACTOR& other) { *this = *this - other; return *this; } template<class T_int> inline FACTOR<T_int>& FACTOR<T_int>::operator*=(const FACTOR& other) { *this = *this * other; return *this; } template<typename T> T ObjectOperations (wstring& errcode, tensor<T> list, tensor<wstring> ops, wstring disposition = L); template<class T = long double>class Fraction { public: polynomial<T> num, den; Fraction() : num(polynomial<T>{ { { 0, tensor<int>(Variables.size(), 0) } } }), den(polynomial<T>{ { { 1, tensor<int>(Variables.size(), 0) } } }) {} Fraction(polynomial<T> numerator) : num(numerator), den(polynomial<T>{ { { 1, tensor<int>(Variables.size(), 0) } } }) {} Fraction(polynomial<T> numerator, polynomial<T> denominator) : num(numerator), den(denominator) {} Fraction extend() { num = { PolynomialMultiply<T>(num) }; den = { PolynomialMultiply<T>(den) }; return *this; } Fraction derivate(size_t Vpos) const { Fraction derivative{ { num[0].derivate(Vpos) * den[0] - num[0] * den[0].derivate(Vpos) }, { den[0] * factor<T>(den[0]) } }; bool empty{ true }; for (const auto& term : derivative.num) { if (!term.empty()) { empty = false; break; } } if (empty) { derivative.num = { { { 0, tensor<int>(Variables.size(), 0) } } }; } return derivative; } Fraction operator+(const Fraction& other) const { Fraction res; res.num = { PolynomialMultiply<T>(num + other.den) - PolynomialMultiply<T>(other.num + den).neg() }; res.den = { PolynomialMultiply<T>(den + other.den) }; return res; } Fraction operator+=(const Fraction& other) { *this = *this + other; return *this; } Fraction operator-(const Fraction& other) const { Fraction res; res.num = { PolynomialMultiply<T>(num + other.den) - PolynomialMultiply<T>(other.num + den) }; res.den = { PolynomialMultiply<T>(den + other.den) }; return res; } Fraction operator-=(const Fraction& other) { *this = *this - other; return *this; } Fraction operator*(const Fraction& other) const { Fraction res; res.num = { PolynomialMultiply<T>(num + other.num) }; res.den = { PolynomialMultiply<T>(den + other.den) }; return res; } Fraction operator*=(const Fraction& other) { *this = *this * other; return *this; } Fraction invert() { Fraction res; res.num = den; res.den = num; return res; } Fraction operator/(const Fraction& other) const { Fraction res; res.num = { PolynomialMultiply<T>(num + other.den) }; res.den = { PolynomialMultiply<T>(den + other.num) }; return res; } Fraction operator/=(const Fraction& other) { *this = *this / other; return *this; } Fraction operator()(T x, size_t Vpos) const { auto res{ *this }; for (auto& fact : res.num) { fact = fact(x, Vpos, 0); } for (auto& fact : res.den) { fact = fact(x, Vpos, 0); } return res; } T operator()(tensor<long double> params) const { T res{ 1 }; for (size_t i = 0; i < num.size(); ++i) { res *= num[i](params); } for (size_t i = 0; i < den.size(); ++i) { res /= den[i](params); } return res; } bool operator==(const Fraction& other) const { return num == other.num and den == other.den; } wstring str() { if ( den == polynomial<T>{ { { 1, tensor<int>(Variables.size(), 0) } } } ) { return num.str(); } uto Num{ num.str() }; auto Den{ den.str() }; if (Num.find(L) != wstring::npos or Num.find(L) != wstring::npos) { Num = L + Num + L; } if (Den.find(L) != wstring::npos or Den.find(L) != wstring::npos) { Den = L + Den + L; } return Num + L + Den; } friend wostream& operator<<(wostream& os, const Fraction& obj) { os << obj.str(); return os; } }; static tensor<Fraction<big>> GetManyFractions (tensor<wstring> numerators, tensor<wstring> denominators, wstring& errcode); class key : public tensor<int> { public: using tensor<int>::tensor; key(tensor<int> val) { this->count = 0; for (const auto& el : val) *this << el; } key operator!() { auto res{ *this }; res.last()++; return res; } key operator~() const { auto res{ *this }; res.last()--; return res; } _NODISCARD inline bool operator<(const tensor& other) const override { if (*this == other) { return false; } auto min_size{ min(this->size(), other.size()) }; for (size_t i = 0; i < min_size; ++i) { if ((*this)[i] != other[i]) { return (*this)[i] < other[i];; } } return this->size() < other.size(); } _NODISCARD inline bool operator<=(const tensor& other) const override { return *this < other or *this == other; } _NODISCARD inline bool operator>(const tensor& other) const override { return !(*this < other) and *this != other; } _NODISCARD inline bool operator>=(const tensor& other) const override { return !(*this < other); } }; static wstring ConvertEnumToWString(switchcase Enum); static switchcase ConvertWStringToEnum(wstring str); tensor<wstring> commands { L, L , L, L, L , L, L, L , L, L , L, L, L , L, L , L, L, L, L , L, L, L }; class Expression; tensor<Expression> __Expr; class Expression { private: using ReturnedFractionType = big; bool activator; _STD map<key, wstring> terms{ { {}, L } }; tensor<key> lines, lister{ {} }; tensor<COORD> FractionLinesPos; tensor<short> FractionLinesLenght; _STD map<key, COORD> dimensions, positions; public: Expression() : activator(false) {}; Expression& operator=(const Expression& other) { if (this == &other) { return *this; } terms = other.terms; lister = other.lister; lines = other.lines; activator = true; } bool contains(key index) const { for (size_t i = 0; i < lister; ++i) { if (lister[i] == index) { return true; } } return false; } void clean() { tensor<key> keys, ops; if (terms.find({}) != terms.end()) { terms.erase(key()); } for (const auto& item : lister) { auto term{ item }; if (terms.find(item + 0) != terms.end()) { for (;;) { keys << term; if (term.empty()) { break; } term--; } } } for (const auto& Key : keys) { if (terms.find(Key) != terms.end()) { terms.erase(Key); } } keys.clear(); for (const auto& line : lines) { for (int Last = 2; contains(line + Last); ++Last) { auto Tensor{ line + Last }; if (terms.find(Tensor) != terms.end()) { keys << Tensor; } ops << Tensor; } } for (const auto& Key : keys) { terms.erase(Key); } for (const auto& op : ops) { for (size_t i = 0; i < lister; ++i) { if (lister[i] == op) { lister.erase(lister.begin() + i); } } } } tensor<key> underbranch(key node) const { tensor<key> output; if (!contains(node)) { return {}; } for (int Last = 0; contains(node + Last); ++Last) { output << node + Last; } return output; } void Insert(key where, wstring Num = L, wstring Den = L) { activator = true; key branch{ where }; branch--; auto branchsize = branch.empty() ? 0 : branch.size() - 1; for (auto& line : lines) { if (where <= line and where.size() <= line.size() and key(line)(branchsize) + where.last() == where) { line[branch.size()]++; } } for (ptrdiff_t i = lister.size() - 1; i >= 0; --i) { auto& ind{ lister[i] }; if (where <= ind and where.size() <= ind.size() and key(ind)(branchsize) + where.last() == where) { if (terms.find(ind) != terms.end()) { auto temp{ terms[ind] }; terms.erase(ind); ind[branch.size()]++; terms[ind] = temp; } else { ind[branch.size()]++; } } } if (Den == L) { lister << where; terms[where] = Num; } else { lines << where; lister << where << where + 0 << where + 1; lister << where + 0 + 0 << where + 1 + 0; terms[where + 0 + 0] = Num; terms[where + 1 + 0] = Den; } lean(); } void Remove(key node) { auto New{ node }; bool ExecLoop{ true }; tensor<tensor<bool>> shifted{ tensor<bool>(lines.size(), false), tensor<bool>(lister.size(), false) }; auto remove{ shifted }; tensor<tensor<key>> container{ lines, lister }; loop: for (size_t i = 0; i < container[ExecLoop]; ++i) { if (container[ExecLoop][i].size() < New.size()) { continue; } bool ContinueLoop{ false }; for (size_t j = 0; j < New; ++j) { if (j == New.size() - 1 and New[j] < container[ExecLoop][i][j]) { shifted[ExecLoop][i] = true; ContinueLoop = true; break; } if (New[j] != container[ExecLoop][i][j]) { ContinueLoop = true; break; } } if (ContinueLoop) { continue; } remove[ExecLoop][i] = true; } if (ExecLoop) { for (size_t i = 0; i < container[1]; ++i) { if (terms.find(container[1][i]) != terms.end() and remove[1][i]) { terms.erase(container[1][i]); } } tensor<key> ListOfKeys; for (size_t i = 0; i < container[1]; ++i) { if (shifted[1][i]) { ListOfKeys << container[1][i]; } } if (ListOfKeys > 1) { GeneralizedHeapSort(ListOfKeys); } for (size_t i = 0; i < ListOfKeys; ++i) { if (terms.find(ListOfKeys[i]) != terms.end()) { auto location{ ListOfKeys[i] }; auto temp{ terms[location] }; terms.erase(location); location[node.size() - 1]--; terms[location] = temp; } } or ( ptrdiff_t i = container[ExecLoop].size() - 1; i >= 0; --i ) { if (remove[ExecLoop][i]) { container[ExecLoop].erase( container[ExecLoop].begin() + i ); continue; }  (shifted[ExecLoop][i]) { container[ExecLoop][i][node.size() - 1]--; } } if (ExecLoop) { ExecLoop = false; goto loop; } lines = container[0]; lister = container[1]; } COORD GetDimensions(key node = {}) { if (terms.find(node) != terms.end()) { auto str{ terms[node] }; auto size{ str.size() };  (BOOLALPHA) { for (ptrdiff_t i = 0; i < (int)str.size() - 1; ++i) { if (str.at(i) == L and isdigit(str.at(i + 1))) { size--; } } } for (const auto& ch : str) { if (ch == L) { size--; } } return dimensions[node] = COORD{ short(size), 1 }; } ool fraction{ false }; for (const auto& line : lines) { if (line == node) { fraction = true; break; } } if (fraction) { COORD num{ GetDimensions(node + 0) }, den{ GetDimensions(node + 1) }; COORD result{ max(num.X, den.X), short(num.Y + den.Y + 1) }; if (terms.find(node + 0 + 0) == terms.end() or terms.find(node + 1 + 0) == terms.end()) { result.X += 2; } dimensions[node] = result; return result; } auto branch{ underbranch(node) }; if (branch.empty()) { return COORD(); } tensor<COORD> branchcoords; for (const auto& index : branch) { branchcoords << GetDimensions(index); } COORD result{}; for (const auto& coord_ : branchcoords) { if (result.Y < coord_.Y) { result.Y = coord_.Y; } } for (int i = -1; i <= branch.last().last(); ++i) { key Key{ node + i }; if (i >= 0) { result.X += dimensions[branch[i]].X; } } dimensions[node] = result; return result; } void GetPositions() { if (dimensions.empty() or activator) { dimensions.clear(); GetDimensions(); } if (dimensions.empty()) { return; } positions.clear(); FractionLinesPos.clear(); FractionLinesLenght.clear(); key node; positions[{}] = { 0, 0 }; if (!activator) { return; } for (;;) { auto directordim{ dimensions[node] }; auto directorpos{ positions[node] }; bool fraction{ false }; for (const auto& index : lines) { if (index == node) { fraction = true; break; } } if (fraction) { positions[node + 0] = COORD{ short( directorpos.X + (directordim.X - dimensions[node + 0].X) / 2 ), directorpos.Y }; positions[node + 1] = COORD{ short( directorpos.X + (directordim.X - dimensions[node + 1].X) / 2 ), short(directorpos.Y + dimensions[node + 0].Y + 1) }; FractionLinesPos << COORD{ directorpos.X, short(directorpos.Y + dimensions[node + 0].Y) }; FractionLinesLenght << directordim.X; } else { bool start{ true }; auto branch{ underbranch(node) }; tensor<short> lenghts(branch.size()), widths(branch.size()); for (size_t i = 0; i < branch; ++i) { widths[i] = (directordim.Y - dimensions[branch[i]].Y) / 2; } for (size_t i = 0; i < branch; ++i) { lenghts[i] = (start ? 0 : 1) + dimensions[branch[i]].X; } for (size_t i = 1; i < lenghts; ++i) { lenghts[i] += lenghts[i - 1]; } for (size_t i = 0; i < branch; ++i) { positions[branch[i]] = COORD{ short(directorpos.X + lenghts[i] - dimensions[branch[i]].X), short(directorpos.Y + widths[i]) }; } } if (terms.find(node) != terms.end()) { node.last()++; continue; } if (contains(node) or node.empty()) { node << 0; continue; } if (node == 1) { break; } node--; node.last()++; } } bool out(COORD& StarterCoord) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); R; GetConsoleScreenBufferInfo(hConsole, &csbi)(); if (StarterCoord.X == -1) { StarterCoord = csbi.dwCursorPosition; } auto SizeLimit{ csbi.dwSize }; if (positions.empty() or activator) { GetPositions(); } if (positions.empty()) { return true; } activator = false; GetConsoleScreenBufferInfo(hConsole, &csbi)(); short space{ max(short(7), dimensions[{}].Y) }; if (space > csbi.dwSize.Y) { return false; } COORD start{ 0, csbi.dwCursorPosition.Y }; if (csbi.dwSize.Y - start.Y < space) { wcout << wstring(space, L); int scroll{ space - csbi.dwSize.Y + start.Y }; start.Y -= scroll; StarterCoord.Y -= scroll; } SetConsoleCursorPosition(hConsole, start); SetConsoleTextAttribute(hConsole, 10); for (size_t i = 0; i < FractionLinesPos; ++i) { FractionLinesPos[i].X += StarterCoord.X; FractionLinesPos[i].Y += StarterCoord.Y;  (FractionLinesPos[i].X + FractionLinesLenght[i] >= SizeLimit.X or FractionLinesPos[i].Y >= SizeLimit.Y) { continue; } SetConsoleCursorPosition(hConsole, FractionLinesPos[i]); wcout << wstring(FractionLinesLenght[i], L) << L; } SetConsoleTextAttribute(hConsole, 15)(); for (const auto& Key : lister) { if (terms.find(Key) == terms.end()) { continue; } auto pos{ positions[Key] }; pos.X += StarterCoord.X; pos.Y += StarterCoord.Y; if (pos.X + terms[Key].size() >= SizeLimit.X or pos.Y >= SizeLimit.Y) { continue; } SetConsoleCursorPosition(hConsole, pos); auto write{ terms[Key] }; if (write == L) { wcout << L; continue; } wstring YellowString; size_t EraseIndex = write.find(L); if (EraseIndex != wstring::npos) { YellowString = write; write.erase(EraseIndex); YellowString.erase(0, EraseIndex + 1); } wcout << ElabExponents(write); SetConsoleTextAttribute(hConsole, 6); wcout << YellowString << L; SetConsoleTextAttribute(hConsole, 15)(); } SetConsoleCursorInfo(hConsole, &cursor); return true; } COORD CursorPosition(key at) { if (positions.empty() or activator) { GetPositions(); } if (positions.empty()) { return COORD(); } activator = false; COORD result; if (at.last() < 0) { at.last() = 0; result = COORD{ short(positions[at].X), short(positions[at].Y + dimensions[at].Y / 2) }; } else { result = COORD{ short(positions[at].X + dimensions[at].X), short(positions[at].Y + dimensions[at].Y / 2) }; } if (terms.find({ 0, 0, 0 }) == terms.end()) { return result; } if (at != key{ 0, 0, 0 }) { return result; } auto pos{ terms[at].find(L) }; if (pos == wstring::npos) { return result; } result.X -= terms[at].size() - pos - 1; return result; } bool rewrite(COORD& Begin, key location, int phase) { if (activator) { ClearArea( { short(csbi.dwSize.X + Begin.X / 2), short(dimensions[{}].Y / 2 + Begin.Y) }, { short(csbi.dwSize.X - Begin.X / 2), short(dimensions[{}].Y / 2) } ); if (!out(Begin)) { return false; } } auto position{ CursorPosition(location) }; position.X += Begin.X - phase; position.Y += Begin.Y; SetConsoleCursorPosition(hConsole, position); et true; } Fraction<ReturnedFractionType> in (switchcase& redirection, wstring& errorcode, bool& graph, bool& equate) { using type = char; int EscapeCode, diff{ 1 }; if constexpr (is_same_v<type, char>) { EscapeCode = -32; } else { EscapeCode = 224; } terms.clear(); terms[{ 0, 0, 0 }] = terms[{ 0, 1, 0 }] = L; terms[{ 1 }] = L; lister = { {}, { 0 }, { 1 }, { 0, 0 }, { 0, 1 }, { 0, 0, 0 }, { 0, 1, 0 }, { 1, 0 } }; lines = { { 0 } }; activator = true; size_t TensorIndex{}; key CursorIndex({ 0, 0, 0 }); GetCursorPos(); COORD begin{ 0, csbi.dwCursorPosition.Y }; if (!out(begin)) { errorcode = L; return Fraction<ReturnedFractionType>{}; } SetConsoleCursorPosition(hConsole, begin); bool arrow{ false }, copied{ false }; for (;;) { if (GetAsyncKeyState(VK_CONTROL) & 0x8000 and GetAsyncKeyState(VK_MENU) & 0x8000) { while (GetAsyncKeyState(VK_CONTROL) & 0x8000 and GetAsyncKeyState(VK_MENU) & 0x8000); if (terms[CursorIndex] == L) { terms[CursorIndex] = L; } else if (CursorIndex.last() >= 0 and Last(terms[CursorIndex]) != L) { terms[CursorIndex] += L; } CursorIndex.last()++; lines << CursorIndex; lister << CursorIndex; lister << CursorIndex + 0 << CursorIndex + 0 + 0; lister << CursorIndex + 1 << CursorIndex + 1 + 0; auto Cursor{ CursorIndex }; Cursor.last()++; lister << Cursor; terms[Cursor] = L; terms[CursorIndex + 1 + 0] = L; CursorIndex << 0 << 0; terms[CursorIndex] = L; terms[Cursor] = L; diff = 1; activator = true; clean(); } if (GetAsyncKeyState(VK_CONTROL) & 0x8000 and GetAsyncKeyState(VK_SHIFT) & 0x8000) { while (GetAsyncKeyState(VK_CONTROL) & 0x8000 and GetAsyncKeyState(VK_SHIFT) & 0x8000); BOOLALPHA = !BOOLALPHA; activator = true; } if (_kbhit()) { bool Cont{ false }; char c; INPUT_RECORD inptrc; DWORD eventf; for (;;) { PeekConsoleInput(hConsoleInput, &inptrc, 1, &eventf); if (inptrc.EventType == KEY_EVENT and inptrc.Event.KeyEvent.bKeyDown) { c = inptrc.Event.KeyEvent.uChar.UnicodeChar; if (inptrc.Event.KeyEvent.wVirtualKeyCode == VK_F1) { TensorIndex = __Expr.empty() ? 0 : ( TensorIndex == 0 ? __Expr.size() - 1 : TensorIndex - 1 ); ReadConsoleInput(hConsoleInput, &inptrc, 1, &eventf); Cont = true; break; } if (inptrc.Event.KeyEvent.wVirtualKeyCode == VK_F2) { TensorIndex = __Expr.empty() ? 0 : ( TensorIndex == __Expr.size() - 1 ? 0 : TensorIndex + 1 ); nsoleInput(hConsoleInput, &inptrc, 1, &eventf); Cont = true; break; } if (inptrc.Event.KeyEvent.wVirtualKeyCode == VK_LEFT or inptrc.Event.KeyEvent.wVirtualKeyCode == VK_RIGHT or inptrc.Event.KeyEvent.wVirtualKeyCode == VK_UP or inptrc.Event.KeyEvent.wVirtualKeyCode == VK_DOWN) { break; } if (c != 0) { break; } } ReadConsoleInput(hConsoleInput, &inptrc, 1, &eventf); } (Cont) { if (!__Expr.empty()) { copied = true; *this = __Expr[TensorIndex]; rIndex = { 0 }; do { for (; contains(CursorIndex); ++CursorIndex.last()); if (CursorIndex.last() <= 1) { CursorIndex.last() = 0; } else { CursorIndex.last() -= 2; } } while ( terms.find(CursorIndex) == terms.end() ? (CursorIndex += key({ 0, 0 }), true) : false ); diff = 0; } le (_kbhit()) { c = _getch(); } bool failed{ !rewrite(begin, CursorIndex, diff) }; if (failed) { errorcode = L; return Fraction<ReturnedFractionType>{}; } continue; }  _getch(); if (c == L) { continue; } if (c == EscapeCode) { arrow = true; continue; } if (c == L and CursorIndex == key{ 0, 0, 0 }) { auto pos{ terms[{ 0, 0, 0 }].find(L) }; if (pos != wstring::npos) { terms[{ 0, 0, 0 }].erase(pos, 1); } } if (terms.find({ 0, 0, 0 }) != terms.end()) { auto pos{ terms[{ 0, 0, 0 }].find(L) }; if (pos != wstring::npos) { terms[{ 0, 0, 0 }].erase(pos); } } if (arrow) { switch (c) { case L: { bool ExecuteMove{ false }; if (terms.find(CursorIndex) != terms.end()) { wstring current{ terms[CursorIndex] }; ElabExponents(current); if (diff < current.size()) { diff++; break; } if (CursorIndex == key{ 0 }) { break; } if (CursorIndex.last() == 0) { ExecuteMove = true; } } if (CursorIndex.last() < 0 or ExecuteMove) { if (CursorIndex.size() <= 1) { break; } if (CursorIndex[CursorIndex.size() - 2] == 0) { CursorIndex[CursorIndex.size() - 2] = 1; CursorIndex--; CursorIndex = underbranch(CursorIndex).last(); diff = 0; break; } if (CursorIndex[CursorIndex.size() - 2] == 1) { CursorIndex -= 2; CursorIndex.last()--; diff = 0; break; } } CursorIndex.last()--; CursorIndex = underbranch(CursorIndex + 0).last(); diff = 0; } break; case L: { if (terms.find(CursorIndex) != terms.end()) { if (diff > 0) { diff--; break; } if (CursorIndex == underbranch({}).last()) { break; } auto branch{ CursorIndex }; branch--; if (CursorIndex == underbranch(branch).last()) { if (CursorIndex[CursorIndex.size() - 2] == 1) { CursorIndex[CursorIndex.size() - 2] = 0; CursorIndex.last() = 0; if (terms.find(CursorIndex) == terms.end()) { CursorIndex.last() = -1; diff = 0; } else { wstring current{ terms[CursorIndex] }; ElabExponents(current); diff = current.size(); } break; } if (CursorIndex[CursorIndex.size() - 2] == 0) { CursorIndex -= 2; CursorIndex.last()++; wstring current{ terms[CursorIndex] }; ElabExponents(current); diff = current.size(); break; } } } CursorIndex.last()++; CursorIndex << 1 << 0; if (terms.find(CursorIndex) == terms.end()) { CursorIndex.last() = -1; } else { wstring current{ terms[CursorIndex] }; ElabExponents(current); diff = current.size(); } } break; case L: if (diff > 0) { terms[CursorIndex].erase( terms[CursorIndex].size() - diff, 1 ); if (diff > 0) { diff--; } break; } __fallthrough; case -109: if (diff > 0) { terms[CursorIndex].erase( terms[CursorIndex].size() - diff ); break; } if (CursorIndex.last() >= underbranch(key(CursorIndex) -= 1).last().last()) { break; } CursorIndex.last()++; Remove(CursorIndex); break; case L: { wstring current{ terms[CursorIndex] }; ElabExponents(current); if (diff != current.size()) { diff = current.size(); break; } if (CursorIndex.last() > 0) { CursorIndex.last()--; } diff = 0; break; } case L: { if (diff != 0) { diff = 0; break; } CursorIndex.last()++; if (!contains(CursorIndex)) { CursorIndex.last()--; } diff = 0; break; } case L: { if (CursorIndex.size() < 2) { continue; } CursorIndex[CursorIndex.size() - 2] = 0; CursorIndex.last() = 0; wstring current{ terms[CursorIndex] }; ElabExponents(current); if (diff > current.size()) { diff = current.size(); } } break; case L: { if (CursorIndex.size() < 2) { continue; } CursorIndex[CursorIndex.size() - 2] = 1; CursorIndex.last() = 0; wstring current{ terms[CursorIndex] }; ElabExponents(current); if (diff > current.size()) { diff = current.size(); } } break; } activator = true; arrow = false; continue; } switch (c) { case L: errorcode = L; return Fraction<ReturnedFractionType>{}; case L: if (terms[CursorIndex] == L) { break; } if (terms[CursorIndex].size() > diff) { auto vel{ terms[CursorIndex] }; ElabExponents(vel); if (vel.size() > 1 and vel.size() - diff > 0) { vel.erase(vel.size() - 1 - diff, 1); DeduceFromExponents(vel); terms[CursorIndex] = vel; break; } el.size() == 1 and diff == 0) { terms[CursorIndex] = L; diff = 1; } break; } terms.erase(CursorIndex); for (ptrdiff_t i = lister.size() - 1; i >= 0; --i) { if (lister[i] == CursorIndex) { lister.erase(lister.begin() + i); break; } } CursorIndex.last()--; diff = 0; __fallthrough; case 127: if (CursorIndex.last() < 0) { break; } if (diff > 0) { terms[CursorIndex].erase( 0, terms[CursorIndex].size() - diff ); break; } Remove(CursorIndex); CursorIndex.last()--; if (CursorIndex.last() < 0) { CursorIndex.last()++; lister << CursorIndex; terms[CursorIndex] = L; } break; case L: if (!copied) { __Expr << *this; } SetConsoleCursorPosition( hConsole, { 0, short(begin.Y + dimensions[{}].Y + 1) } ); return Export(redirection, errorcode, graph, equate); default: if (terms[CursorIndex] == L) { terms[CursorIndex] = wstring(1, c); diff = 0; break; } if (terms[CursorIndex].empty() and CursorIndex.last() > 0 and c != L) { terms[CursorIndex] += L; } auto vel{ terms[CursorIndex] }; auto new_diff{ (int)vel.size() - diff }; auto backup{ vel }; ElabExponents(vel); auto copy{ vel }; copy.erase(0, vel.size() - diff); for (const auto& ch : copy) { if (CFSuperScript(wstring(1, ch)) != wstring(1, ch)) { new_diff--; } } if (new_diff < 0) { new_diff = 0; } vel = backup.substr(0, new_diff) + wstring(1, c) + backup.substr(new_diff, backup.size()); terms[CursorIndex] = vel; } if (terms.find({ 0, 0, 0 }) != terms.end()) { auto Word{ terms[{ 0, 0, 0 }] }; if (!Word.empty()) { for (const auto& comma : commands) { if (Word == comma) { break; } auto back{ comma }; if (back.size() > Word.size()) { back.erase(Word.size()); } if (back == Word) { back = comma; back.erase(0, Word.size()); Word += L + back; break; } } terms[{ 0, 0, 0 }] = Word; } } clean(); activator = true; GetConsoleScreenBufferInfo(hConsole, &csbi)(); } if (activator) { copied = false; } bool failed{ !rewrite(begin, CursorIndex, diff) }; if (failed) { errorcode = L; return Fraction<ReturnedFractionType>{}; } } } Fraction<ReturnedFractionType> Export (switchcase& redirection, wstring& errorcode, bool& graph, bool& equate) { bool search{ false }; size_t first{}, last{}; tensor<int> datas; tensor<bool> IsChar; wstring Word = terms.find({ 0, 0, 0 }) != terms.end() ? terms[{ 0, 0, 0}] : L; auto EraseIndex{ Word.find(L) }; if (EraseIndex != wstring::npos) { Word.erase(EraseIndex); } for (size_t i = 0; i <= Word.size(); ++i) { if (i < Word.size()) { if (isalpha(Word.at(i))) { if (!search) { search = true; first = i; } last = i; continue; } } if (!search) { continue; first = last = i; } search = false; if ( (redirection = ConvertWStringToEnum( Word.substr(first, last - first + 1) )) != NotAssigned ) { terms[{ 0, 0, 0 }] = Word; terms[{ 0, 0, 0 }].erase(0, last + 1); if (terms[{ 0, 0, 0 }].empty()) { Remove({ 0, 0, 0 }); } auto arguments{ Word }; arguments.erase(first); bool add{ false }; size_t _first{}, _last{}; for (size_t j = 0; j < arguments.size(); ++j) { if (!isdigit(arguments.at(j)) and arguments.at(j) != L) { if (add and _last - _first <= 10) { add = false; IsChar << false; datas << stoi( arguments.substr(_first, _last - _first + 1) ); } else if (isalpha(arguments.at(j))) { IsChar << true; datas << arguments.at(j); } _last = _first = j; continue; } if (!add) { add = true; _first = j; } _last = j; } break; } if (i == Word.size()) { break; } first = last = i; } equate = false; for (auto& term : terms) { auto& str{ term.second }; if (str == L) { str = L; continue; } for (ptrdiff_t i = str.size() - 1; i >= 0; --i) { if (str.at(i) == L or str.at(i) == L) { str.erase(i, 1); } } if (str.find(L) != wstring::npos) { equate = true; } } graph = false; if (terms.find({ 0, 0, 0 }) != terms.end()) { if (!terms[{ 0, 0, 0 }].empty()) { if (terms[{ 0, 0, 0 }].at(0) == L) { graph = true; terms[{ 0, 0, 0 }].erase(0, 1); } } } int sizemax{ 1 }, index; for (;;) { if (lines.empty()) { break; } sizemax = index = 0; for (size_t i = 0; i < lines; ++i) { if (sizemax < lines[i].size()) { sizemax = lines[i].size(); index = i; } } if (sizemax <= 1) { sizemax = 1; break; } auto main{ lines[index] }; lines.erase(lines.begin() + index); int delta{}; main -= 2; tensor<tensor<key>> fractal{ {}, {} }; for (const auto& Key : terms) { if (Key.first.size() < main) { continue; } bool Continue{ false }; for (size_t i = 0; i < main; ++i) { if (Key.first[i] != main[i]) { Continue = true; break; } } if (Continue) { continue; } fractal[Key.first[main.size()]] << Key.first; } GeneralizedHeapSort(fractal[0]); GeneralizedHeapSort(fractal[1]); Insert(main, L); bool skip{ false }; for (size_t i = 0; i < fractal[0]; ++i) { if (skip) { skip = false; continue; } delta++; main.last()++; if (fractal[0][i] == sizemax) { fractal[0][i][main.size() - 1] += delta; Insert(main, terms[fractal[0][i]]); continue; } fractal[0][i][main.size() - 1] += delta; fractal[0][i + 1][main.size() - 1] += delta; Insert(main, terms[fractal[0][i]], terms[fractal[0][i + 1]]); skip = true; } delta++; main.last()++; Insert(main, L); skip = false; for (size_t i = 0; i < fractal[1]; ++i) { if (skip) { skip = false; continue; } delta++; main.last()++; if (fractal[1][i] == sizemax) { fractal[1][i][main.size() - 1] += delta; Insert(main, terms[fractal[1][i]]); continue; } fractal[1][i][main.size() - 1] += delta; fractal[1][i + 1][main.size() - 1] += delta; Insert(main, terms[fractal[1][i]], terms[fractal[1][i + 1]]); skip = true; } main.last()++; Insert(main, L); main.last()++; Remove(main); clean(); } int Size{}; for (const auto& item : terms) { if (Size < item.first[sizemax - 1]) { Size = item.first[sizemax - 1]; } } bool activated{ false }; for (int i = Size; i >= 0; --i) { if (terms.find({ i }) == terms.end()) { activated = false; continue; } if (!activated) { activated = true; continue; } terms[{ i }] += terms[{ i + 1 }]; Remove({ i + 1 }); Size--; } bool FractionFirst{ true }; tensor<wstring> Opers, Tops, Bottoms; for (key ind = { 0 }; ind[0] <= Size; ++ind.last()) { if (!ind[0]) { if (FractionFirst = terms.find(ind) == terms.end()) { Opers << L; } } if ((ind[0] + FractionFirst) % 2) { Tops << terms[ind + tensor<int>{ 0, 0 }]; Bottoms << terms[ind + tensor<int>{ 1, 0 }]; continue; } nsor<wstring> opers, strings; auto pol{ terms[ind] }; int balance{}; tensor<ptrdiff_t> indeces{ -1 }; tensor<int> distribution{ 0 }; for (size_t i = 0; i < pol.size(); ++i) { switch (pol.at(i)) { case L: distribution << ++balance; indeces << i; break; case L: distribution << --balance; indeces << i; break; } } t min = distribution.empty() ? 0 : distribution[0]; for (size_t i = 1; i < distribution; ++i) { if (min > distribution[i]) { min = distribution[i]; } } for (auto& Balance : distribution) { Balance -= min; } ptrdiff_t fi{}, li{}; for (ptrdiff_t i = 0; i < distribution; ++i) { if (distribution[i] == 0) { fi = i; break; } } for (ptrdiff_t i = distribution.size() - 1; i >= 0; --i) { if (distribution[i] == 0) { li = i; break; } } tensor<ptrdiff_t> left, right; for (ptrdiff_t i = li + 1; i < distribution; ++i) { if (distribution[i] + 1 < right) { right--; continue; } if (distribution[i] + 1 != right) { right << indeces[i]; } } for (ptrdiff_t i = fi; i >= 0; --i) { if (indeces.empty()) { break; } if (i == fi and i == li) { continue; } if (distribution[i] + 1 < left) { left--; continue; } if (distribution[i] + 1 != left) { left << indeces[i]; } } auto Final{ left + right }; if (li == fi and Final.empty() and distribution != tensor<int>{ 0 }) { Final = { li }; } if (pol == L or pol == L) { opers << pol; } else { for (ptrdiff_t i = Final.size() - 1; i >= 0; --i) { if (Final[i] < 0) { continue; } auto temp{ pol }; temp.erase(0, Final[i] + 1); strings >> temp; opers >> wstring(1, pol.at(Final[i])); pol.erase(Final[i]); } strings >> pol; opers >> L << L; } wstring checker{ L }; for (size_t i = 0; i < strings; ++i) { auto Pol{ strings[i] }; if (Pol.empty()) { continue; } if (Last(Pol) == L) { errorcode = L; return Fraction<ReturnedFractionType>(); } int ParenthesisBalance{}; for (ptrdiff_t j = Pol.size() - 1; j < Pol.size() and j >= 0; --j) { switch (Pol.at(j)) { case L: ParenthesisBalance--; break; case L: ParenthesisBalance++; break; } if (ParenthesisBalance) { continue; } if (checker.find(Pol.at(j)) != wstring::npos) { opers.insert(opers.begin() + i + 1, wstring(1, Pol.at(j))); strings.insert( strings.begin() + i + 1, Pol.substr(j + 1, Pol.size() - j) ); Pol.erase(j); strings[i] = Pol; continue; } bool activate{ Pol.at(j) == L }; if (j > 0) { activate = activate and Pol.at(j - 1) == L; } if (activate) { if (!isdigit(Pol.at(j + 1))) { errorcode = L; return Fraction<ReturnedFractionType>(); } strings.insert(strings.begin() + i + 1, L); opers.insert( opers.begin() + i + 1, Pol.substr(j, Pol.size() - j - 1) ); Pol.erase(j); strings[i] = Pol; } } } for (ptrdiff_t i = strings.size() - 1; i >= 0; --i) { if (strings[i].empty()) { strings.erase(strings.begin() + i); opers[i] += opers[i + 1]; opers.erase(opers.begin() + (i + 1)); } } Tops += strings; Opers += opers; Bottoms += tensor<wstring>(strings.size(), L); } tensor<Fraction<big>> FractionList{ GetManyFractions(Tops, Bottoms, errorcode) }; if (!errorcode.empty()) { return Fraction<ReturnedFractionType>(); } IsChar(Variables.size(), true); if (datas > Variables.size()) { datas(Variables.size()); } else { for (size_t i = datas.size(); i < Variables.size(); ++i) { datas << Variables.at(i); } } wstring Var; tensor<size_t> locations(datas.size(), -1); for (size_t i = 0; i < datas; ++i) { if (IsChar[i]) { if (Var.find(datas[i]) == wstring::npos) { Var += datas[i]; } } } for (size_t i = 0; i < Var.size(); ++i) { for (size_t j = 0; j < datas; ++j) { if (IsChar[j] and datas[j] == Var.at(i)) { locations[j] = i; } } } for (auto& Fract : FractionList) { for (size_t i = 0; i < datas; ++i) { if (!IsChar[i]) { Fract = Fract(big(datas[i]), i); } } } Variables = Var; auto _Size{ FractionList.size() * 2 }; for (size_t i = 0; i < _Size; ++i) { auto& pol = i % 2 ? FractionList[i / 2].den : FractionList[i / 2].num; for (auto& fact : pol) { for (auto& mono : fact) { tensor<int> NewExp(Var.size(), 0); for (size_t j = 0; j < datas; ++j) { if (IsChar[j]) { NewExp[locations[j]] += mono.exp[j]; } } mono.exp = NewExp; } fact = PolynomialSum(fact); } monomial<big> head{ 1, tensor<int>(Variables.size(), 0) }; for (ptrdiff_t j = pol.size() - 1; j >= 0; --j) { if (pol[j] == 1) { head.coefficient *= pol[j][0].coefficient; for (size_t k = 0; k < Variables.size(); ++k) { head.exp[k] += pol[j][0].exp[k]; } pol.erase(pol.begin() + j); } } pol >> factor<big>{ head }; } if (Variables.empty()) { Variables = L; for (auto& Fract : FractionList) { for (auto& pol : Fract.num) { for (auto& mono : pol) { mono.exp(1, 0); } } } for (auto& Fract : FractionList) { for (auto& pol : Fract.den) { for (auto& mono : pol) { mono.exp(1, 0); } } } } return ObjectOperations(errorcode, FractionList, Opers); } }; tensor_t PrimeNumbers; _STD map<int, wstring> CalculatedData; struct Console { wstring Text; WORD Attribute{ 15 }; void log() const { SetConsoleTextAttribute(hConsole, Attribute); wcout << Text; SetConsoleTextAttribute(hConsole, 15)(); } bool operator!=(const Console& other) const { return Text != other.Text and Attribute != other.Attribute; } friend wostream& operator<<(wostream& wos, const Console& T) { SetConsoleTextAttribute(hConsole, T.Attribute); wos << T.Text; SetConsoleTextAttribute(hConsole, 15)(); return wos; } }; class ConsoleStream : public tensor<Console> { public: ConsoleStream() {} ConsoleStream(initializer_list<Console> init) { for (const auto& item : init) { (*this) << item; } } ConsoleStream operator+(ConsoleStream other) const { auto This{ *this }; for (const auto& item : other) { This << item; } return This; } inline void output() const { for (int i = 0; i < this->size(); ++i) { wcout << (*this)[i]; } } inline void log() { this->output(); this->clear(); } friend wostream& operator<<(wostream& wos, const ConsoleStream& T) { for (int i = 0; i < T.size(); ++i) { wos << T[i]; } return wos; } }; ConsoleStream ConsoleText; static void SendCtrlPlusMinus(bool plus); static ptrdiff_t intpow(ptrdiff_t base, int exp); template<typename _Ty = long double> class Matrix : public tensor<tensor<_Ty>> { public: Matrix() {} using tensor<tensor<_Ty>>::tensor; int output( COORD SelectedElement = { -1, -1 }, int& extension = __NULL__, WORD Attribute = 15 ) const { GetConsoleScreenBufferInfo(hConsole, &csbi)(); auto size{ this->size() }; auto begin{ csbi.dwCursorPosition }; wcout << wstring(4 * size + 1, L); GetConsoleScreenBufferInfo(hConsole, &csbi)(); if (csbi.dwCursorPosition.Y >= begin.Y) { begin.Y -= 4 * size + 1 - csbi.dwCursorPosition.Y + begin.Y; } SetConsoleCursorPosition(hConsole, begin); csbi.dwCursorPosition = begin; tensor<tensor<wstring>> StrMatrix(size), StrDenominators(size); for (size_t i = 0; i < size; ++i) { for (size_t j = 0; j < (*this)[i]; ++j) { auto element{ (*this)[j][i] }; if (SelectedElement.Y >= 0 or integer(element)) { StrDenominators[i] << L; StrMatrix[i] << to_wstring((int)element); continue; } int I{ -1 }; for (int k = 2; k < 1'000; ++k) { if (integer(k * element)) { I = k; break; } } if (I == -1) { StrMatrix[i] << to_wstring(element); StrDenominators[i] << L; } else { StrMatrix[i] << to_wstring(int(element * I)); StrDenominators[i] << to_wstring(I); } } } int sum{}; for (size_t i = 0; i < size; ++i) { auto column{ StrMatrix[i] }; auto denom{ StrDenominators[i] }; int maxlenght{ 3 }; for (auto& num : column) { if (num.size() > maxlenght) { maxlenght = num.size(); } } for (auto& den : denom) { if (den.size() > maxlenght) { maxlenght = den.size(); } } for (auto& num : column) { if (num.size() < maxlenght) { int TotalLenght = maxlenght - num.size(); num = wstring(TotalLenght / 2, L) + num + wstring(TotalLenght - TotalLenght / 2, L); } } for (auto& den : denom) { if (den.size() < maxlenght) { int TotalLenght = maxlenght - den.size(); den = wstring(TotalLenght / 2, L) + den + wstring(TotalLenght - TotalLenght / 2, L); } } StrMatrix[i] = column; StrDenominators[i] = denom; sum += maxlenght; } sum += size * 2; tensor<bool> HaveTheyFractions(size, false); for (size_t i = 0; i < size; ++i) { for (size_t j = 0; j < size; ++j) { if (StrDenominators[j][i].at( (StrDenominators[j][i].size() - 1) / 2) != L ) { HaveTheyFractions[i] = true; break; } } } int row{}; size_t index{}; int line{}; if (extension) { extension = sum + 3; } for (size_t i = 0; index <= 2 * size; ++i) { if (index == 2 * size) { line = i; } if (index == 0 or index == 2 * size) { wcout << L << wstring(sum + 1, L) << L; csbi.dwCursorPosition.Y++; SetConsoleCursorPosition( hConsole, { begin.X, csbi.dwCursorPosition.Y } ); index++; continue; } wcout << L; if (index % 2 == 0) { wcout << wstring(sum, L) << L; index++; csbi.dwCursorPosition.Y++; SetConsoleCursorPosition( hConsole, { begin.X, csbi.dwCursorPosition.Y } ); continue; } if (HaveTheyFractions[(index - 1) / 2]) { row++; } if (row == 4) { row = 1; } for (size_t j = 0; j < size; ++j) { if (j == SelectedElement.X and (index - 1) / 2 == SelectedElement.Y) { SetConsoleTextAttribute(hConsole, 12); } auto TempDenominator{ StrDenominators[j][(index - 1) / 2] }; if ( !HaveTheyFractions[(index - 1) / 2] or (row == 2 and TempDenominator.at( (TempDenominator.size() - 1) / 2) == L) ) { wcout << StrMatrix[j][(index - 1) / 2]; if (j == SelectedElement.X and (index - 1) / 2 == SelectedElement.Y) { SetConsoleTextAttribute(hConsole, 4); wcout << L; } else { wcout << L; } } else switch (row) { case 1: if ( TempDenominator.at((TempDenominator.size() - 1) / 2) == L) { wcout << wstring( StrMatrix[j][(index - 1) / 2].size() + 1, L ); } else { wcout << StrMatrix[j][(index - 1) / 2] << L; } break; case 2: wcout << wstring(StrMatrix[j][(index - 1) / 2].size(), L); wcout << L; break; case 3: if (TempDenominator.at( (TempDenominator.size() - 1) / 2) == L) { wcout << wstring( StrMatrix[j][(index - 1) / 2].size() + 1, L ); } else { wcout << StrDenominators[j][(index - 1) / 2] << L; } break; } SetConsoleTextAttribute(hConsole, Attribute); wcout << L; } if (row == 0 or row == 3) { index++; } wcout << L; csbi.dwCursorPosition.Y++; SetConsoleCursorPosition( hConsole, { begin.X, csbi.dwCursorPosition.Y } ); } if (SelectedElement.Y == -2) { line = max(line, (int)SelectedElement.X); begin.Y += line + 1; } if (SelectedElement.X == -1) begin.X += sum + 3; SetConsoleCursorPosition(hConsole, begin); __NULL__ = 0; return line; } bool input(wstring& errcode) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); const int EscapeCode{ -32 }; GetConsoleScreenBufferInfo(hConsole, &csbi)(); auto start{ csbi.dwCursorPosition }; wcout << wstring(29, L); GetConsoleScreenBufferInfo(hConsole, &csbi)(); if (csbi.dwCursorPosition.Y >= start.Y) { start.Y -= 29 - csbi.dwCursorPosition.Y + start.Y; } SetConsoleCursorPosition(hConsole, start); csbi.dwCursorPosition = start; GetConsoleScreenBufferInfo(hConsole, &csbi)(); COORD begin{ csbi.dwCursorPosition }; size_t size_s{ 2 }; tensor<Matrix<_Ty>> Displayed; const wstring operatorsAllowed{ L }; tensor<wstring> operators{ L }; wstring ToConvalidate; bool Continue{ true }, keep{ false }, skip{ false }; for (;;) { if (_kbhit() or (GetAsyncKeyState(VK_CONTROL) & 0x8000 and GetAsyncKeyState(VK_MENU) & 0x8000)) { skip = false; tensor<long double> unit(size_s, 0); int sizemin = size_s, lenght{ 1 }, depth = 2 * size_s + 1; char c = _kbhit() ? tolower(_getch()) : L; switch (c) { case L: this->clear(); return true; case L: goto end; case L: operators.last().empty() ? (void)operators-- : operators.last().pop_back(); if (!ToConvalidate.empty()) { if (Last(ToConvalidate) == L) { Displayed--; } ToConvalidate.pop_back(); } if (operators.empty()) { operators = { {} }; } goto output; } if (c == 0 or c == EscapeCode) { skip = true; continue; } if (operatorsAllowed.find(c) == wstring::npos) { continue; } if (c != L) { operators.last() += c; ToConvalidate += c; goto output; } input: sizemin = 2; unit(size_s, 0); for (const auto& matrix : Displayed) { int localmin{ 1 }; for (ptrdiff_t i = size_s - 1; i >= 0; --i) { if (matrix[i] != unit) { localmin = i; break; } } if (localmin == size_s) { sizemin = size_s; break; } for (ptrdiff_t i = size_s - 1; i >= 0; --i) { for (size_t j = 0; j < size_s; ++j) { if (matrix[j][i] != 0) { if (localmin < i) { localmin = i; } break; } } } if (localmin > sizemin) { sizemin = localmin; } if (sizemin == size_s) { break; } } while (GetAsyncKeyState(VK_CONTROL) & 0x8000 and GetAsyncKeyState(VK_MENU) & 0x8000); if (!keep) { Displayed << Matrix<_Ty>(size_s, tensor<long double>(size_s, 0)); } { auto& inputer{ Displayed.last() }; Continue = true; keep = false; R; if (inputer.size() < 2) { inputer(2); } Matrix<bool> Signs(inputer.size()); for (auto& row : inputer) { row(inputer.size(), 0); } for (auto& row : Signs) { row(Signs.size(), false); } for (size_t i = 0; i < inputer; ++i) { for (size_t j = 0; j < inputer[i]; ++j) { Signs[i][j] = inputer[i][j] < 0; } } if (inputer[0][0] == 0) { inputer[0][0] = 1; } bool arrow{ false }; depth = inputer.output({ 0, 0 }, lenght); COORD IndexAccesser{}; wstring MatrixAtIndex; for (;;) { char C; if (GetAsyncKeyState(VK_CONTROL) & 0x8000 and GetAsyncKeyState(VK_MENU)) { goto inputend; } if (_kbhit()) { C = tolower(_getch()); if (C == EscapeCode) { arrow = true; continue; } if (C <= 0) { continue; } if (arrow) { switch (C) { case L: C = L; break; case L: C = L; break; case L: C = L; break; case L: C = L; break; } arrow = false; } size_t size; switch (C) { case L: IndexAccesser.Y = (IndexAccesser.Y - 1) % inputer.size(); break; case L: IndexAccesser.Y = (IndexAccesser.Y + 1) % inputer.size(); break; case L: IndexAccesser.X = (IndexAccesser.X - 1) % inputer.size(); break; case L: IndexAccesser.X = (IndexAccesser.X + 1) % inputer.size(); break; } MatrixAtIndex = to_wstring( (int)inputer[IndexAccesser.Y][IndexAccesser.X] ); switch (C) { case L: { random_device rng; mt19937 gen(rng()); uniform_int_distribution<> dis(-100, 100); for (size_t i = 0; i < inputer; ++i) { for (size_t j = 0; j < inputer[i]; ++j) { if (inputer[i][j] == 0) { int rand{ dis(gen) }; Signs[i][j] = rand < 0; inputer[i][j] = rand; } } } } break; case L: inputer.last() = inputer[inputer.size() - 2]; MatrixAtIndex = to_wstring( (int)inputer[IndexAccesser.Y][IndexAccesser.X] ); break; case L: if (MatrixAtIndex == L and Signs[IndexAccesser.Y][IndexAccesser.X]) { Signs[IndexAccesser.Y][IndexAccesser.X] = false; break; } if (MatrixAtIndex.size() == 1) { MatrixAtIndex = L; break; } MatrixAtIndex.pop_back(); break; case 127: if (GetAsyncKeyState(VK_MENU) & 0x8000) { for (size_t i = 0; i < inputer; ++i) { for (size_t j = 0; j < inputer[i]; ++j) { inputer[i][j] = 0; Signs[i][j] = false; } } break; } MatrixAtIndex = L; Signs[IndexAccesser.Y][IndexAccesser.X] = false; break; case L: if (inputer > 6) { break; } size = inputer.size() + 1; Signs(size); inputer(size); for (size_t i = 0; i < size; ++i) { inputer[i](size, 0); Signs[i](size, false); } keep = true; goto inputend; case L: if (inputer.size() <= max(2, sizemin)) { break; } Signs--; inputer--; for (auto& row : Signs) { row--; } for (auto& row : inputer) { row--; } IndexAccesser.X %= inputer.size(); IndexAccesser.Y %= inputer.size(); keep = true; goto inputend; case L: Continue = false; inputend: GetConsoleScreenBufferInfo(hConsole, &csbi)(); csbi.dwCursorPosition.Y += 2 * inputer.size() + 1; SetConsoleCursorPosition( hConsole, csbi.dwCursorPosition ); SetConsoleCursorInfo(hConsole, &cursor); goto exit; case L: SetConsoleCursorInfo(hConsole, &cursor); this->clear(); return true; default: if (isdigit(C) or (C == L and MatrixAtIndex == L) and !Signs[IndexAccesser.Y][IndexAccesser.X]) { if (Signs[IndexAccesser.Y][IndexAccesser.X] and MatrixAtIndex.at(0) != L) { MatrixAtIndex = L + MatrixAtIndex; } if (C == L) { Signs[IndexAccesser.Y][IndexAccesser.X] = true; } if (MatrixAtIndex.size() > 4 + (MatrixAtIndex.at(0) == L)) { break; } if (MatrixAtIndex == L) { MatrixAtIndex.clear(); } MatrixAtIndex += C; } } inputer[IndexAccesser.Y][IndexAccesser.X] = MatrixAtIndex == L ? 0 : stoi(MatrixAtIndex); GetConsoleScreenBufferInfo(hConsole, &csbi)(); auto CursorPos{ csbi.dwCursorPosition }; ClearArea( { (short)(CursorPos.X + 30), (short)(CursorPos.Y + 8) }, { 30, 8 } ); depth = inputer.output(IndexAccesser, lenght); SetConsoleCursorInfo(hConsole, &cursor); } if (!RunMonitor) { GetConsoleScreenBufferInfo(hConsole, &csbi)(); csbi.dwCursorPosition.Y += 2 * inputer.size() + 1; SetConsoleCursorPosition(hConsole, csbi.dwCursorPosition); SetConsoleCursorInfo(hConsole, &cursor); *this = Matrix<_Ty>( inputer.size(), tensor<long double>(inputer.size(), 0) ); return true; } } } exit: if (Displayed.last() == Matrix<_Ty>(size_s, tensor<long double>(size_s, 0))) { *this = Matrix<_Ty>(size_s, tensor<long double>(size_s, 0)); return true; } while (GetAsyncKeyState(VK_CONTROL) & 0x8000 and GetAsyncKeyState(VK_MENU) & 0x8000); if (!keep) { operators << L; ToConvalidate += L; } if (keep) { for (auto& matrix : Displayed) { size_s = Displayed.last().size(); matrix(size_s); for (auto& row : matrix) { row(size_s, 0); } } } if (!Continue) { end: GetConsoleScreenBufferInfo(hConsole, &csbi)(); auto D = Continue ? depth + 1 : 0; SetConsoleCursorPosition( hConsole, { 0, short(csbi.dwCursorPosition.Y + D) } ); break; } output: R; SetConsoleCursorPosition(hConsole, { 0, begin.Y }); short extension = csbi.dwSize.X - 1; short limit = csbi.dwCursorPosition.Y + depth + 1; for (short i = begin.Y; i <= limit; ++i) { wcout << wstring(extension, L) << L; } SetConsoleCursorInfo(hConsole, &cursor); SetConsoleCursorPosition(hConsole, begin); GetConsoleScreenBufferInfo(hConsole, &csbi)(); SetConsoleCursorPosition( hConsole, { short(csbi.dwCursorPosition.X + 1), short(csbi.dwCursorPosition.Y + depth / 2) } ); wcout << operators[0]; GetConsoleScreenBufferInfo(hConsole, &csbi)(); SetConsoleCursorPosition( hConsole, { short(csbi.dwCursorPosition.X + 1), begin.Y } ); for (size_t i = 0; i < Displayed.size() - keep; ++i) { GetConsoleScreenBufferInfo(hConsole, &csbi)(); if (csbi.dwSize.X <= csbi.dwCursorPosition.X + 11 * size_s + 1) { Displayed.erase(i); if (i + 1 < operators) { operators.erase(i + 1); } int sum{}; for (const auto& op : operators) { sum += op.size(); } sum += Displayed.size(); if (ToConvalidate.size() > sum) { ToConvalidate.erase(sum); } break; } Displayed[i].output(); GetConsoleScreenBufferInfo(hConsole, &csbi)(); SetConsoleCursorPosition( hConsole, { short(csbi.dwCursorPosition.X + 1), short(csbi.dwCursorPosition.Y + depth / 2) } ); if (i + 1 < operators) { if (csbi.dwCursorPosition.X + operators[i + 1].size() >= csbi.dwSize.X) { operators.erase(i + 1); break; } wcout << operators[i + 1]; } GetConsoleScreenBufferInfo(hConsole, &csbi)(); SetConsoleCursorPosition( hConsole, { short(csbi.dwCursorPosition.X + 1), short(csbi.dwCursorPosition.Y - depth / 2) } ); } if (keep) { goto input; } } } if (Displayed.empty()) { GetConsoleScreenBufferInfo(hConsole, &csbi)(); csbi.dwCursorPosition.Y += 2 * size_s + 1; SetConsoleCursorPosition(hConsole, csbi.dwCursorPosition); SetConsoleCursorInfo(hConsole, &cursor); *this = Matrix<_Ty>(size_s, tensor<long double>(size_s, 0)); return true; } *this = ObjectOperations(errcode, Displayed, operators, ToConvalidate); return *this != Matrix<_Ty>{}; } void DisplayWith(const Matrix other) const { GetConsoleScreenBufferInfo(hConsole, &csbi)(); if (csbi.dwSize.X <= 22 * this->size() + 2) { this->output({ 0, -2 }); other.output({ 0, -2 }); wcout << L; return; } other.output({ (short)this->output(), -2 }); wcout << L; } void DisplayWith(const Matrix A, const Matrix B) const { GetConsoleScreenBufferInfo(hConsole, &csbi)(); if (csbi.dwSize.X <= 33 * this->size() + 3) { this->output({ 0, -2 }); A.output({ 0, -2 }); B.output({ 0, -2 }); wcout << L; return; } int line{ this->output() }; line = max(line, A.output()); B.output({ (short)line, -2 }); wcout << L; } Matrix operator+(const Matrix other) const { Matrix result(*this); for (size_t i = 0; i < result; ++i) { for (size_t j = 0; j < other; ++j) { result[i][j] += other[i][j]; } } return result; } Matrix operator+=(const Matrix other) { *this = *this + other; return *this; } Matrix operator-(const Matrix other) const { Matrix result(*this); for (size_t i = 0; i < result; ++i) { for (size_t j = 0; j < other; ++j) { result[i][j] -= other[i][j]; } } return result; } Matrix operator-=(const Matrix other) { *this = *this - other; return *this; } tensor<_Ty> operator*(const tensor<_Ty> vector) const { if (vector.size() != this->size()) { throw out_of_range(); } tensor<_Ty> product(vector.size()); for (size_t i = 0; i < product; ++i) { _Ty DotProduct{}; for (size_t j = 0; j < product; ++j) { DotProduct += (*this)[i][j] * vector[j]; } product[i] = DotProduct; } return product; } Matrix operator*(const _Ty scalar) const { auto This{ *this }; for (auto& row : This) { for (auto& el : row) { el *= scalar; } } return This; } Matrix& operator*=(const _Ty scalar) { *this = *this * scalar; return *this; } Matrix operator*(const Matrix other) const { if (*this % other) { return {}; } size_t size{ this->size() }; Matrix<_Ty> res(size); for (size_t i = 0; i < size; ++i) { for (size_t j = 0; j < size; ++j) { double scalar_prod{}; for (size_t k = 0; k < size; ++k) { scalar_prod += (*this)[i][k] * other[k][j]; } res[i] << scalar_prod; } } return res; } Matrix& operator*=(const Matrix other) { *this = *this * other; return *this; } template<typename T = _Ty> T det() { if constexpr (is_same_v<T, factor<>>) { factor<> det; int s = this->size(); switch (s) { case 1: return (*this)[0][0]; case 2: return (*this)[0][0] * (*this)[1][1] - (*this)[0][1] * (*this)[1][0]; } for (size_t i = 0; i < s; ++i) { Matrix<factor<>> MX(s - 1); for (size_t I = 0; I < s - 1; ++I) { for (size_t J = 0; J < s; ++J) { if (i == J) { continue; } MX[I] << (*this)[I + 1][J]; } } auto MiddleDet{ MX.det() }; if (MiddleDet != 0) { auto adder{ (*this)[0][i] * MiddleDet }; for (auto& mon : adder) { mon.coefficient *= -1; } det -= adder.neg(); } } return det; } if constexpr (is_integral_v<T> or is_floating_point_v<T>) { T det{}; size_t s{ this->size() }; switch (s) { case 1: return (*this)[0][0]; case 2: return (*this)[0][0] * (*this)[1][1] - (*this)[0][1] * (*this)[1][0]; } for (size_t i = 0; i < s; ++i) { Matrix MX(s - 1); for (size_t I = 0; I < s - 1; ++I) { for (size_t J = 0; J < s; ++J) { if (i == J) { continue; } MX[I] << (*this)[I + 1][J]; } } det += intpow(-1, i) * (*this)[0][i] * MX.det(); } return det; } return T(); } Matrix invert(_Ty det = 0) { Matrix<_Ty> result(this->size()); if (det == 0) { det = this->det(); } if (det == _Ty()) { result = *this; result[0][0] = nan(); return result; } for (size_t i = 0; i < this->size(); ++i) { for (size_t j = 0; j < this->size(); ++j) { auto second{ *this }; second.erase(second.begin() + i); for (size_t k = 0; k < second; ++k) { second[k].erase(second[k].begin() + j); } result[i] << ((i + j) % 2 == 0 ? 1 : -1) * second.det() / det; } } return result; } tensor<double> EigenValues() { size_t s{ this->size() }; Matrix<factor<>> PolynomialMatrix(s, tensor<factor<>>(s)); for (size_t i = 0; i < s; ++i) { for (size_t j = 0; j < s; ++j) { PolynomialMatrix[i][j] << monomial<>{ (long double)(*this)[i][j], { 0 } }; } } for (size_t i = 0; i < s; ++i) { PolynomialMatrix[i][i] >> monomial<>{ -1, { 1 } }; } tensor<double> eigenvalues; wchar_t save_char{ charVariable }; wstring save_wstring{ Variables }; charVariable = L; Variables = L; auto EigenStrings{ EquationSolver(PolynomialMatrix.det()) }; for (auto str : EigenStrings) { str.erase(0, str.find(L) + 1); if (str.find(L) == wstring::npos) { eigenvalues << stod(str); } } for (size_t i = 0; i < eigenvalues; ++i) { for (size_t j = i + 1; j < eigenvalues; ++j) { if (eigenvalues[i] < eigenvalues[j]) { swap(eigenvalues[i], eigenvalues[j]); } } } charVariable = save_char; Variables = save_wstring; return eigenvalues; } Matrix EigenVectors(tensor<double> EigenV = {}) { size_t size{ this->size() }; if (EigenV.empty()) { EigenV = this->EigenValues(); } if (EigenV.size() != size) { return {}; } tensor<double> result; Matrix<_Ty> eigenvectors(size); for (size_t i = 0; i < size; ++i) { auto NewMx{ *this }; for (size_t j = 0; j < size; ++j) { NewMx[j][j] -= EigenV[i]; } for (size_t j = 0; j < size - 1; ++j) { result << -NewMx[j].last(); } NewMx--; for (size_t j = 0; j < size - 1; ++j) { NewMx[j]--; } auto Det{ NewMx.det() }; for (size_t j = 0; j < size - 1; ++j) { auto NewMatrix{ NewMx }; for (size_t k = 0; k < size - 1; ++k) { NewMatrix[k][k] = result[k]; } eigenvectors[i] << NewMatrix.det() / Det; } eigenvectors[i] << 1; double norm{}; for (size_t j = 0; j < size; ++j) { norm += eigenvectors[i][j] * eigenvectors[i][j]; } norm = sqrt(norm); if (isnan(norm)) { return {}; } for (size_t j = 0; j < size; ++j) { eigenvectors[i][j] /= norm; } } return eigenvectors; } }; template<typename T> T EmptyProduct(T shape) { if constexpr (is_same_v<T, Fraction<>>) { return Fraction<>{ polynomial<>{ { { 1, tensor<int>(Variables.size(), 0) } } }, polynomial<>{ { { 1, tensor<int>(Variables.size(), 0) } } } }; } if constexpr (is_same_v<T, Fraction<big>>) { return Fraction<big>{ polynomial<big>{ { { 1, tensor<int>(Variables.size(), 0) } } }, polynomial<big>{ { { 1, tensor<int>(Variables.size(), 0) } } } }; } if constexpr (is_same_v<T, Matrix<>>) { auto Result{ shape }; for (size_t i = 0; i < shape; ++i) { for (size_t j = 0; j < shape; ++j) { shape[i][j] = 0; } } for (size_t i = 0; i < shape; ++i) { shape[i][i] = 1; } return Result; } } HDC GHDC; static void DrawLine(int firstX, int firstY, int secondX, int secondY, HPEN Hpen); static void DrawLineToBuffer( HDC hdcmem, HBITMAP hbmem, int firstX, int firstY, int secondX, int secondY, HPEN Hpen ); static void ProjectPoint(tensor<long double> point, int& pointX, int& pointY); static void ProjectAndDrawLine (tensor<long double> start, tensor<long double> end, HPEN Hpen); class Point__ { private: int ScreenX, ScreenY; tensor<long double> Normal; public: long double x, y, z; Point__() : x(0), y(0), z(0), ScreenX(-1), ScreenY(-1), Normal(3) {} Point__(long double _x, long double _y, long double _z) : x(_x), y(_y), z(_z), ScreenX(-1), ScreenY(-1), Normal(3) {} Point__(factor<> funct, long double _x, long double _y) : x(_x), y(_y), z(funct({ x, y })), ScreenX(-1), ScreenY(-1), Normal(3) {} Point__(Fraction<> funct, long double _x, long double _y) : x(_x), y(_y), z(funct({ x, y })), ScreenX(-1), ScreenY(-1), Normal(3) {} int GetScreenX() { if (ScreenX == -1) { ProjectPoint({ x, y, z }, ScreenX, ScreenY); } return ScreenX; } int GetScreenY() { if (ScreenY == -1) { ProjectPoint({ x, y, z }, ScreenX, ScreenY); } return ScreenY; } tensor<long double> GetNormalVector() const { return Normal; } bool Void() const { return x == 0 and y == 0 and z == 0 and ScreenX == -1 and ScreenY == -1 and Normal == tensor<long double>(3); } Point__& operator=(const Point__& other) { if (this != &other) { ScreenX = other.ScreenX; ScreenY = other.ScreenY; Normal = other.Normal; x = other.x; y = other.y; z = other.z; } return *this; } tensor<long double> SetNormalVector(Fraction<> dfx, Fraction<> dfy) { Normal(3); Normal[0] = dfx({ x, y }); Normal[1] = dfy({ x, y }); Normal[2] = 1; long double norm{ hypot(Normal[0], Normal[1], Normal[2]) }; for (auto& component : Normal) { component /= norm; } return Normal; } void Display(int width, COLORREF color) { if (ScreenX == -1 or ScreenY == -1) { ProjectPoint({ x, y, z }, ScreenX, ScreenY); } nt w2{ width / 2 }; for (int i = -w2; i < width - w2; ++i) { for (int j = -w2; j < width - w2; ++j) { SetPixel(GHDC, ScreenX, ScreenY, color); } } } void StdDisplay (Fraction<> fx, Fraction<> dfx, Fraction<> dfy, tensor<long double> light) { Point__ P{ fx, x, y }; auto normal{ P.SetNormalVector(dfx, dfy) }; auto dot{ normal[0] * light[0] + normal[1] * light[1] + normal[2] * light[2] }; int RgbValue = clamp(int(255 * dot), 0, 255); P.Display(2, RGB(RgbValue, RgbValue, RgbValue)); } }; static void DrawLine(Point__ P1, Point__ P2, HPEN hpen); static void DrawLineToBuffer (HDC hdcmem, HBITMAP hbmem, Point__ P1, Point__ P2, HPEN Hpen); template<typename T> bool isnan(Fraction<T> object) { return false; } template<typename T> bool isnan(Matrix<T> object) { return isnan(object[0][0]); } class NumberData { public: ptrdiff_t number{}; wstring code; int degree{}; wstring expression; tensor<ptrdiff_t> sequence; divisor div; digitRatio digit; strong_ordering operator<=>(const NumberData& other) const { return number <=> other.number; } NumberData() = default; NumberData( ptrdiff_t num, const wstring& c, int deg, const wstring& expr, const tensor<ptrdiff_t>& seq, const divisor& d, const digitRatio& dr ) : number(num), code(c), degree(deg), expression(expr), sequence(seq), div(d), digit(dr) {} void printf() { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); if (PRINTN) { wcout << L << number << L; SetConsoleTextAttribute(hConsole, 2); wcout << L << hex << uppercase; wcout << number << L << dec << nouppercase; if (number - 1 < PrimeNumbers.list_primes) { wcout << L << number << L; wcout << PrimeNumbers.list_primes[number - 1] << L; } } else if (number >= 10) { if ( digit.digitSumRatioNum == 0 and digit.digitProductRatioNum == 0 ) { return; } wcout << L << number << L; SetConsoleTextAttribute(hConsole, 2); wcout << L << hex << uppercase; wcout << number << L << dec << nouppercase; if (number - 1 < PrimeNumbers.list_primes) { wcout << L << number << L; wcout << PrimeNumbers.list_primes[number - 1] << L; } SetConsoleTextAttribute(hConsole, 13); if (digit.digitSumRatioNum != 0) { wcout << L; wcout << L << digit.digitSumRatioNum; wcout << L << digit.digitSumRatioDen; wcout << L; } if (digit.digitProductRatioNum != 0) { wcout << L; if (digit.digitProductRatioDen != 1) { wcout << L; } ut << digit.digitProductRatioNum; if (digit.digitProductRatioDen != 1) { wcout << L; wcout << digit.digitProductRatioDen; wcout << L; } wcout << L; } } if (!code.empty()) { SetConsoleTextAttribute(hConsole, 12); wcout << L << code << L; } if (degree != 0) { SetConsoleTextAttribute(hConsole, 4); wcout << L << degree << L; SetConsoleTextAttribute(hConsole, 3); wcout << L; for (size_t i = 0; i < sequence.size() - 1; ++i) { wcout << sequence[i] << L; } wcout << sequence.last() << L; } if (!expression.empty()) { if (PrimeNumbers.is_prime[number]) { SetConsoleTextAttribute(hConsole, 240); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; } else { SetConsoleTextAttribute(hConsole, 11); wcout << L; wcout << expression << L; if (div.DivNumber != 1) { SetConsoleTextAttribute(hConsole, 8); wcout << L; wcout << div.DivNumber << L; wcout << L; wcout << div.DivSum << L; wcout << L; if (div.DivProduct != 1) { wcout << div.DivProduct << L; } else { wcout << div.Div_pr << L; } } } } SetConsoleTextAttribute(hConsole, 15)(); } }; tensor<wstring> Numbers, Polynomials, Expressions; tensor<tensor<wstring>> GlobalNumerators, GlobalDenominators, GlobalOperators; tensor<tensor<short>> ActionsList; static wstring Handler(wstring test); static size_t Factorial(size_t n); static size_t BinomialCoeff(size_t n, size_t k); static ptrdiff_t Gcd(ptrdiff_t A, ptrdiff_t B); template<typename T> static int Gcd(tensor<T> terms); static void ReassigneEnum(switchcase& option); static void WriteFraction (wstring Num, wstring Den, wstring& command, COORD START = { -1, -1 }); static void PrintPFrame (double deg, int sides, double radius, COORD WinCenter); static void DrawFrame (int arc, double __i, int centerX, int centerY, double DIM); static void DrawCircleSquare(COORD CircleCenter); static void CS_CenterPrinter(); static void CS_CornerPrinter(); static void ProgressBar(long double ratio, double barWidth); static long double WaitingScreen(auto begin, auto end); static wstring GetLine(tensor<wstring>& sugg, bool ShowSuggestions = true); static wstring GetUserNum (wstring txt, ptrdiff_t low, ptrdiff_t high, bool ShowSuggestions); static void SetDebug(wstring message, switchcase& opt, bool& Return, ptrdiff_t& LowerBound, ptrdiff_t& UpperBound, ptrdiff_t& datalenght ); static void MonitorConsoleSize(COORD min, atomic_bool& runMonitor); static void UserInputThread(); static void DrawAxis(HDC hdcmem, HBITMAP hbmem, double pInc, double vInc); static LRESULT CALLBACK WindowProcessor2D( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ); static BOOL CreateGraph(Fraction<> funct = { {}, {} }); static LRESULT CALLBACK WindowProcessor3D( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ); static void Project3DGraph(Fraction<> funct); static bool Prime(ptrdiff_t number); static void PrimeNCalculator(ptrdiff_t max, ptrdiff_t min = 0); static tensor<wstring> Fractioner(wstring polinomial); static tensor<int> DecomposeStrings(wstring Terminal); static wstring Cript(ptrdiff_t input); static wstring FactNumber(ptrdiff_t input); static int ExeStrings(wstring input); static divisor DivisorCalculator(wstring factor); static digitRatio DigitRationalizer(ptrdiff_t inpt); static tensor<int> DivisorCounter(int num); static NumberData ExecuteSimpledeg(ptrdiff_t input); static NumberData ExecuteDegree(ptrdiff_t input); static NumberData ExecuteSimpleFact(ptrdiff_t input); static NumberData ExecuteFactor(ptrdiff_t input); static NumberData ExecuteSimpleDF(ptrdiff_t input); static NumberData ExecuteDigit(ptrdiff_t input); static NumberData ExecuteDegFactor(ptrdiff_t input); static NumberData ExecuteDegDigit(ptrdiff_t input); static NumberData ExecuteFactDigit(ptrdiff_t input); static NumberData ExecuteAll(ptrdiff_t input); static wstring PolynomialSyntax(wstring pol); static wstring PolynomialSyntaxDirector(wstring pol); static wstring UpdateString(wstring& ToEvaluate); static wstring NumberCodeSyntax(wstring ToEvaluate); static ptrdiff_t NumberConverter(size_t root, wstring M); static ptrdiff_t StringConverter(wstring ToEvaluate); static void CodeConverter (wstring ToEvaluate, wstring message, bool ShowErrors, bool NecBoundary); static void LongComputation (wstring ToEvaluate, wstring message, bool ShowErrors, bool NecBoundary); static factor<big> GetMonomials(wstring pol); static polynomial<big> GetMonomialsRedirector(wstring pol); static polynomial<big> GetMonomialsAssister(wstring pol); static tensor<tensor<long double>> FromPolynomialToPos( factor<> vect, int& StartIndex, tensor<int>& CorrectSizes, tensor<int>& VDirectorTerm, tensor<int>& VKnownTerm, tensor<tensor<int>>& VDirectorSeq, tensor<tensor<int>>& VKnownSeq ); static void PolynomialDivide ( FACTOR<> dividend, FACTOR<> divisor, FACTOR<>& quotient, FACTOR<>& rest ); static polynomial<> Total(factor<> vect); static polynomial<> Partial(factor<> vect); static polynomial<> Binomial(factor<> vect); static polynomial<> Trinomial(factor<> vect); static polynomial<> SquareDifference(factor<> vect); static polynomial<> Ruffini(factor<> vect); static polynomial<> CompleteTheSquare(factor<> vect); static polynomial<> TrinomialSquare(factor<> vect); static FACTOR<> Complementary(POLYNOMIAL<> Polynomial, FACTOR<> factor, int exp); static void Simplify(Fraction<>& fr, int& ncoeff, int& dcoeff); static void Approximator(tensor<long double>& Equation, long double& root); static tensor<wstring> EquationSolver(factor<> equation); static tensor<long double> RootExtractor(polynomial<> vect); static tensor<tensor<long double>> SystemSolver(tensor<factor<>> functions); static void FractDisequationMain( polynomial<> Num, polynomial<> Den, tensor<wstring>& Roots, tensor<bool>& ItsFromDenominator, bool& InitSign, bool& Invert ); static ConsoleStream GetAlgebricSolution( tensor<wstring> roots, tensor<bool> ItsFromDenominator, bool InitialSign, bool ExpectedSign, bool CanBeNull = false ); static bool ParamDisequationSetup( polynomial<>& Num, polynomial<>& Den, polynomial<>& Sum, tensor<bool>& FromDenominator, tensor<long double>& AdditionalRoots, factor<>& Parametric, tensor<factor<>>& tops, tensor<factor<>>& bottoms, bool& InitSign, bool& InvertSign ); static void ParamDisequationMain( polynomial<> Un, tensor<factor<>> tops, tensor<factor<>> bottoms, tensor<long double> AdditionalRoots, size_t& Unisize, tensor<tensor<factor<>>>& TableOfMains, tensor<long double>& RootSet, tensor<long double>& RootExamples, tensor<wstring>& vals ); static ConsoleStream GetParametricSolution( wchar_t parameter, size_t Unisize, size_t Vpos, bool InitialSign, bool ExpectedSign, bool CanBeNull, tensor<bool> TermsFromDenominator, polynomial<>& Num, polynomial<>& Den, factor<> Parametric, tensor<factor<>> tops, tensor<factor<>> bottoms, tensor<tensor<factor<>>> TableOfMains, tensor<long double> RootSet, tensor<long double> RootExamples, tensor<wstring> vals ); static ConsoleStream DisequationSolutionPrinter( polynomial<> Num, polynomial<> Den, int behaviour, bool ChangeSign, bool PrintCondition = true ); static void PrintFraction (int NC, int DC, int& LINE, bool WritePlus, Fraction<> fract); static void PrintFractionaryResult ( int NC, int DC, int& lines, Fraction<> Fract, POLYNOMIAL<> NScomp = { {} }, POLYNOMIAL<> DScomp = { {} }, bool HasMoreVariables = true, bool correct = false, tensor<double> roots = {}, tensor<POLYNOMIAL<>> Denominators = {} ); static void CodeToNumber(switchcase& argc); static wstring ExpandNumber( switchcase& argc, big Number = big(), int Base = 0, bool access = true ); static void Repeater( switchcase& argc, wstring message, NumberData CPU(ptrdiff_t input) ); static void Loop( switchcase& argc, wstring message, NumberData CPU(ptrdiff_t input), bool select = false ); static void DecompAndSolve(switchcase& argc); template<typename Type> static polynomial<> DecompPolynomial(switchcase& argc, Type Polynomial); static void DecompMatrices(switchcase& argc); int main() { int ErrorCode{}, ErrMessage; setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); QueryPerformanceFrequency(&ProgramFrequency); Beep(1'000, 50); Beep(1'000, 50); wstring simpledeg{ L }; wstring simplefact{ L }; wstring def_sct{ L }; wstring desimpledeg{ L }; wstring desimplefact{ L }; wstring defact_message{ L }; defact_message += L; wstring deg_message{ L }; wstring fact_message{ L }; fact_message += L; wstring message{ L }; wstring AllMessage{ L }; wstring de_digit{ L }; de_digit += L; wstring deg_digit{ L }; wstring fact_digit{ L }; wstring defact_digit{ L }; wstring vel; switchcase option; bool start{ true }; bool LockPrimeNumbersInput{ false }; ptrdiff_t global{ 1 }; long double ComputationTime{}; size_t Timer{ 6'500'000'000 }; for (;;) { if (!LockPrimeNumbersInput) { Start: system(); SetConsoleTitle(L); SetConsoleTextAttribute(hConsole, 2); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 10); wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 2); wcout << L; SetConsoleTextAttribute(hConsole, 9); wcout << L; wstring Timer_t{ to_wstring(Timer) }; for (ptrdiff_t i = Timer_t.size() - 3; i > 0; i -= 3) Timer_t.insert(Timer_t.begin() + i, L); wcout << L << Timer_t << L; wstring G{ GetUserNum(L, 0, GLOBAL_CAP, false) }; if (G == L) { ErrorCode = 3; goto End; } if (G.empty()) global = 0; else if (!isdigit(G.at(0))) global = 0; else global = stoull(G); if (global < 10'000'000) { if (!start and global == 0) LockPrimeNumbersInput = true; global = start ? 10'000'000 : 0; } SetConsoleTextAttribute(hConsole, 15)(); auto OldGlobalMax{ GlobalMax }; if (global != 0) { LARGE_INTEGER begin; QueryPerformanceCounter(&(begin)); GlobalMax = global; R; PrimeNCalculator(GlobalMax + 1'000, OldGlobalMax); DECLARE_TIME_POINT(end); if (GlobalMax / (OldGlobalMax + 1) > 10) ComputationTime = WaitingScreen(begin, end); else WaitingScreen(begin, end); SetConsoleCursorInfo(hConsole, &cursor); start = false; } if (GlobalMax > 9'000 and global > 1 and GlobalMax / (OldGlobalMax + 1) > 10) { ComputationTime /= 1'000'000; Timer = (GlobalMax + 1'000) * 60'000 / ComputationTime; } } system(); SetConsoleTitle(L); Beep(750, 300); wcout << L; SetConsoleTextAttribute(hConsole, 4); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 9); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 11); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 14); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 6); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; vel = GetLine(Numbers); if (vel.empty()) vel = L; option = ConvertWStringToEnum(vel); ssigne: if (vel.size() == 1) { switch (vel.at(0)) { case L: LockPrimeNumbersInput = true; wcout << L; goto option_choice; case L: LockPrimeNumbersInput = false; wcout << L; goto option_choice; case L: goto Start; case L: ErrorCode = -1073741510; goto End; default: vel += L; } } option = ConvertWStringToEnum(vel); if (option == NotAssigned) { wcout << L; SetConsoleTextAttribute(hConsole, 64); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); option_choice: wcout << L; vel = GetLine(Numbers); goto assigne; } wcout << L; ReassigneEnum(option); auto wtitle{ ConvertEnumToWString(option) }; system(); SetConsoleTitle(wtitle.c_str()); thread calculator, monitor; RunMonitor = true; do { Beep(500, 200); bool Threading{ false }; switch (option) { case DoSimpleCode: Repeater(option, simpledeg, ExecuteSimpledeg); break; case DoComplexCode: Repeater(option, message, ExecuteDegree); break; case DoSimpleFactor: Repeater(option, simplefact, ExecuteSimpleFact); break; case DoComplexFactor: Repeater(option, fact_message, ExecuteFactor); break; case DoCodeFactor: Repeater(option, def_sct, ExecuteSimpleDF); break; case DoAll: Repeater(option, AllMessage, ExecuteDegFactor); break; case DebugSimpleCode: Loop(option, desimpledeg, ExecuteSimpledeg); break; case DebugComplexCode: Loop(option, deg_message, ExecuteDegree); break; case DebugSimpleFactor: Loop(option, desimplefact, ExecuteSimpleFact); break; case DebugComplexFactor: Loop(option, defact_message, ExecuteFactor); break; case DebugCodeFactor: Loop(option, def_sct, ExecuteSimpleDF); break; case DebugAll: Loop(option, AllMessage, ExecuteDegFactor); break; case DebugDigits: Loop(option, de_digit, ExecuteDigit, true); break; case DebugDigitsAndCode: Loop(option, deg_digit, ExecuteDegDigit, true); break; case DebugDigitsAndFactor: Loop(option, fact_digit, ExecuteFactDigit, true); break; case DebugComplete: Loop(option, defact_digit, ExecuteAll, true); break; case ConvertCodeInverse: CodeToNumber(option); break; case SeriesExpansion: ExpandNumber(option); break; case FactorPolynomial: Threading = true; calculator = thread(DecompPolynomial<wstring>, ref(option), L); monitor = thread( MonitorConsoleSize, COORD{ 50, 20 }, ref(RunMonitor) ); break; case FractElaborator: Threading = true; calculator = thread(DecompAndSolve, ref(option)); monitor = thread( MonitorConsoleSize, COORD{ 60, 30 }, ref(RunMonitor) ); break; case FactorMatrix: Threading = true; calculator = thread(DecompMatrices, ref(option)); monitor = thread( MonitorConsoleSize, COORD{ 80, 45 }, ref(RunMonitor) ); break; } if (Threading) { SetThreadAffinityMask(calculator.native_handle(), 1 << 0); SetThreadAffinityMask(monitor.native_handle(), 1 << 1); if (calculator.joinable()) calculator.join(); if (monitor.joinable()) monitor.join(); if (!RunMonitor) { RunMonitor = true; system(); continue; } } if (option == Random) goto MB; } while (option != NotAssigned); } MB: wcout << L; ErrorCode = 0; ErrMessage = MessageBox( NULL, L, L, MB_ABORTRETRYIGNORE | MB_ICONWARNING ); Numbers.clear(); Polynomials.clear(); Expressions.clear(); GlobalNumerators.clear(); GlobalDenominators.clear(); GlobalOperators.clear(); ActionsList.clear(); if (ErrMessage == IDRETRY) { LockPrimeNumbersInput = false; goto Start; } if (ErrMessage == IDIGNORE) goto MB; End: system(); SetConsoleTextAttribute(hConsole, 4); Beep(750, 100); Beep(650, 75); Beep(550, 50); return ErrorCode; } static wstring Handler(wstring test) { if (test.find(L) != wstring::npos or test.find(L) != wstring::npos) while (Last(test) == L) test.pop_back(); if (Last(test) == L or Last(test) == L) test.pop_back(); return ElabExponents(test); } static size_t Factorial(size_t n) { if (n <= 1) return 1; return n * Factorial(n - 1); } static size_t BinomialCoeff(size_t n, size_t k) { long double coeff{ 1.0 }; if (n <= 20) coeff = Factorial(n) / (static_cast<long double>(Factorial(k)) * Factorial(n - k)); else for (size_t j = 1; j <= n - k; ++j) coeff *= (static_cast<long double>(k) + j) / j; return static_cast<size_t>(coeff); } static ptrdiff_t Gcd(ptrdiff_t A, ptrdiff_t B) { if (A < B) swap(A, B); while (B != 0) { auto temp{ B }; B = A % B; A = temp; } return A; } static big Gcd(big A, big B) { if (A < B) swap(A, B); while (B != 0) { big temp = B; B = A % B; A = temp; } return A; } template<typename T>static int Gcd(tensor<T> terms) { int gcd{}; if (terms.empty()) return 0; if constexpr (is_same_v<T, int>) { if (terms == 1) return terms[0]; gcd = terms[0]; for (const auto& term : terms) { gcd = Gcd(gcd, term); if (gcd == 1) break; } } else if constexpr (is_same_v<T, MONOMIAL<>> or is_same_v<T, monomial<>>) { if (terms == 1) return terms[0].coefficient; gcd = terms[0].coefficient; for (const auto& term : terms) { gcd = Gcd(gcd, term.coefficient); if (gcd == 1) break; } } return gcd; } static big Gcd(tensor<big> terms) { if (terms == 1) return terms[0]; auto gcd{ terms[0] }; for (const auto& term : terms) { gcd = Gcd(gcd, term); if (gcd == 1) break; } return gcd; } static ptrdiff_t intpow(ptrdiff_t base, int exp) { ptrdiff_t power{ 1 }; auto NewExp{ exp + 1 }; auto NewBase{ base }; if (base < 0) NewBase *= -1; while (--NewExp > 0) { power *= NewBase; if (power < 0) return -1; } if (exp % 2 == 1 and base < 0) return -power; return power; } inline static wstring ConvertEnumToWString(switchcase Enum) { auto it = enumToStringMap.find(Enum); if (it != enumToStringMap.end()) return it->second; return L; } inline static switchcase ConvertWStringToEnum(wstring str) { auto it = stringToEnumMap.find(str); if (it != stringToEnumMap.end()) return it->second; else { stringToEnumMap.insert({ str , NotAssigned }); it = stringToEnumMap.find(str); return it->second; } } static void ReassigneEnum(switchcase& option) { if (option != Random) return; random_device rng; mt19937 gen(rng()); uniform_int_distribution<> dis(0, commands.size() - 1); switch (dis(gen)) { case 0: option = DoSimpleCode; return; case 1: option = DoComplexCode; return; case 2: option = DoSimpleFactor; return; case 3: option = DoComplexFactor; return; case 4: option = DoCodeFactor; return; case 5: option = DebugCodeFactor; return; case 6: option = DoAll; return; case 7: option = DebugSimpleCode; return; case 8: option = DebugComplexCode; return; case 9: option = DebugSimpleFactor; return; case 10: option = DebugComplexFactor; return; case 11: option = DebugComplexFactor; return; case 12: option = DebugAll; return; case 13: option = DebugDigits; return; case 14: option = DebugDigitsAndCode; return; case 15: option = DebugDigitsAndCode; return; case 16: option = DebugDigitsAndFactor; return; case 17: option = ConvertCodeInverse; return; case 18: option = SeriesExpansion; return; case 19: option = FactorPolynomial; return; case 20: option = FractElaborator; return; case 21: option = FactorMatrix; return; } } namespace ConsoleLogData { int RotAngle{ 270 }, PolygDegree{}, PolygonSides{ 4 }; int CircleCenterX, CircleCenterY, CircleRotDegreeAngle{}; bool DecreaseAngle{ true }, DecreaseWidth{ true }; double DWidth{ 1.9 }; const tensor<int> spectrum{ 9, 9, 9, 11, 11, 3, 3, 12, 4 }; }; static void ClearArea(COORD WinCenter, COORD Dimensions) { GetConsoleScreenBufferInfo(hConsole, &csbi)(); DWORD written; COORD coord{ short(WinCenter.X - Dimensions.X), short(WinCenter.Y - Dimensions.Y) }; for (int y = WinCenter.Y; y <= WinCenter.Y + 2 * Dimensions.Y; ++y) { coord.Y = y - Dimensions.Y; FillConsoleOutputCharacter (hConsole, L, 2 * Dimensions.X + 1, coord, &written); } } static void WriteFraction(wstring Num, wstring Den, wstring& command, COORD START) { int spaces = fabs(((int)Num.size() - (int)Den.size()) / 2); bool script = true; if (Num.size() > 0) for (const auto& comma : commands) { command = comma; auto back{ command }; if (back.size() == Num.size()) continue; if (back.size() > Num.size()) back.erase(Num.size()); if (back == Num) { script = false; break; } } R; GetConsoleScreenBufferInfo(hConsole, &csbi)(); if (START.X < 0) START = csbi.dwCursorPosition; GetConsoleScreenBufferInfo(hConsole, &csbi)(); SetConsoleCursorPosition(hConsole, START); wstring S(csbi.dwSize.X - START.X, L); wcout << S << L; SetConsoleCursorPosition(hConsole, START); if (Num.size() > Den.size()) { if (!script) { SetConsoleTextAttribute(hConsole, 6); wcout << command << L; SetConsoleCursorPosition(hConsole, START); SetConsoleTextAttribute(hConsole, 15)(); } wcout << Num << L; SetConsoleCursorPosition(hConsole, { START.X, short(START.Y + 1) }); wcout << S << L; SetConsoleCursorPosition(hConsole, { START.X, short(START.Y + 1) }); wcout << wstring(Num.size(), L) << L; SetConsoleCursorPosition(hConsole, { START.X, short(START.Y + 2) }); wcout << S << L; SetConsoleCursorPosition(hConsole, { START.X, short(START.Y + 2) }); wcout << wstring(spaces, L) << Den << L; } else { if (!script) { SetConsoleTextAttribute(hConsole, 6); wcout << wstring(spaces, L) << command << L; SetConsoleCursorPosition(hConsole, START); SetConsoleTextAttribute(hConsole, 15)(); } wcout << wstring(spaces, L) << Num << L; SetConsoleCursorPosition(hConsole, { START.X, short(START.Y + 1) }); wcout << S << L; SetConsoleCursorPosition(hConsole, { START.X, short(START.Y + 1) }); wcout << wstring(Den.size(), L) << L; SetConsoleCursorPosition(hConsole, { START.X, short(START.Y + 2) }); wcout << S << L; SetConsoleCursorPosition(hConsole, { START.X, short(START.Y + 2) }); wcout << Den << L; } wcout << L; } static void PrintPFrame (double deg, int sides, double radius, COORD WinCenter) { SetConsoleTextAttribute(hConsole, 15)(); COORD coord{}; const double DIM{ 1.9 }; const short centerX{ WinCenter.X }; const short centerY{ WinCenter.Y }; long double setX, setY; long double theta{ 2 * M_PI / sides }; long double sidelenght{ sqrt(2 * radius * radius * (1 - cos(theta))) }; long double apotem{ sqrt(pow(radius, 2) - pow(sidelenght / 2, 2)) }; wstring prints{ L }; for (long double rad = 0; rad < 2 * M_PI; rad += theta) { for (int i = 0; i < sidelenght; ++i) { setX = i - sidelenght / 2; setY = apotem; rad += deg; coord.X = setX * cos(rad) - setY * sin(rad); coord.Y = setX * sin(rad) + setY * cos(rad); coord.X *= DIM; coord.X += centerX; coord.Y += centerY; rad -= deg; SetConsoleCursorPosition(hConsole, coord); int index = coord.Y - centerY + radius; index *= (long double)prints.size() / (2 * radius); wcout << prints[index]; } } } static void DrawFrame (int arc, double __i, int centerX, int centerY, double DIM) { using ConsoleLogData::spectrum; COORD coord{}; int setX, setY; const double R{ 8 }; for (int deg = 0; deg < arc; ++deg) { long double rad{ (double)deg / 180 * M_PI }; setX = R * cos(rad); setY = R * sin(rad); coord.X = setX * cos(__i) - setY * sin(__i); coord.Y = setX * sin(__i) + setY * cos(__i); coord.X *= DIM; coord.X += centerX; coord.Y += centerY; SetConsoleCursorPosition(hConsole, coord); WORD Color{ 15 }; random_device rng; mt19937 gen(rng()); uniform_int_distribution<> dis(0, 9); random_device Random; mt19937 Gen(Random()); uniform_int_distribution<> Dis(0, spectrum.size() - 1); int DisGen{ Dis(Gen) }; for (size_t j = 0; j < spectrum; ++j) if (DisGen == j) Color = spectrum[j]; SetConsoleTextAttribute(hConsole, Color); wcout << dis(gen); } } static void DrawCircleSquare(COORD CircleCenter) { using namespace ConsoleLogData; COORD Cursor{ 0, CircleCenter.Y }; Cursor.Y -= Min.Y; const double SPEED{ 50 }; const double GAP{ 0.05 }; const int const_x{ CircleCenter.X }; const int const_y{ CircleCenter.Y }; const double R2{ 5 }; bool DoNotSkip{ true }; for (CircleRotDegreeAngle;; CircleRotDegreeAngle += 7) { if (IsDone.load() and !DoNotSkip) { ClearArea(CircleCenter, Min); SetConsoleCursorPosition(hConsole, Cursor); return; } DoNotSkip = false; long double i{ (double)CircleRotDegreeAngle / 180 * M_PI }; CircleCenterX = const_x + R2 * cos(i); CircleCenterY = const_y + R2 * sin(i); if (DWidth <= 1 or DWidth >= 2.5) DecreaseWidth = !DecreaseWidth; if (RotAngle <= 0 or RotAngle >= 360) DecreaseAngle = !DecreaseAngle; DrawFrame(RotAngle, i, CircleCenterX, CircleCenterY, DWidth); DecreaseWidth ? DWidth -= GAP : DWidth += GAP; DecreaseAngle ? RotAngle -= SPEED * GAP : RotAngle += SPEED * GAP; PrintPFrame(PolygDegree * M_PI / 180, PolygonSides, 10, CircleCenter); PolygDegree += 2; if (PolygDegree % 180 == 0) switch (PolygonSides) { case 4: PolygonSides = 6; break; case 6: PolygonSides = 8; break; case 8: PolygonSides = 4; break; } sleep_for(microseconds(1)); ClearArea(CircleCenter, Min); } } inline static void CS_CenterPrinter() { GetConsoleScreenBufferInfo(hConsole, &csbi)(); COORD WinCenter{}; if (csbi.dwSize.X / 2 < Min.X) WinCenter.X = Min.X; else WinCenter.X = csbi.dwSize.X / 2; if (csbi.dwSize.Y / 2 < Min.Y) WinCenter.Y = Min.Y + 1; else WinCenter.Y = csbi.dwSize.Y / 2 + 1; DrawCircleSquare(WinCenter); } inline static void CS_CornerPrinter() { GetConsoleScreenBufferInfo(hConsole, &csbi)(); wcout << wstring(csbi.dwSize.Y - 1, L); SetConsoleCursorPosition(hConsole, { 0, 0 }); DrawCircleSquare(Min); } static void ProgressBar(long double ratio, double barWidth) { if (barWidth <= 10) return; SetConsoleCursorPosition(hConsole, { 0, 1 }); wcout << L; int pos{ int(barWidth * ratio) }; for (int i = 0; i < barWidth; ++i) { if (i < pos) wcout << L; else i == pos ? wcout << L : wcout << L; } ratio *= 100.0; wostringstream stream; stream << fixed << setprecision(1) << ratio; wcout << L << stream.str() << L; } static long double WaitingScreen(auto begin, auto end) { system(); long double delta = 1'000 * static_cast<double>(end.QuadPart - begin.QuadPart) / (ProgramFrequency.QuadPart); wostringstream output; output << fixed << setprecision(1) << L; if (delta <= 10) { output << delta * 1'000; output << L; } else if (delta <= 10'000) { output << delta; output << L; } else if (delta <= 600'000) { output << delta / 1'000; output << L; } else { output << delta / 60'000; output << L; } GetConsoleScreenBufferInfo(hConsole, &csbi)(); SetConsoleTextAttribute(hConsole, 6); COORD Cursor{ short((csbi.dwSize.X - output.str().size()) / 2 - 1), csbi.dwSize.Y / 2 - 1 }; SetConsoleCursorPosition(hConsole, Cursor); wcout << output.str(); sleep_for(seconds(1)); SetConsoleTextAttribute(hConsole, 15)(); return delta * 1'000'000; } static wstring CTSuperScript(wchar_t input) { switch (input) { case L: return L; break; case L: return L; break; case L: return L; break; case L: return L; break; case L: return L; break; case L: return L; break; case L: return L; break; case L: return L; break; case L: return L; break; case L: return L; break; } return wstring(1, input); } static wstring CFSuperScript(wstring script) { wstring output; for (const auto& ch : script) { auto it = ConvertFromSuperScript.find(script); if (it != ConvertFromSuperScript.end()) output += it->second; else output += wstring(1, ch); } return output; } static wstring ElabExponents(wstring& str) { if (!BOOLALPHA) return str; int J{ 1 }; bool dobreak{ false }; for (size_t I = 0; I < str.size(); ++I) { auto pointer{ I + 1 }; if (str.at(I) == L and I != str.size() - 1) { ile (str.at(pointer) < 128 and isdigit(str.at(pointer))) { dobreak = false; wstring replacer; if (str.at(pointer) == L) { if (J > 1) replacer = L; else dobreak = true; } else replacer = CTSuperScript(str.at(pointer)); if (dobreak) break; str.replace(pointer, 1, replacer); if (I < str.size() - 1 and J == 1) str.erase(I, 1); J++; pointer = I + J - 1 + (J == 1); if (pointer >= str.size()) break; } J = 1; } } return str; } static void DeduceFromExponents(wstring& str) { for (ptrdiff_t i = str.size() - 1; i >= 0; --i) { auto script{ wstring(1, str.at(i)) }; auto unscript{ CFSuperScript(script) }; if (unscript != script) { str.erase(i, 1); str.insert(str.begin() + i, L); str.insert(str.begin() + (i + 1), unscript.at(0)); } } } static wstring GetLine(tensor<wstring>& sugg, bool ShowSuggestions) { using type = char; int EscapeCode; if constexpr (is_same_v<type, char>) EscapeCode = -32; else EscapeCode = 224; setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); int diff{}, maxsize; wstring vel, E_Vel, command{ L }; bool script{ false }, arrow{ false }, Continue{ false }; ptrdiff_t TensorIndex{}; wstring StringCopy; for (;;) { if (_kbhit()) { script = false; GetConsoleScreenBufferInfo(hConsole, &csbi)(); maxsize = csbi.dwSize.X; if (vel.size() >= maxsize) { short height = csbi.dwCursorPosition.Y - (vel.size() - 1) / maxsize; onsoleCursorPosition(hConsole, { 0, height }); wcout << wstring(vel.size(), L); SetConsoleCursorPosition( hConsole, { (short)(maxsize - 1), height } ); vel.erase(maxsize - 1); continue; } type c = _getch(); if (c != EscapeCode and c != -109 and c < 0) continue; if (c == L) break; auto Test{ E_Vel }; ol cond{ ( c == L or c == L or c == L or c == L or c == L or c > 31 or c == -109 ) and c != EscapeCode }; if (c == EscapeCode) arrow = true; if (c == 0) { Continue = true; continue; } if (Continue) { Continue = false; continue; } if (!cond) continue; switch (c) { case L: return L; case L: if (E_Vel.size() > 1 and E_Vel.size() - diff > 0) E_Vel.erase(E_Vel.size() - 1 - diff, 1); else if (E_Vel.size() == 1 and diff == 0) E_Vel.clear(); break; case L: if (ShowSuggestions) vel = command; break; case 127: E_Vel.erase(0, E_Vel.size() - diff); break; default: auto copy{ E_Vel }; copy.erase(0, E_Vel.size() - diff); int new_diff{ (int)vel.size() - diff }; for (const auto& ch : copy) if (CFSuperScript(wstring(1, ch)) != wstring(1, ch)) new_diff--; if (!arrow) { if (new_diff < 0) new_diff = 0; vel = vel.substr(0, new_diff) + wstring(1, c) + vel.substr(new_diff, vel.size()); break; } switch (c) { case L: if (diff < E_Vel.size()) diff++; break; case L: if (diff > 0) diff--; break; case L: if (sugg.empty()) break; TensorIndex++; if (TensorIndex >= sugg) TensorIndex = 0; StringCopy = vel = sugg[TensorIndex]; break; case L: if (sugg.empty()) break; TensorIndex--; if (TensorIndex < 0) TensorIndex = sugg.size() - 1; StringCopy = vel = sugg[TensorIndex]; break; case L: if (diff <= 0) break; E_Vel.erase(E_Vel.size() - diff, 1); diff--; break; case -109: E_Vel.erase(E_Vel.size() - diff); diff = 0; break; case L: diff = E_Vel.size(); break; case L: diff = 0; break; } if (arrow) arrow = false; } if (BOOLALPHA) { ElabExponents(E_Vel); if (E_Vel != Test) { vel = E_Vel; DeduceFromExponents(vel); } else { E_Vel = vel; ElabExponents(E_Vel); } } se if (E_Vel == Test) E_Vel = vel; else vel = E_Vel; auto Velpart{ E_Vel }; if (Velpart.size() - diff >= 0) Velpart.erase(Velpart.size() - diff); else Velpart.clear(); if (vel.size() > maxsize) { vel.clear(); E_Vel.clear(); Velpart.clear(); diff = 0; } if (vel.size() > maxsize) { wcout << L << wstring(maxsize, L); script = true; } R; if (ShowSuggestions and !vel.empty()) for (const auto& comma : commands) { command = comma; auto back{ command }; if (back.size() == vel.size() and back != vel) continue; if (back.size() > vel.size()) back.erase(vel.size()); if (back == E_Vel) { SetConsoleTextAttribute(hConsole, 6); wcout << L << wstring(maxsize, ); wcout << L << command; SetConsoleTextAttribute(hConsole, 15)(); wcout << L << E_Vel << L << Velpart; script = true; break; } } if (!script) { wcout << L << wstring(maxsize, L); wcout << L << E_Vel << L << Velpart; } SetConsoleCursorInfo(hConsole, &cursor); } if (!RunMonitor) return L; } if (vel != StringCopy) sugg << vel; return vel; } static wstring GetUserNum (wstring txt, ptrdiff_t low, ptrdiff_t high, bool ShowSuggestions) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); switchcase option; ptrdiff_t UserNum; wstring check; do { wcout << txt; check = GetLine(Numbers, ShowSuggestions); wcout << L; for (ptrdiff_t i = check.size() - 1; i >= 0; --i) if (check.at(i) == L or check.at(i) == L or check.at(i) == L) check.erase(i, 1); if (check == L or check.empty()) return check; option = ConvertWStringToEnum(check); ReassigneEnum(option); if (option != NotAssigned) return ConvertEnumToWString(option); if (regex_search(check, wregex(L))) { if (!PolynomialSyntaxDirector(check).empty()) { UserNum = 0; goto exit; } factor<big> operation{ PolynomialMultiply<big>(GetMonomialsAssister(check)) }; if (operation > 1 or operation.empty()) { UserNum = 0; goto exit; } UserNum = operation[0].coefficient.Number<ptrdiff_t>(); } else UserNum = big(check).Number<ptrdiff_t>(); if (UserNum <= numeric_limits<ptrdiff_t>::min() or UserNum >= numeric_limits<ptrdiff_t>::max()) UserNum = 0; exit: if (UserNum < low or UserNum > high) { wcout << L; if (txt.empty()) { GetConsoleScreenBufferInfo(hConsole, &csbi)(); SetConsoleCursorPosition( hConsole, { csbi.dwCursorPosition.X, (short)(csbi.dwCursorPosition.Y - 1) } ); wcout << wstring(14, L) << L; } } auto gcd{ Gcd(UserNum, LCM) }; UserNum /= gcd.Number<ptrdiff_t>(); LCM /= gcd; } while (UserNum < low or UserNum > high); return to_wstring(UserNum); } static void SetDebug(wstring message, switchcase& opt, bool& Return, ptrdiff_t& LowerBound, ptrdiff_t& UpperBound, ptrdiff_t& datalenght ) { wstring n_{ to_wstring(GlobalMax) }, Input, txt; Return = false; wcout << L; wcout << L << n_ << L; SetConsoleTextAttribute(hConsole, 15)(); txt = L; do Input = GetUserNum(txt, 1, GlobalMax, true); while (Input.empty()); if (Input == L) { opt = Random; Return = true; return; } opt = ConvertWStringToEnum(Input); ReassigneEnum(opt); if (opt != NotAssigned) { system(); SetConsoleTitle(Input.c_str()); Return = true; return; } LowerBound = stoull(Input) + 1; txt = L; do Input = GetUserNum(txt, 1, GlobalMax, true); while (Input.empty()); if (Input == L) { opt = Random; Return = true; } opt = ConvertWStringToEnum(Input); ReassigneEnum(opt); if (opt != NotAssigned) { system(); SetConsoleTitle(Input.c_str()); Return = true; return; } UpperBound = stoull(Input) + 1; if (UpperBound < LowerBound) swap(LowerBound, UpperBound); datalenght = UpperBound - LowerBound; } static void SendCtrlPlusMinus(bool plus) { INPUT inputs[4]{}; inputs[0].type = INPUT_KEYBOARD; inputs[0].ki.wVk = VK_CONTROL; inputs[1].type = INPUT_KEYBOARD; inputs[1].ki.wVk = plus ? VK_OEM_PLUS : VK_OEM_MINUS; inputs[2].type = INPUT_KEYBOARD; inputs[2].ki.wVk = plus ? VK_OEM_PLUS : VK_OEM_MINUS; inputs[2].ki.dwFlags = KEYEVENTF_KEYUP; inputs[3].type = INPUT_KEYBOARD; inputs[3].ki.wVk = VK_CONTROL; inputs[3].ki.dwFlags = KEYEVENTF_KEYUP; SendInput(ARRAYSIZE(inputs), inputs, sizeof(INPUT)); } static void SendString(wstring str) { tensor<INPUT> inputs(str.size() * 2); for (const auto& ch : str) { SHORT vk = VkKeyScanW(ch); if (vk == -1) { switch (ch) { case L: vk = VK_OEM_2; break; case L: vk = VK_OEM_5; break; case L: vk = VK_MULTIPLY; break; case L: vk = VK_SUBTRACT; break; case L: vk = VK_ADD; break; default: continue; } } bool NeedsShift = (vk & 0x0100) != 0; BYTE vkey = LOBYTE(vk); if (NeedsShift) { INPUT ShiftDown = { 0 }; ShiftDown.type = INPUT_KEYBOARD; ShiftDown.ki.wVk = VK_SHIFT; inputs.push_back(ShiftDown); } INPUT KeyDown = { 0 }; KeyDown.type = INPUT_KEYBOARD; KeyDown.ki.wVk = vkey; inputs.push_back(KeyDown); INPUT KeyUp = KeyDown; KeyUp.ki.dwFlags = KEYEVENTF_KEYUP; inputs.push_back(KeyUp); if (NeedsShift) { INPUT ShiftUp = { 0 }; ShiftUp.type = INPUT_KEYBOARD; ShiftUp.ki.wVk = VK_SHIFT; ShiftUp.ki.dwFlags = KEYEVENTF_KEYUP; inputs.push_back(ShiftUp); } } SendInput(UINT(inputs.size()), inputs.Data(), sizeof(INPUT)); } static void MonitorConsoleSize(COORD min, atomic_bool& runMonitor) { int time{ 50 }; unique_lock<mutex> lk(MonitorMTX); while (RunMonitor) { MonitorCV.wait_for(lk, milliseconds(time), [&] { return !RunMonitor; }); if (!RunMonitor) return; etCursorPos(); auto oldLength{ csbi.dwSize.X }; if (oldLength >= min.X and csbi.dwSize.Y >= min.Y) { time = 50; continue; } ndCtrlPlusMinus(false); GetConsoleScreenBufferInfo(hConsole, &csbi)(); auto newLength{ csbi.dwSize.X }; if (oldLength == newLength and GetConsoleWindow() == GetForegroundWindow()) { runMonitor = false; return; } time /= 2; } } static void UserInputThread() { while (computing) { sleep_for(milliseconds(100)); if (_kbhit()) { char choice = _getch(); if (choice == L or choice == L) { { lock_guard<mutex> lock(mtx); GlobalInterr = true; interrupted = true; } Cv.notify_all(); return; } } } } RECT ClientRect; namespace WindowData { bool redo{ false }; enum states { MIN, MAX, H_FLX, A_FLX, D_FLX }; LPARAM Coords{}, Current{}; bool enable{ false }; double Zoom{ 1 }; wchar_t __save; int gIndex{}; tensor<int> Indexlist; int shiftX{}, shiftY{}; tensor<tensor<int>> memory{ {} }; class DATA { public: COLORREF Color; Fraction<> Function; wstring ID; tensor<int> States; tensor<long double> StatX, StatY; DATA() : Color(0) {} DATA(Fraction<> funct); bool operator==(DATA other) { return ID == other.ID; } }; tensor<DATA> List; DATA::DATA(Fraction<> funct) : Function(funct), ID(funct.str()) { const double DeltaX{ 0.01 }; auto Derivative{ funct.derivate(0) }; StatX = RootExtractor({ Derivative.num }); for (ptrdiff_t i = StatX.size() - 1; i > 0; --i) if (StatX[i] == StatX[i - 1]) StatX.erase(i, 1); size_t I{}; for (; I < StatX; ++I) { auto x{ StatX[I] }; auto y{ funct.num[0]({ x }) / funct.den[0]({ x }) }; StatY << y; x -= DeltaX; bool before{ funct.num[0]({ x }) / funct.den[0]({ x }) > y }; x += 2 * DeltaX; bool after{ funct.num[0]({ x }) / funct.den[0]({ x }) > y }; if (before and after) States << MIN; else if (!(before or after)) States << MAX; else States << H_FLX; } auto NewStatX{ RootExtractor({ Derivative.derivate(0).num }) }; for (ptrdiff_t j = NewStatX.size() - 1; j > 0; --j) if (NewStatX[j] == NewStatX[j - 1]) NewStatX.erase(j, 1); for (; I < NewStatX; ++I) { auto x{ NewStatX[I] }; auto y{ funct.num[0]({ x }) / funct.den[0]({ x }) }; StatX << x; StatY << y; x -= DeltaX; bool before{ funct.num[0]({ x }) / funct.den[0]({ x }) > y }; States << (before ? D_FLX : A_FLX); } random_device rng; mt19937 gen(rng()); uniform_int_distribution<> dis(0, 127); int rgbValues[3]{}; auto i{ List.size() }; if ((i | FOREGROUND_BLUE) != i) rgbValues[2] += dis(gen); if ((i | FOREGROUND_GREEN) != i) rgbValues[1] += dis(gen); if ((i | FOREGROUND_RED) != i) rgbValues[0] += dis(gen); if ((i | FOREGROUND_INTENSITY) != i) { rgbValues[0] += 128; rgbValues[1] += 128; rgbValues[2] += 128; } Color = RGB(rgbValues[0], rgbValues[1], rgbValues[2]); } }; namespace Window3Data { enum states { MINIMUM, MAXIMUM, SADDLE, UNKNOWN, }; tensor<int> def; tensor<int> Light{ 0, 0, -1 }; double Zoom{ 1 }; bool enable{ false }; LPARAM Coords{}, Current{}; tensor<long double> StatX, StatY, StatZ; Fraction<> Function, PartialXder, PartialYder; auto Theta{ M_PI / 4 }; auto Phi{ M_PI / 3 }; }; static void DrawLine(int firstX, int firstY, int secondX, int secondY, HPEN Hpen) { SelectObject(GHDC, Hpen); MoveToEx(GHDC, firstX, firstY, NULL); LineTo(GHDC, secondX, secondY); DeleteObject(Hpen); } static void DrawLineToBuffer( HDC hdcmem, HBITMAP hbmem, int firstX, int firstY, int secondX, int secondY, HPEN Hpen ) { HBITMAP oldBitmap = (HBITMAP)SelectObject(hdcmem, hbmem); if (!oldBitmap) return; HPEN oldPen = (HPEN)SelectObject(hdcmem, Hpen); if (!oldPen) { SelectObject(hdcmem, oldBitmap); return; } MoveToEx(hdcmem, firstX, firstY, NULL); LineTo(hdcmem, secondX, secondY); SelectObject(hdcmem, oldPen); SelectObject(hdcmem, oldBitmap); } static void DrawLine(Point__ P1, Point__ P2, HPEN hpen) { SelectObject(GHDC, hpen); MoveToEx(GHDC, P1.GetScreenX(), P1.GetScreenY(), NULL); LineTo(GHDC, P2.GetScreenX(), P2.GetScreenY()); DeleteObject(hpen); } static void DrawLineToBuffer (HDC hdcmem, HBITMAP hbmem, Point__ P1, Point__ P2, HPEN Hpen) { DrawLineToBuffer( hdcmem, hbmem, P1.GetScreenX(), P1.GetScreenY(), P2.GetScreenX(), P2.GetScreenY(), Hpen ); } static void IncrementCalculator(double zoom, double& pInc, double& vInc) { bool less; double comparator{ 1 }; vInc = zoom; do (less = comparator < vInc) ? comparator *= 10 : comparator /= 10; while (comparator < vInc == less); less ? comparator /= 10 : comparator *= 10; if (vInc <= comparator) vInc = comparator; else if (vInc <= 4 * comparator) vInc = 2 * comparator; else vInc = 5 * comparator; pInc = 20 * vInc / zoom; if (pInc > 100) { pInc /= 10; vInc /= 10; } else if (pInc < 10) { pInc *= 10; vInc *= 10; } } static void ProjectPoint(tensor<long double> point, int& pointX, int& pointY) { using namespace Window3Data; Phi += M_PI / 2; Matrix<> Rotation{ { cos(Theta), -sin(Theta), 0 }, { sin(Theta) * sin(Phi), cos(Theta) * sin(Phi), cos(Phi) }, { sin(Theta) * cos(Phi), cos(Theta) * cos(Phi), -sin(Phi) } }; Phi -= M_PI / 2; auto Projection{ Rotation * point }; pointX = Projection[0] * 20 / Zoom + ClientRect.right / 2; pointY = Projection[1] * 20 / Zoom + ClientRect.bottom / 2; } static void ProjectAndDrawLine (tensor<long double> start, tensor<long double> end, HPEN Hpen) { int p1x, p1y, p2x, p2y; ProjectPoint(start, p1x, p1y); ProjectPoint(end, p2x, p2y); DrawLine(p1x, p1y, p2x, p2y, Hpen); } static void DrawAxis(HDC hdcmem, HBITMAP hbmem, double pInc, double vInc) { using namespace Window3Data; int OriginX{ ClientRect.right / 2 }, OriginY{ ClientRect.bottom / 2 }; const int MarkLenght{ 5 }; tensor<int> pixelX, pixelY; tensor<wstring> PixelValues; for (int i = 0; i < 3; ++i) { double point_pos[3]{}, point_neg[3]{}; double Value{ 300 }; point_pos[i] = i == 1 ? -Value : Value; point_neg[i] = i == 1 ? Value : -Value; int X1 = X2D(point_pos[0], point_pos[1], point_pos[2]); int Y1 = Y2D(point_pos[0], point_pos[1], point_pos[2]); int X2 = X2D(point_neg[0], point_neg[1], point_neg[2]); int Y2 = Y2D(point_neg[0], point_neg[1], point_neg[2]); auto color{ RGB( abs(point_pos[0]) / 100 * 255, abs(point_pos[2]) / 100 * 255, abs(point_pos[1]) / 100 * 255 ) }; LOGBRUSH lb; lb.lbStyle = BS_SOLID; lb.lbColor = color; lb.lbHatch = 0; HPEN UsedPen = ExtCreatePen(PS_DOT, 1, &lb, 0, NULL); DrawLineToBuffer( hdcmem, hbmem, X1, Y1, OriginX, OriginY, CreatePen(PS_SOLID, 1, color) ); DrawLineToBuffer(hdcmem, hbmem, OriginX, OriginY, X2, Y2, UsedPen); auto Pxf{ X2 - OriginX }; auto Pyf{ Y2 - OriginY }; auto hyp{ hypot(Pxf, Pyf) }; double _x{}; uto PerpAngle = Pyf == 0 ? M_PI / 2 : atan(-double(Pxf) / Pyf); auto cX{ MarkLenght * cos(PerpAngle) }; auto cY{ MarkLenght * sin(PerpAngle) }; for (double pixel = 0; pixel < hyp; pixel += pInc) { if (pixel == 0) continue; auto y = Pyf == 0 ? 0 : sqrt(fabs(pixel * pixel / (1 + pow((double(Pxf) / Pyf), 2)))); auto x = Pyf == 0 ? pixel : y * double(Pxf) / Pyf ; if (x > 0 == Pxf > 0) x = -x; if (y > 0 != Pyf > 0) y = -y; auto X{ Handler(to_wstring(x)) }; pixelX << OriginX + x << OriginX - x; pixelY << OriginY - y << OriginY + y; PixelValues << X << L + X; DrawLineToBuffer( hdcmem, hbmem, OriginX + x - cX, OriginY - y - cY, OriginX + x + cX, OriginY - y + cY, UsedPen ); DrawLineToBuffer( hdcmem, hbmem, OriginX - x - cX, OriginY + y - cY, OriginX - x + cX, OriginY + y + cY, UsedPen ); _x += vInc; } TextOut(GHDC, X1, Y1, (wstring(1, L + i)).c_str(), (wstring(1, L + i)).size()); } } static LRESULT CALLBACK WindowProcessor2D( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) { using namespace WindowData; switch (uMsg) { case WM_DESTROY: Zoom = 1; shiftX = 0; shiftY = 0; charVariable = __save; Variables = wstring(1, __save); PostQuitMessage(0); return 0; case WM_SIZE: InvalidateRect(hwnd, NULL, TRUE); return 0; case WM_COMMAND: { auto id{ LOWORD(wParam) }; if ((id | 2) == id) { SetFocus(hwnd); return 0; } bool derivate{ (id | 1) == id }; int index = id >> 2; f (!derivate) { Indexlist.erase(Indexlist.begin() + index); memory(gIndex + 1); memory << Indexlist; gIndex++; redo = !Indexlist.empty(); charVariable = __save; Variables = wstring(1, __save); auto shiftx{ shiftX }; auto shifty{ shiftY }; auto zoom{ Zoom }; DestroyWindow(hwnd); shiftX = shiftx; shiftY = shifty; Zoom = zoom; return 0; } uto derivative{ List[memory[gIndex][index]].Function.derivate(0) }; if (derivative.num == polynomial<>{ { { 0, tensor<int>(Variables.size(), 0) } } }) { SetFocus(hwnd); return 0; } DATA new_data{ derivative }; for (const auto& indx : Indexlist) if (List[indx] == new_data) { SetFocus(hwnd); return 0; } Indexlist << List.size(); List << new_data; gIndex++; if (Indexlist > 10) { --Indexlist; gIndex--; } memory(gIndex); memory << Indexlist; redo = true; charVariable = __save; Variables = wstring(1, __save); auto shiftx{ shiftX }; auto shifty{ shiftY }; auto zoom{ Zoom }; DestroyWindow(hwnd); shiftX = shiftx; shiftY = shifty; Zoom = zoom; return 0; } case WM_LBUTTONDOWN: enable = true; WindowData::Current = Coords = lParam; return 0; case WM_LBUTTONUP: enable = false; WindowData::Current = lParam; return 0; case WM_MOUSEMOVE: { WindowData::Current = lParam; if (!enable) break; int OldXpos = (short)LOWORD(Coords), OldYpos = (short)HIWORD(Coords); int xPos = (short)LOWORD(lParam), yPos = (short)HIWORD(lParam); shiftX -= OldXpos - xPos; shiftY += OldYpos - yPos; Coords = lParam; InvalidateRect(hwnd, NULL, TRUE); return 0; } case WM_MOUSEWHEEL: { int WheelData = GET_WHEEL_DELTA_WPARAM(wParam) / 120; bool decrease{ WheelData < 0 }; double amount = (GetKeyState(VK_MENU) & 0x8000) != 0 ? 3 : 1.2; WheelData = abs(WheelData); for (int i = 0; i < WheelData; ++i) { if (Zoom < 10000000 and decrease) Zoom *= amount; if (Zoom > 0.00001 and !decrease) Zoom /= amount; } } WindowData::Current = lParam; InvalidateRect(hwnd, NULL, TRUE); return 0; case WM_KEYDOWN: switch (wParam) { case 13: Zoom = 1; shiftX = 0; shiftY = 0; charVariable = __save; Variables = wstring(1, __save); DestroyWindow(hwnd); return 0; case L: enable = false; Zoom = 1; shiftX = 0; shiftY = 0; break; case L: shiftX += 10; break; case L: shiftX -= 10; break; case L: shiftY += 10; break; case L: shiftY -= 10; break; case 189: if (Zoom < 10000000) Zoom *= 1.2; break; case 187: if (Zoom > 0.00001) Zoom /= 1.2; break; case L: { if ((GetKeyState(VK_CONTROL) & 0x8000) == 0 or gIndex + 1 >= memory) return 0; gIndex++; Indexlist = memory[gIndex]; redo = true; auto shiftx{ shiftX }; auto shifty{ shiftY }; auto zoom{ Zoom }; DestroyWindow(hwnd); shiftX = shiftx; shiftY = shifty; Zoom = zoom; } return 0; case L: { if ((GetKeyState(VK_CONTROL) & 0x8000) == 0 or gIndex <= 0) return 0; gIndex--; Indexlist = memory[gIndex]; redo = true; auto shiftx{ shiftX }; auto shifty{ shiftY }; auto zoom{ Zoom }; DestroyWindow(hwnd); shiftX = shiftx; shiftY = shifty; Zoom = zoom; } return 0; default: return DefWindowProc(hwnd, uMsg, wParam, lParam); } InvalidateRect(hwnd, NULL, TRUE); return 0; case WM_PAINT: { PAINTSTRUCT ps; RECT client; GetClientRect(hwnd, &client); if (client.right == 0 and client.bottom == 0) return DefWindowProc(hwnd, uMsg, wParam, lParam); HDC hdc = BeginPaint(hwnd, &ps); GHDC = hdc; int OriginX{ client.right / 2 + shiftX }; int OriginY{ client.bottom / 2 - shiftY }; const int markLenght{ 3 }; SetBkMode(hdc, TRANSPARENT); HFONT hFont = CreateFontW( 16, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, L ); SelectObject(hdc, hFont); double ValueIncrement, PixelIncrement; IncrementCalculator(Zoom, PixelIncrement, ValueIncrement); ensor<int> NumbersX, NumbersY; tensor<wstring> ValsX, ValsY; int OldPixelValue{ OriginX }; SIZE TextSize{ -50, 0 }, OldTextSize{ TextSize }; double x{}; for ( int pixel = OriginX; pixel < client.right; pixel += PixelIncrement ) { HPEN hpen; DrawLine( pixel, OriginY - markLenght, pixel, OriginY + markLenght, CreatePen(PS_SOLID, 2, RGB(0, 128, 0)) ); auto X{ Handler(to_wstring(x)) }; GetTextExtentPoint32(hdc, cstr(X), &TextSize); if (OldPixelValue + OldTextSize.cx / 2 - pixel + TextSize.cx / 2 + 10 < 0) { OldPixelValue = pixel; OldTextSize = TextSize; NumbersX << pixel - TextSize.cx / 2; ValsX << X; hpen = CreatePen(PS_SOLID, 1, RGB(96, 96, 96)); } else hpen = CreatePen(PS_DOT, 1, RGB(64, 64, 64)); DrawLine(pixel, 0, pixel, client.bottom, hpen); x += ValueIncrement; } OldPixelValue = OriginX; OldTextSize = TextSize = {}; x = -ValueIncrement; for ( int pixel = OriginX - PixelIncrement; pixel > 0; pixel -= PixelIncrement ) { HPEN hpen; DrawLine( pixel, OriginY - markLenght, pixel, OriginY + markLenght, CreatePen(PS_SOLID, 2, RGB(0, 128, 0)) ); auto X{ Handler(to_wstring(x)) }; GetTextExtentPoint32(hdc, cstr(X), &TextSize); if (OldPixelValue - OldTextSize.cx / 2 - pixel - TextSize.cx / 2 - 10 > 0) { OldPixelValue = pixel; OldTextSize = TextSize; NumbersX << pixel - TextSize.cx / 2; ValsX << X; hpen = CreatePen(PS_SOLID, 1, RGB(96, 96, 96)); } else hpen = CreatePen(PS_DOT, 1, RGB(64, 64, 64)); DrawLine(pixel, 0, pixel, client.bottom, hpen); x -= ValueIncrement; } ixelValue = OriginY; OldTextSize = TextSize = {}; double y{ ValueIncrement }; for ( int pixel = OriginY - PixelIncrement; pixel > 0; pixel -= PixelIncrement ) { HPEN hpen; DrawLine( OriginX - markLenght, pixel, OriginX + markLenght, pixel, CreatePen(PS_SOLID, 2, RGB(0, 128, 0)) ); auto Y{ Handler(to_wstring(y)) }; GetTextExtentPoint32(hdc, cstr(Y), &TextSize); if (pixel - OldTextSize.cy / 2 - OldPixelValue - TextSize.cy / 2 < 0) { OldPixelValue = pixel; OldTextSize = TextSize; NumbersY << pixel - TextSize.cy / 2; ValsY << Y; hpen = CreatePen(PS_SOLID, 1, RGB(96, 96, 96)); } else hpen = CreatePen(PS_DOT, 1, RGB(64, 64, 64)); rawLine(0, pixel, client.right, pixel, hpen); y += ValueIncrement; } OldPixelValue = OriginY; OldTextSize = TextSize = { 0, 26 }; y = -ValueIncrement; for ( int pixel = OriginY + PixelIncrement; pixel < client.bottom; pixel += PixelIncrement ) { HPEN hpen; DrawLine( OriginX - markLenght, pixel, OriginX + markLenght, pixel, CreatePen(PS_SOLID, 2, RGB(0, 128, 0)) ); to Y{ Handler(to_wstring(y)) }; GetTextExtentPoint32(hdc, cstr(Y), &TextSize); if (OldPixelValue + OldTextSize.cy / 2 - pixel + TextSize.cy / 2 < 0) { OldPixelValue = pixel; OldTextSize = TextSize; NumbersY << pixel - TextSize.cy / 2; ValsY << Y; hpen = CreatePen(PS_SOLID, 1, RGB(96, 96, 96)); } else hpen = CreatePen(PS_DOT, 1, RGB(64, 64, 64)); DrawLine(0, pixel, client.right, pixel, hpen); y -= ValueIncrement; } SetTextColor(hdc, RGB(192, 255, 255)); for (size_t i = 0; i < NumbersX; ++i) TextOut(hdc, NumbersX[i], OriginY, cstr(ValsX[i])); for (size_t i = 0; i < NumbersY; ++i) TextOut(hdc, OriginX, NumbersY[i], cstr(ValsY[i])); for (size_t i = 0; i < memory[gIndex]; ++i) { bool write{ false }, Enable{ true }; tensor<int> Xcoord, Ycoord, asintothes; for ( double __x = (-client.right / 2 - shiftX) * Zoom / 20; __x < (client.right / 2 - shiftX) * Zoom / 20; __x += 0.1 * Zoom ) { auto _den{ List[memory[gIndex][i]].Function.den[0]({ __x }) * LCM.Number<long double>() }; if (_den == 0) continue; auto fx{ List[memory[gIndex][i]].Function.num[0]({ __x }) / _den }; int X = OriginX + __x * 20 / Zoom, Y = OriginY - fx * 20 / Zoom; if (Y > 0 and Y <= client.bottom and X > 0 and X <= client.right) { write = true; Enable = true; Xcoord << X; Ycoord << Y; } else if (write) { if (Enable) asintothes << X; Enable = false; } } for (ptrdiff_t j = 0; j < (ptrdiff_t)Xcoord.size() - 1; ++j) { bool Continue{ false }; for (const auto& asintothe : asintothes) if (Xcoord[j] < asintothe and asintothe < Xcoord[j + 1]) { Continue = true; break; } if (Continue) continue; DrawLine( Xcoord[j], Ycoord[j], Xcoord[j + 1], Ycoord[j + 1], CreatePen(PS_SOLID, 2, List[memory[gIndex][i]].Color) ); } } DrawLine( OriginX, 0, OriginX, client.bottom, CreatePen(PS_SOLID, 2, RGB(0, 128, 0)) ); DrawLine( 0, OriginY, client.right, OriginY, CreatePen(PS_SOLID, 2, RGB(0, 128, 0)) ); tensor<wstring> PriorityLabels; tensor<int> PriorityLabelsX, PriorityLabelsY; tensor<int> PriorityLabelsCenterX, PriorityLabelsCenterY; int cursorX = (short)LOWORD(WindowData::Current); int cursorY = (short)HIWORD(WindowData::Current); for (size_t i = 0; i < memory[gIndex]; ++i) for (size_t j = 0; j < List[memory[gIndex][i]].States; ++j) { SetTextColor(hdc, List[memory[gIndex][i]].Color); int X = OriginX + List[memory[gIndex][i]].StatX[j] * 20 / Zoom; int Y = OriginY - List[memory[gIndex][i]].StatY[j] * 20 / Zoom; for (int k = -2; k < 2; ++k) for (int l = -2; l < 2; ++l) SetPixel(hdc, X + k, Y + l, RGB(255, 255, 255)); wstring Out; switch (List[memory[gIndex][i]].States[j]) { case MIN: Out = L; break; case MAX: Out = L; break; case H_FLX: Out = L; break; case A_FLX: Out = L; break; case D_FLX: Out = L; break; } auto _X{ Handler(to_wstring(List[memory[gIndex][i]].StatX[j])) }; auto _Y{ Handler(to_wstring(List[memory[gIndex][i]].StatY[j])) }; Out += _X + L + _Y + L; SIZE _TextSize; GetTextExtentPoint32(hdc, cstr(Out), &_TextSize); int CX{ X - _TextSize.cx / 2 }, CY{ Y - _TextSize.cy }; int CX2{ X + _TextSize.cx / 2 }, CY2{ Y + _TextSize.cy / 2 }; if (CX < cursorX and cursorX < CX2 and CY < cursorY and cursorY < CY2) { PriorityLabels << Out; PriorityLabelsX << CX; PriorityLabelsY << CY; PriorityLabelsCenterX << X; PriorityLabelsCenterY << Y; } else TextOut(hdc, CX, CY, cstr(Out));  (PriorityLabels.empty()) continue; t MinRadius{ -1 }, MinRadiusIndex{}; for (size_t k = 0; k < PriorityLabels; ++k) { int radius = hypot( cursorX - PriorityLabelsCenterX[k], cursorY - PriorityLabelsCenterY[k] ); if (MinRadius < 0 or MinRadius > radius) { MinRadius = radius; MinRadiusIndex = k; } } for (size_t k = 0; k < PriorityLabels; ++k) { if (k == MinRadiusIndex) { SetBkColor(hdc, RGB(255, 255, 255)); SetTextColor(hdc, RGB(0, 0, 0)); SetBkMode(hdc, OPAQUE); TextOut( hdc, PriorityLabelsX[k], PriorityLabelsY[k], cstr(PriorityLabels[k]) ); SetBkMode(hdc, TRANSPARENT); continue; } TextOut( hdc, PriorityLabelsX[k], PriorityLabelsY[k], cstr(PriorityLabels[k]) ); } } EndPaint(hwnd, &ps); return 0; } default: return DefWindowProc(hwnd, uMsg, wParam, lParam); } return DefWindowProc(hwnd, uMsg, wParam, lParam); } static BOOL CreateGraph(Fraction<> funct) { if (Variables.size() != 1) return false; using namespace WindowData; __save = charVariable; charVariable = L; Variables = L; HINSTANCE hInstance = GetModuleHandle(0); bool present{ false }; DATA new_data; if (funct.num.empty() and funct.den.empty()) goto WindowCreation; new_data = funct; for (const auto idx : memory[gIndex]) if (List[idx] == new_data) { present = true; break; } if (!present) { Indexlist << List.size(); List << new_data; gIndex++; if (List > 10) { --Indexlist; gIndex--; } } memory(gIndex); memory << Indexlist; if (memory == 2) { --memory; gIndex--; } WindowCreation: WNDCLASS wc{}; wc.lpfnWndProc = WindowProcessor2D; wc.hInstance = hInstance; wc.lpszClassName = L; wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); RegisterClass(&wc); HWND hwnd = CreateWindowEx( 0, L, L, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 1200, 700, NULL, NULL, hInstance, NULL ); if (!hwnd) return false; ShowWindow(hwnd, SW_SHOW); PAINTSTRUCT ps; HDC hdc = BeginPaint(hwnd, &ps); SIZE Maxlenght{}; for (size_t i = 0; i < memory[gIndex]; ++i) { auto Text{ List[memory[gIndex][i]].ID }; SIZE lenght{}; GetTextExtentPoint32(hdc, cstr(Text), &lenght); if (Maxlenght.cx < lenght.cx) Maxlenght.cx = lenght.cx; if (Maxlenght.cy < lenght.cy) Maxlenght.cy = lenght.cy; } EndPaint(hwnd, &ps); tensor<HWND> ButtonList; for (size_t i = 0; i < memory[gIndex]; ++i) { ButtonList << CreateWindowEx( 0, L, List[memory[gIndex][i]].ID.c_str(), WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON, 30, 30 + i * (2 * Maxlenght.cy + 20), Maxlenght.cx + 10, Maxlenght.cy + 10, hwnd, HMENU((i << 2) | 2), hInstance, NULL ); ButtonList << CreateWindowEx( 0, L, L, WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON, 50 + Maxlenght.cx, 30 + i * (2 * Maxlenght.cy + 20), 2 * Maxlenght.cy, 2 * Maxlenght.cy, hwnd, HMENU((i << 2) | 1), hInstance, NULL ); ButtonList << CreateWindowEx( 0, L, L, WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON, 60 + Maxlenght.cx + 2 * Maxlenght.cy, 30 + i * (2 * Maxlenght.cy + 20), 2 * Maxlenght.cy, 2 * Maxlenght.cy, hwnd, HMENU((i << 2) | 0), hInstance, NULL ); } InvalidateRect(hwnd, NULL, FALSE); MSG msg{}; while (GetMessage(&msg, NULL, 0, 0)) { TranslateMessage(&msg); DispatchMessage(&msg); } bool result{ redo }; redo = false; return result; } static LRESULT CALLBACK WindowProcessor3D( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) { using namespace Window3Data; switch (uMsg) { case WM_DESTROY: Zoom = 1; PostQuitMessage(0); return 0; case WM_SIZE: InvalidateRect(hwnd, NULL, TRUE); return 0; case WM_LBUTTONDOWN: enable = true; Window3Data::Current = Window3Data::Coords = lParam; return 0; case WM_LBUTTONUP: enable = false; Window3Data::Current = lParam; return 0; case WM_MOUSEMOVE: { indow3Data::Current = lParam; if (!enable) break; int OldXpos = (short)LOWORD(Coords), OldYpos = (short)HIWORD(Coords); int xPos = (short)LOWORD(lParam), yPos = (short)HIWORD(lParam); ong double radius{ hypot(OldXpos - ClientRect.right / 2, OldYpos - ClientRect.bottom / 2) }; Theta += 2 * asin((OldXpos - xPos) / (2 * radius)); Phi += 2 * asin((OldYpos - yPos) / (2 * radius)); f (Theta < 0) Theta += 2 * M_PI; if (Theta > 2 * M_PI) Theta -= 2 * M_PI; if (Phi < 0) Phi += 2 * M_PI; if (Phi > 2 * M_PI) Phi -= 2 * M_PI; Coords = lParam; InvalidateRect(hwnd, NULL, TRUE); return 0; } case WM_MOUSEWHEEL: { int WheelData = GET_WHEEL_DELTA_WPARAM(wParam) / 120; bool decrease{ WheelData < 0 }; double amount = (GetKeyState(VK_MENU) & 0x8000) != 0 ? 3 : 1.2; WheelData = abs(WheelData); for (int i = 0; i < WheelData; ++i) { if (Zoom < 10000000 and decrease) Zoom *= amount; if (Zoom > 0.00001 and !decrease) Zoom /= amount; } } Window3Data::Current = lParam; InvalidateRect(hwnd, NULL, TRUE); return 0; case WM_KEYDOWN: switch (wParam) { case 13: DestroyWindow(hwnd); return 0; case L: Theta = M_PI / 4; Phi = M_PI / 3; Zoom = 1; break; case L: Theta += M_PI / 36; if (Theta < 0) Theta += 2 * M_PI; if (Theta > 2 * M_PI) Theta -= 2 * M_PI; break; case L: Theta -= M_PI / 36; if (Theta < 0) Theta += 2 * M_PI; if (Theta > 2 * M_PI) Theta -= 2 * M_PI; break; case L: Phi += M_PI / 36; if (Phi < 0) Phi += 2 * M_PI; if (Phi > 2 * M_PI) Phi -= 2 * M_PI; break; case L: Phi -= M_PI / 36; if (Phi < 0) Phi += 2 * M_PI; if (Phi > 2 * M_PI) Phi -= 2 * M_PI; break; case 189: if (Zoom < 10000000) Zoom *= 1.2; break; case 187: if (Zoom > 0.00001) Zoom /= 1.2; break; default: return 0; } InvalidateRect(hwnd, NULL, TRUE); return 0; case WM_PAINT: { AINTSTRUCT ps; RECT client; GetClientRect(hwnd, &client); ClientRect = client; if (client.right == 0 and client.bottom == 0) return DefWindowProc(hwnd, uMsg, wParam, lParam); HDC hdc = BeginPaint(hwnd, &ps); GHDC = hdc; etTextColor(hdc, RGB(128, 128, 255)); SetBkMode(hdc, TRANSPARENT); HFONT hFont = CreateFontW( 16, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, L ); SelectObject(hdc, hFont); HDC hdcmem{ CreateCompatibleDC(hdc) }; HBITMAP hbmem{ CreateCompatibleBitmap(hdc, client.right, client.bottom) }; SelectObject(hdcmem, hbmem); double PixelIncrement, ValueIncrement; IncrementCalculator(Zoom, PixelIncrement, ValueIncrement); DrawAxis(hdcmem, hbmem, PixelIncrement, ValueIncrement); ensor<tensor<Point__>> mesh; for (double x = -15 * Zoom; x < 15 * Zoom; x += 0.5 * Zoom) { tensor<Point__> points; for (double y = -15 * Zoom; y < 15 * Zoom; y += 0.5 * Zoom) { Point__ P{ Function, x, y }; if (P.GetScreenY() < 0 or P.GetScreenY() > client.bottom) { points << Point__(); continue; } P.SetNormalVector(PartialXder, PartialYder); points << P; } mesh << points; } or (size_t i = 0; i < mesh.size() - 1; ++i) for (size_t j = 0; j < mesh[i].size() - 1; ++j) { tensor<Point__> square{ mesh[i][j], mesh[i][j + 1], mesh[i + 1][j], mesh[i + 1][j + 1] }; for (const auto& P : square) if (P.Void()) continue; auto ii{ square[0].GetNormalVector() }; auto ij{ square[1].GetNormalVector() }; auto ji{ square[2].GetNormalVector() }; auto jj{ square[3].GetNormalVector() }; tensor<long double> Normal{ ii[0] + ij[0] + ji[0] + jj[0], ii[1] + ij[1] + ji[1] + jj[1], ii[2] + ij[2] + ji[2] + jj[2] }; long double norm{ hypot(Normal[0], Normal[1], Normal[2]) }; for (auto& component : Normal) component /= norm; tensor<double> light{ 0, 0, 1 }; auto dot{ Normal[0] * light[0] + Normal[1] * light[1] + Normal[2] * light[2] }; int RgbValue = clamp(int(255 * dot), 0, 255); if (RgbValue < 0) continue; HPEN pen{ CreatePen(PS_SOLID, 1, RGB(RgbValue, RgbValue, RgbValue)) }; SelectObject(hdcmem, pen); DrawLineToBuffer(hdcmem, hbmem, square[0], square[1], pen); DrawLineToBuffer(hdcmem, hbmem, square[0], square[2], pen); DeleteObject(pen); } rawAxis(hdcmem, hbmem, PixelIncrement, ValueIncrement); for (size_t i = 0; i < StatX; ++i) { int pointX, pointY; ProjectPoint({ StatX[i], StatY[i], StatZ[i] }, pointX, pointY); for (int j = 0; j < 2; ++j) for (int k = 0; k < 2; ++k) SetPixel(hdc, pointX + j, pointY + k, RGB(255, 255, 255)); wstring Out; switch (def[i]) { case MINIMUM: Out = L; break; case MAXIMUM: Out = L; break; case SADDLE: Out = L; break; case UNKNOWN: Out = L; break; } auto _X{ Handler(to_wstring(StatX[i])) }; auto _Y{ Handler(to_wstring(StatY[i])) }; auto _Z{ Handler(to_wstring(StatZ[i])) }; Out += _X + L + _Y + L + _Z + L; SIZE txtsize; GetTextExtentPoint32(hdc, cstr(Out), &txtsize); TextOut(hdc, pointX - txtsize.cx / 2, pointY + 10, cstr(Out)); } BitBlt(hdc, 0, 0, client.right, client.bottom, hdcmem, 0, 0, SRCPAINT); DeleteObject(hbmem); DeleteDC(hdcmem); EndPaint(hwnd, &ps); return 0; } default: return DefWindowProc(hwnd, uMsg, wParam, lParam); } return DefWindowProc(hwnd, uMsg, wParam, lParam); } static void Project3DGraph(Fraction<> funct) { if (Variables.size() != 2) return; using namespace Window3Data; Function = funct; PartialXder = Function.derivate(0); PartialYder = Function.derivate(1); StatX.clear(); StatY.clear(); StatZ.clear(); auto StationaryPoints{ SystemSolver({ PartialXder.num[0], PartialYder.num[0] }) }; for (size_t i = 0; i < StationaryPoints; ++i) { StatX << StationaryPoints[i][0]; StatY << StationaryPoints[i][1]; StatZ << Function({ StationaryPoints[i][0], StationaryPoints[i][1] }); } Matrix<Fraction<>> Hessian{ { PartialXder.derivate(0), PartialXder.derivate(1) }, { PartialYder.derivate(0), PartialYder.derivate(1) }, }; for (size_t i = 0; i < StatX; ++i) { Matrix<> hessian(2); for (int j = 0; j < 2; ++j) for (int k = 0; k < 2; ++k) hessian[j] << Hessian[j][k]({ StatX[i], StatY[i] }); long double A{ hessian[0][0] }, B{ hessian[0][1] }; long double C{ hessian[1][0] }, D{ hessian[1][1] }; long double delta{ A * A + D * D - 2 * A * D + 4 * B * C }; if (delta < 0) { def << UNKNOWN; continue; } delta = sqrt(delta); long double e1{ (A + D + delta) / 2 }, e2{ (A + D - delta) / 2 }; if (e1 == 0 or e2 == 0) def << UNKNOWN; else if (e1 > 0 != e2 > 0) def << SADDLE; else if (e1 > 0 and e2 > 0) def << MINIMUM; else def << MAXIMUM; } HINSTANCE hInstance = GetModuleHandle(0); WNDCLASS wc{}; wc.lpfnWndProc = WindowProcessor3D; wc.hInstance = hInstance; wc.lpszClassName = L; wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH); RegisterClass(&wc); HWND hwnd = CreateWindowEx( 0, L, L, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, 1200, 700, NULL, NULL, hInstance, NULL ); if (!hwnd) return; ShowWindow(hwnd, SW_SHOW); MSG msg{}; while (GetMessage(&msg, NULL, 0, 0)) { TranslateMessage(&msg); DispatchMessage(&msg); } } static bool Prime(ptrdiff_t number) { if (number <= 1) return false; if (number <= 3) return true; if (number < GlobalMax) return PrimeNumbers.is_prime[number]; if (number % 2 == 0 or number % 3 == 0) return false; for (size_t i = 5; i * i <= number; i += 6) if (number % i == 0 or number % (i + 2) == 0) return true; return true; } static void PrimeNCalculator(ptrdiff_t max, ptrdiff_t min) { GetConsoleScreenBufferInfo(hConsole, &csbi)(); PrimeNumbers.is_prime(max + 1, true); const int BARWIDTH{ csbi.dwSize.X - 11 }; int speed{ 50 }, iter{}; const int SQUARE{ (int)sqrt(max) + 2 }; system(); SetConsoleTextAttribute(hConsole, 4); wstring warning{ L }; warning.append(L + to_wstring(GlobalMax)); if (BARWIDTH + 11 > warning.size()) wcout << warning; DECLARE_TIME_POINT(begin); SetConsoleTextAttribute(hConsole, 15)(); for (ptrdiff_t p = 2; p < SQUARE; ++p) { if (!PrimeNumbers.is_prime[p]) continue; for (ptrdiff_t i = min - (min % p) + (p * p); i <= max; i += p) PrimeNumbers.is_prime[i] = false; if (iter % speed == 0) { DECLARE_TIME_POINT(stop); long double progress{ (long double)p / SQUARE }; if (progress > 1) progress = 1; else if (progress > 0.5) speed = 15; ProgressBar(progress, BARWIDTH); int time = 1'000 * static_cast<double>(stop.QuadPart - begin.QuadPart) / (ProgramFrequency.QuadPart); long double time_rem{ (time / progress) * (1 - progress) }; long double time_seconds{ (long double)time_rem / 1'000 }; wostringstream stream; stream << fixed << setprecision(1) << time_seconds; wcout << L << stream.str() << L; if (speed < 75) speed += 5; } iter++; } SetConsoleCursorPosition(hConsole, { 0, 0 }); wcout << wstring(BARWIDTH + 11, L) << L; wcout << wstring(BARWIDTH + 11, L) << L; thread t1([&]() { for (ptrdiff_t p = min == 0 ? 2 : min + 1001; p < max + 1; ++p) if (PrimeNumbers.is_prime[p]) PrimeNumbers.list_primes << p; lock_guard<mutex> lock(mtx); IsDone = true; cv.notify_one(); } ); thread t2(CS_CenterPrinter); if (t1.joinable()) t1.join(); if (t2.joinable()) t2.join(); } static tensor<compost> DecomposeNumber(ptrdiff_t input) { int index{}; tensor<compost> output(12, compost{ 0, 1 }); for (size_t i = 0; PrimeNumbers.list_primes[i] * PrimeNumbers.list_primes[i] <= input; ++i) if (input != 1) if (input % PrimeNumbers.list_primes[i] == 0) { if (output[index].factors == PrimeNumbers.list_primes[i]) output[index].exp++; else output[index].factors = PrimeNumbers.list_primes[i]; input /= PrimeNumbers.list_primes[i]; if (input % PrimeNumbers.list_primes[i] != 0) index++; i--; } if (output[index].factors == input) output[index].exp++; else output[index].factors = input; return output; } static tensor<int> DecomposeStrings(wstring terminal) { int pass{}, CiphresElement; tensor<int> ciphres; for (size_t i = 0; i < terminal.size(); ++i) { while (pass != 0) { pass--; i++; } if (i >= terminal.size()) return ciphres; if (i == terminal.size() - 1) CiphresElement = terminal.at(i) - L; else if (i > terminal.size() - 3) { if (terminal.at(i + 1) == L) { CiphresElement = 10 * (terminal.at(i) - L); pass = 1; } else CiphresElement = terminal.at(i) - L; } else if (terminal.at(i) == L) { CiphresElement = 10 * (terminal.at(i + 1) - L) + (terminal.at(i + 2) - L); pass = 2; } else { if (terminal.at(i + 1) == L) { CiphresElement = 10 * (terminal.at(i) - L); pass = 1; } else CiphresElement = terminal.at(i) - L; } ciphres << CiphresElement; } return ciphres; } static tensor<wstring> Fractioner(wstring str) { tensor<wstring> monomials; wstring temp; auto backup{ str }; int ParenthesisBalance{}, Parenthesis{}, find{}; for (const auto& ch : backup) { if (ch == L) ParenthesisBalance++; if (ParenthesisBalance == 0 and ch == L) { temp = str; for (size_t finder = 0; finder < temp.size(); ++finder) { if (find == 0) { if (temp.at(finder) == L) Parenthesis++; if (Parenthesis == 0 and temp.at(finder) == L) find = finder; if (temp.at(finder) == L) Parenthesis--; } } temp.erase(find); monomials << temp; str.erase(0, find + 1); find = 0; } if (ch == L) ParenthesisBalance--; } monomials << str; return monomials; } static tensor<tensor<wstring>> FractPolynomial(wstring pol) { while ( (Last(pol) == L || Last(pol) == L)) pol.pop_back(); if (!issign(pol.at(0))) pol = L + pol; tensor<wstring> adders; int Parenthesis{}; for (ptrdiff_t i = pol.size() - 1; i >= 0; --i) { switch (pol.at(i)) { case L: Parenthesis++; break; case L: Parenthesis--; break; } if (issign(pol.at(i)) and Parenthesis == 0) { auto part{ pol }; part.erase(0, i); if (part.at(0) == L) part.erase(0, 1); pol.erase(i); adders << part; } } tensor<tensor<wstring>> factors(adders.size()); for (size_t i = 0; i < adders; ++i) { auto adder{ adders[i] }; for (ptrdiff_t j = adders[i].size() - 1; j >= 0;) { auto J{ j }; auto FactorPart{ adder }; int parenthesis{ adders[i].at(j) != L }; for (ptrdiff_t k = FactorPart.size() - 1; k >= 0; --k) { switch (FactorPart.at(k)) { case L: parenthesis++; break; case L: parenthesis--; break; } if (parenthesis == 0) { FactorPart.erase(0, k + (adders[i].at(j) != L)); adder.erase(adder.size() - FactorPart.size()); j = k; break; } } if (FactorPart == L) FactorPart = L; factors[i] << FactorPart; if (j == J) break; } } for (size_t i = 0; i < factors; ++i) for (ptrdiff_t j = factors[i].size() - 1; j >= 0; --j) if (factors[i][j].empty()) factors[i].erase(factors[i].begin() + j); for (ptrdiff_t i = factors.size() - 1; i >= 0; --i) if (factors[i].empty()) factors.erase(factors.begin() + i); return factors; } static wstring Cript(ptrdiff_t input) { if (CalculatedData.find(input) != CalculatedData.end()) return CalculatedData[input]; auto expfactors{ DecomposeNumber(input) }; while (expfactors.last().factors == 0) expfactors--; wstring OutputString, ExpVerify, ExpString, PrimeExp_String, result; ptrdiff_t WhatFactor, prime_exp; int sizestring, presence; bool repeat; for ( size_t FactorIndexAccesser = 0; FactorIndexAccesser < expfactors; ++FactorIndexAccesser ) { repeat = false; presence = 0; ExpVerify = to_wstring(expfactors[FactorIndexAccesser].exp); WhatFactor = expfactors[FactorIndexAccesser].factors; wstring start{ L }, end{ L }; if (expfactors[FactorIndexAccesser].exp != 1 and expfactors[FactorIndexAccesser].exp < 11) { end += ExpVerify; presence = 1; } else if (expfactors[FactorIndexAccesser].exp > 10) { end += L + ExpVerify; presence = 2; } auto WhatFactorString{ to_wstring(WhatFactor) }; OutputString = start + WhatFactorString + end; do { while (Prime(WhatFactor)) { ptrdiff_t index = PrimeNumbers.list_primes.size() / 2; ptrdiff_t position{ -1 }, incr{ index }; for (;;) { incr /= 2; if (incr == 0) incr = 1; if (PrimeNumbers.list_primes[index] > WhatFactor) index -= incr; else if (PrimeNumbers.list_primes[index] < WhatFactor) index += incr; else { position = index + 1; break; } } WhatFactor = position; WhatFactorString = to_wstring(WhatFactor); OutputString.erase(0, OutputString.find(L)); OutputString = start + WhatFactorString + OutputString; switch (presence) { case 1: ExpString = wstring(1, Last(OutputString)); OutputString.erase(OutputString.size() - 1); break; case 2: ExpString = L + wstring(1, OutputString.at(OutputString.size() - 2)) + wstring(1, Last(OutputString)); OutputString.erase(OutputString.size() - 3); break; } if (repeat) { PrimeExp_String = wstring(1, Last(OutputString)); OutputString.erase(OutputString.size() - 1); prime_exp = stoull(PrimeExp_String) + 1; PrimeExp_String = to_wstring(prime_exp); if (prime_exp > 10) PrimeExp_String = L + PrimeExp_String; OutputString += PrimeExp_String; } else OutputString += L; if (presence > 0) OutputString += ExpString; repeat = true; } if (WhatFactor != 1 and !Prime(WhatFactor)) { WhatFactorString = Cript(WhatFactor); OutputString.erase(0, OutputString.find(L)); OutputString = start + WhatFactorString + OutputString; WhatFactor = 1; } } while (WhatFactor != 1); result += L + OutputString; } result.erase(0, 1); int position[12]{}, j{}; for (int i = 0; i < result.size() - 2; ++i) if ( result.at(i) == L and result.at(i + 1) == L and result.at(i + 2) == L ) position[j++] = i; for (int k = j - 1; k >= 0; --k) result.erase(position[k], 3); int l{}; sizestring = result.size(); if (sizestring > 4) { for (int m = 0; m < result.size() - 3; ++m) if ((result.at(m) == L) and (result.at(m + 3) == L)) position[l++] = m; or (int m = l - 1; m >= 0; --m) { result.erase(position[m] + 3, 1); result.erase(position[m], 1); } } CalculatedData[input] = result; return result; } static wstring FactNumber(ptrdiff_t input) { auto expfactors{ DecomposeNumber(input) }; while (expfactors.last().factors == 0) expfactors--; wstring output; for (size_t i = 0; i < expfactors; ++i) { output += to_wstring(expfactors[i].factors); if (expfactors[i].exp != 1) output += L + to_wstring(expfactors[i].exp); output += L; } output.erase(output.size() - 3); return output; } static int ExeStrings(wstring input) { bool presence{ true }; int output{}, location{}, values[12]{}; for (size_t i = 0; i < input.size(); ++i) if (input.at(i) == L) input.erase(i, 1); auto parts{ Fractioner(input) }; for (size_t i = 0; i < parts; ++i) { if (parts[i].at(0) == L) { for (ptrdiff_t j = parts[i].size() - 1; j >= 0; --j) if ((presence) and (parts[i].at(j) == L)) { presence = false; location = j; } auto temp{ parts[i] }; temp.erase(location); temp.erase(0, 1); parts[i].erase(0, location + 1); values[i] = ExeStrings(temp) * stoi(parts[i]); } else values[i] = stoi(parts[i]); presence = true; } for (size_t end = 0; end < parts.size(); ++end) output += values[end]; return output; } static divisor DivisorCalculator(wstring factor) { divisor output{ 1, 1, 1, L }; tensor<wstring> parts; tensor<ptrdiff_t> values; tensor<int> exponents; bool ExpPresence{ false }; for (ptrdiff_t i = factor.size() - 1; i >= 0; --i) if (factor.at(i) == L) { auto backup{ factor }; backup.erase(0, i + 2); if (Last(backup) == L) backup.pop_back(); parts << backup; factor.erase(i); } if (Last(factor) == L) factor.pop_back(); parts << factor; for (size_t i = 0; i < parts.size(); ++i) { ptrdiff_t value{}, exp{ 1 }; ExpPresence = false; for (size_t j = 1; j < parts[i].size(); ++j) if (parts[i].at(j) == L) { value = stoull(parts[i].substr(0, j)); exp = stoull(parts[i].substr(j + 1, parts[i].size() - 1)); ExpPresence = true; } if (!ExpPresence) value = stoull(parts[i]); values << value; exponents << exp; } for (size_t i = 0; i < parts; ++i) output.DivNumber *= exponents[i] + 1; ptrdiff_t x{ 1 }; for (size_t i = 0; i < parts; ++i) { ptrdiff_t num = -1 + intpow(values[i], exponents[i] + 1); ptrdiff_t den{ values[i] - 1 }; if (den != 0) output.DivSum *= (num / den); x *= intpow(values[i], exponents[i]); } if (output.DivSum < 0) output.DivSum = -1; if (output.DivNumber > 0) { double out{ (double)output.DivNumber / 2 }; ptrdiff_t y; if (integer(out)) y = intpow(x, out); else y = intpow(x, out) * sqrt(x); if (y > 0) output.DivProduct = y; else if (output.DivNumber % 2 == 0) output.Div_pr = to_wstring(x) + L + to_wstring((ptrdiff_t)out); else { output.Div_pr = to_wstring((ptrdiff_t)sqrt(x)); output.Div_pr += L + to_wstring((ptrdiff_t)(out * 2)); } } else { output.DivNumber = -1; output.DivProduct = -1; } return output; } static digitRatio DigitRationalizer(ptrdiff_t inpt) { digitRatio output; int digit_sum{}, digit_product{ 1 }; auto input{ to_string(inpt) }; for (size_t i = 0; i < input.size(); ++i) { digit_sum += input.at(i) - L; digit_product *= input.at(i) - L; } if (items.digitSumRatioNum == 0 and inpt % digit_sum == 0) { output.digitSumRatioNum = 1; output.digitSumRatioDen = inpt / digit_sum; } else if ( items.digitSumRatioNum * inpt == items.digitSumRatioDen * digit_sum ) { output.digitSumRatioNum = items.digitSumRatioNum; output.digitSumRatioDen = items.digitSumRatioDen; } if (digit_product == 0) { output.digitProductRatioNum = 0; output.digitProductRatioDen = 0; } else if (items.digitProductRatioNum == 0 and inpt % digit_product == 0) { output.digitProductRatioNum = 1; output.digitProductRatioDen = inpt / digit_product; } else if ( items.digitProductRatioNum * inpt == items.digitProductRatioDen * digit_product ) { output.digitProductRatioNum = items.digitProductRatioNum; output.digitProductRatioDen = items.digitProductRatioDen; } return output; } static tensor<int> DivisorCounter(int num) { tensor<int> vec; auto expfact{ DecomposeNumber(num) }; while (expfact.last().factors == 0) expfact--; tensor<tensor<int>> MainDiv; for (size_t i = 0; i < expfact; ++i) { MainDiv++; int EFelement{ 1 }; for (int j = 0; j <= expfact[i].exp; ++j) { MainDiv[i] << EFelement; EFelement *= expfact[i].factors; } } tensor<int> temp; for (ptrdiff_t i = MainDiv.size() - 1; i > 0; --i) { for (const auto& a : MainDiv[i]) for (const auto& b : MainDiv[i - 1]) temp << a * b; MainDiv[i - 1] = temp; MainDiv--; } return MainDiv[0]; } static NumberData ExecuteSimpledeg(ptrdiff_t input) { NumberData output; output.number = input; output.code = Cript(input); return output; } static NumberData ExecuteDegree(ptrdiff_t input) { NumberData output; output.number = input; output.code = Cript(input); ptrdiff_t copy = input, counter{}; do { output.sequence << copy; copy = ExeStrings(Cript(copy)); counter++; if (copy < 4) output.degree = counter + copy; } while (copy != 1); output.sequence << 1; copy = input; return output; } static NumberData ExecuteSimpleFact(ptrdiff_t input) { NumberData output; output.number = input; output.expression = FactNumber(input); return output; } static NumberData ExecuteFactor(ptrdiff_t input) { NumberData output; output.number = input; output.expression = FactNumber(input); auto D{ DivisorCalculator(output.expression) }; output.div = D; return output; } static NumberData ExecuteSimpleDF(ptrdiff_t input) { NumberData output; output.number = input; output.code = Cript(input); output.expression = FactNumber(input); return output; } static NumberData ExecuteDigit(ptrdiff_t input) { NumberData output; auto D{ DigitRationalizer(input) }; output.number = input; output.digit = D; return output; } static NumberData ExecuteDegFactor(ptrdiff_t input) { auto A{ ExecuteDegree(input) }; auto B{ ExecuteFactor(input) }; A.expression = B.expression; A.div = B.div; return A; } static NumberData ExecuteDegDigit(ptrdiff_t input) { auto B{ ExecuteDigit(input) }; if (B.digit.digitSumRatioNum == 0 and B.digit.digitProductRatioNum == 0) return B; auto A{ ExecuteDegree(input) }; A.digit = B.digit; return A; } static NumberData ExecuteFactDigit(ptrdiff_t input) { auto B{ ExecuteDigit(input) }; if (B.digit.digitSumRatioNum == 0 and B.digit.digitProductRatioNum == 0) return B; auto A{ ExecuteFactor(input) }; A.digit = B.digit; return A; } static NumberData ExecuteAll(ptrdiff_t input) { auto C{ ExecuteDigit(input) }; if (C.digit.digitSumRatioNum == 0 and C.digit.digitProductRatioNum == 0) return C; auto A{ ExecuteDegree(input) }; auto B{ ExecuteFactor(input) }; A.expression = B.expression; A.div = B.div; A.digit = C.digit; return A; } static wstring PolynomialSyntax(wstring pol) { if (pol.empty()) return L; for (const auto& c : pol) if (!isalnum(c) and !issign(c) and c != L and c != L and c != L) return L; for (size_t i = 1; i < pol.size(); ++i) if (issign(pol.at(i)) and issign(pol.at(i - 1))) return L; if (!issign(pol.at(0))) pol = L + pol; if (issign(Last(pol))) return L; for (size_t i = 0; i < pol.size() - 1; ++i) if (pol.at(i) == L and !isdigit(pol.at(i + 1))) return L; tensor<wstring> parts; for (ptrdiff_t i = pol.size() - 1; i >= 0; --i) if (issign(pol.at(i))) { auto part{ pol }; part.erase(0, i + 1); pol.erase(i); parts << part; } for (auto part : parts) { auto New{ part }; if (New.find(L) != wstring::npos) New.erase(New.find(L), 1); if (!New.empty()) if (New.find(L) != wstring::npos) return L; if (part.find(L) != wstring::npos) { if (part.at(0) == L) return L; if (Last(part) == L) return L; if (!isdigit(Last(part))) return L; while (isdigit(Last(part))) { if (part.empty()) break; part.pop_back(); if (Last(part) == L) { part.pop_back(); break; } if (!isdigit(Last(part))) return L; } } if (part.empty()) continue; while (isdigit(part.at(0))) { part.erase(0, 1); if (part.empty()) break; } if (part.empty()) continue; if (part.at(0) == L or Last(part) == L) return L; for (size_t i = 0; i < part.size(); ++i) for (size_t j = i + 1; j < part.size(); ++j) if (isalpha(part.at(i)) and part.at(i) == part.at(j)) return L; for (size_t i = 0; i < part.size() - 1; ++i) if (isdigit(part.at(i))) for (size_t j = i; j < part.size(); ++j) { if (j >= part.size()) break; if (!isdigit(part.at(j))) break; if (j - i >= 2) return L; } for (size_t i = 1; i < part.size(); ++i) if ( isdigit(part.at(i)) and !isdigit(part.at(i - 1)) and part.at(i - 1) != L ) return L; } return L; } static wstring PolynomialSyntaxDirector(wstring pol) { if (pol.empty()) return L; if (pol.at(0) == L or Last(pol) == L) return L; for (ptrdiff_t i = pol.size() - 2; i > 0; --i) if (pol.at(i) == L) { if (pol.at(i - 1) == or pol.at(i + 1) == ) return L; if (pol.at(i - 1) == or pol.at(i + 1) == ) { pol.erase(i, 1); continue; } if (!isalnum(pol.at(i - 1)) or !isalnum(pol.at(i + 1))) return L; pol.erase(i, 1); } for (ptrdiff_t i = 0; i < (ptrdiff_t)pol.size() - 2; ++i) if (pol.at(i) == L and pol.at(i + 1) == L) return L; if (pol.empty()) return L; auto copy{ pol }; if (copy.size() >= 2) { if (copy.at(0) == L) copy.erase(0, 1); if (Last(copy) == L) copy.pop_back(); } if (copy.find(L) == wstring::npos and copy.find(L) == wstring::npos) return PolynomialSyntax(copy); bool balanced{ false }; balance: int ParenthesisBalance{}; for (const auto& c : copy) { switch (c) { case L: ParenthesisBalance++; break; case L: ParenthesisBalance--; break; } if (ParenthesisBalance < 0) { if (!balanced) break; return L; } if (ParenthesisBalance >= 100) return L; } if (ParenthesisBalance == 0) pol = copy; else if (!balanced) { balanced = true; copy = pol; goto balance; } else return L; for (ptrdiff_t i = pol.size() - 1; i >= 0; --i) if (pol.at(i) == L or pol.at(i) == L) pol.erase(i, 1); for (const auto& c : pol) if (!isalnum(c) and !issign(c) and c != L and c != L and c != L and c != L ) return L; bool error{ true }; for (const auto& c : pol) if (!issign(c)) error = false; if (error) return L; for (size_t i = 1; i < pol.size(); ++i) if (issign(pol.at(i)) and issign(pol.at(i - 1))) return L; if (pol.at(0) == L) return L; auto fact = FractPolynomial(pol); for (const auto& adder : fact) if (adder > 10) return L; for (auto adder : fact) for (auto element : adder) { if (PolynomialSyntaxDirector(element).empty()) continue; if (element.find(L) != wstring::npos) if (!isdigit(Last(element))) return L; bool exp{ element.size() > 1 and element.size() < 4 }; if (exp) if (element.at(0) == L) for (size_t i = 1; i < element.size(); ++i) if (!isdigit(element.at(i))) return L; } return L; } static wstring UpdateString(wstring& ToEvaluate) { int BoundaryBalance{}; for (const auto& c : ToEvaluate) { switch (c) { case L: BoundaryBalance++; break; case L: BoundaryBalance--; break; } if (BoundaryBalance > 1 or BoundaryBalance < 0) return L; } tensor<wstring> pieces; bool start{ true }; for (ptrdiff_t i = ToEvaluate.size() - 1; i >= 0; --i) { wstring piece{ ToEvaluate }; if (ToEvaluate.at(i) == L) { piece.erase(0, i + 1); if (i + 1 < ToEvaluate.size()) ToEvaluate.erase(i + 1); if (start) start = false; } else if (ToEvaluate.at(i) == L and !start) { piece.erase(0, i); ToEvaluate.erase(i); } else continue; pieces << piece; } if (!ToEvaluate.empty()) pieces << ToEvaluate; for (auto piece : pieces) { if (piece.empty()) continue; if (piece.at(0) == L and Last(piece) == L) { piece.pop_back(); piece.erase(0, 1); } if (piece.find(L) != wstring::npos or piece.find(L) != wstring::npos) return L; } ToEvaluate.clear(); for (auto piece : pieces) { if (piece.empty()) continue; if (piece.at(0) == L) { piece.pop_back(); piece.erase(0, 1); ToEvaluate = piece + ToEvaluate; } else { for (ptrdiff_t i = piece.size() - 1; i >= 0; --i) if (!isdigit(piece.at(i)) or piece.at(i) > 127) piece.erase(i, 1); if (piece.empty()) continue; int number = stoi(piece); if (number > GlobalMax or number <= 0) return L; ToEvaluate = Cript(number) + ToEvaluate; } } return L; } static wstring NumberCodeSyntax(wstring ToEvaluate) { if (ToEvaluate == L) return L; tensor<wstring> mono; bool LocError{ true }; int ParenthesisBalance{}; for (ptrdiff_t space = ToEvaluate.size() - 1; space >= 0; --space) if (ToEvaluate.at(space) == L or ToEvaluate.at(space) == L) ToEvaluate.erase(space, 1); for (size_t i = 0; i < ToEvaluate.size(); ++i) { switch (ToEvaluate.at(i)) { case L: ParenthesisBalance++; break; case L: ParenthesisBalance--; break; } if (ParenthesisBalance < 0) return L; if (ParenthesisBalance >= 100) return L; } if (ParenthesisBalance != 0) return L; if (ToEvaluate.empty()) return L; if (regex_search(ToEvaluate, wregex(L))) return L; if (ToEvaluate.at(0) == L) return L; if (ToEvaluate.at(0) == L) return L; if (ToEvaluate.at(0) == L) return L; if (Last(ToEvaluate) == L) return L; if (regex_search(ToEvaluate, wregex((L)))) return L; if (regex_search(ToEvaluate, wregex(L))) return L; if (regex_search(ToEvaluate, wregex(L))) if (!regex_search(ToEvaluate, wregex(L))) return L; if (regex_search(ToEvaluate, wregex(L))) return L; mono = Fractioner(ToEvaluate); for (size_t indexof = 0; indexof < mono; ++indexof) { ptrdiff_t stackfinder{ -1 }, stickfinder{ -1 }, FindIndex{ -1 }; bool stop{ false }; int res{}; tensor<int> min_ciphres, max_ciphres; tensor<int> ciphr_min, ciphr_max; wstring min, max; auto stack{ mono[indexof] }; for (size_t second = 1; second < mono; ++second) { if (indexof != second) { if (mono[indexof] == mono[second]) return L; wstring stick{ mono[second] }; if (stack.size() < stick.size()) { min = stack; max = stick; } else { min = stick; max = stack; } if (stack.at(0) == L or stick.at(0) == L) { stackfinder = stack.find(L); stickfinder = stick.find(L); if (stackfinder == wstring::npos) stackfinder = -1; if (stickfinder == wstring::npos) stickfinder = -1; if (stackfinder * stickfinder < 0) { if (stackfinder > 0) FindIndex = stackfinder; else FindIndex = stickfinder; } else if (stickfinder == stackfinder) { FindIndex = stackfinder; for (int l = 0; l <= FindIndex + 1; ++l) if (l < min.size()) if (stick.at(l) != stack.at(l)) stop = true; auto min_backup{ min }; auto max_backup{ max }; min_backup.erase(0, FindIndex + 2); max_backup.erase(0, FindIndex + 2); min_ciphres = DecomposeStrings(min_backup); max_ciphres = DecomposeStrings(max_backup); if (min_ciphres < max_ciphres) { ciphr_min = min_ciphres; ciphr_max = max_ciphres; } else { ciphr_min = max_ciphres; ciphr_max = min_ciphres; } for (size_t l = 0; l < ciphr_min; ++l) { if (!stop and ciphr_min[l] == ciphr_max[l]) { res++; if (ciphr_min[l] != ciphr_max[l]) stop = true; } else stop = true; } } } else { min_ciphres = DecomposeStrings(min); max_ciphres = DecomposeStrings(max); if (min_ciphres < max_ciphres) { ciphr_min = min_ciphres; ciphr_max = max_ciphres; } else { ciphr_min = max_ciphres; ciphr_max = min_ciphres; } for (size_t l = 0; l < ciphr_min; ++l) { if (!stop and ciphr_min[l] == ciphr_max[l]) { res++; if (ciphr_min[l] != ciphr_max[l]) stop = true; } else stop = true; } } if ( res % 2 == 1 and ciphr_max.size() - ciphr_min.size() <= 1 and ciphr_max <= 1 + res and ciphr_min <= 1 + res ) return L; } } for (ptrdiff_t i = stack.size() - 1; i >= 0; --i) if (stack.at(i) == ) { FindIndex = i; break; } if (Last(stack) == L) return L; if (Last(stack) == L) return L; if (stack.at(0) == L) { LocError = true; for (ptrdiff_t checkplus = 1; checkplus < FindIndex; ++checkplus) if (stack.at(checkplus) == L) LocError = false; if (LocError) return L; stack.erase(0, 1); stack.erase(FindIndex - 1); auto message{ NumberCodeSyntax(stack) }; if (!message.empty()) return message; } else if (mono[indexof].at(0) == L) return L; else for (size_t check = 1; check < mono[indexof].size(); ++check) if (mono[indexof].at(check) == L or mono[indexof].at(check) == L) return L; } return L; } static ptrdiff_t NumberConverter(size_t root, wstring M) { bool WhichWay{ true }, XOutOfRange{ false }; bool UselessExponent{ false }; bool XSubscriptOutOfRange{ false }; int size = PrimeNumbers.list_primes.size(), nums; auto ciphres{ DecomposeStrings(M) }; for (size_t iter = 0; iter < ciphres; ++iter) { WhichWay = !WhichWay; nums = ciphres[iter]; if (!XOutOfRange and WhichWay) { UselessExponent = nums == 1; root = intpow(root, nums); } else do { if (!XOutOfRange and root < size) { if (root > 0) root = PrimeNumbers.list_primes[root - 1]; else XSubscriptOutOfRange = true; nums--; } else XOutOfRange = true; } while (!XSubscriptOutOfRange and !XOutOfRange and nums != 0); if (XSubscriptOutOfRange) return -3; if (UselessExponent) return -2; if (XOutOfRange) return -1; return root; } static ptrdiff_t StringConverter(wstring ToEvaluate) { size_t integer{ 1 }; auto mono{ Fractioner(ToEvaluate) }; for (size_t indexof = 0; indexof < mono; ++indexof) { auto M{ mono[indexof] }; ptrdiff_t FindIndex{ -1 }; for (ptrdiff_t i = M.size() - 1; i >= 0; --i) if (M.at(i) == ) { FindIndex = i; break; } ptrdiff_t root; if (M.at(0) != L) root = NumberConverter(1, M); lse root = NumberConverter( StringConverter(M.substr(1, FindIndex - 1)), M.substr(FindIndex + 1, M.size() - 1) ); if (root < 0) return root; else integer *= root; } return integer; } static void CodeConverter (wstring ToEvaluate, wstring message, bool ShowErrors, bool NecBoundary) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); ptrdiff_t number; if (ToEvaluate == L) return; for (ptrdiff_t space = ToEvaluate.size() - 1; space >= 0; --space) if (ToEvaluate.at(space) == L or ToEvaluate.at(space) == L) ToEvaluate.erase(space, 1); if (NecBoundary) UpdateString(ToEvaluate); number = StringConverter(ToEvaluate); if (ShowErrors or number > 0) { auto text{ L + ToEvaluate + L }; ConsoleText << Console{ text, 11 }; } if (number < -2 and ShowErrors) { auto text{ L }; ConsoleText << Console{ text, 12 }; } if (number == -1 and ShowErrors) { auto text{ L }; ConsoleText << Console{ text, 12 }; } if (number == -2 and ShowErrors) { auto text{ L }; ConsoleText << Console{ text, 6 }; } if (!message.empty() and ShowErrors and number > 0) { wstring text{ message == L ? L : L }; ConsoleText << Console{ text, 15 }; if (number < GlobalMax) text = L + Cript(number) + L; else text = L; ConsoleText << Console{ text, 2 }; } if (number > 0) { auto text{ L }; ConsoleText << Console{ text, 15 }; ConsoleText << Console{ to_wstring(number) + L, 4 }; } } static void LongComputation (wstring ToEvaluate, wstring message, bool ShowErrors, bool NecBoundary) { computing = true; interrupted = false; auto backup{ ToEvaluate }; int counter{}; tensor<size_t> pos; for (size_t i = 0; i < ToEvaluate.size(); ++i) if (ToEvaluate.at(i) == L) { pos << i; counter++; } if (counter == 0) { CodeConverter(ToEvaluate, message, ShowErrors, NecBoundary); ConsoleText.log(); } else for (size_t i = 0; i < intpow(10, counter); ++i) { { lock_guard<mutex> lock(mtx); if (GlobalInterr) break; } thread comp_thread([&]() { auto j{ to_wstring(i) }; backup = ToEvaluate; int ZerosCount = counter - j.size(); for (int k = 0; k < ZerosCount; ++k) j = L + j; for (size_t k = 0; k < j.size(); ++k) backup.replace(pos[k], 1, wstring(1, j.at(k))); if (NecBoundary) UpdateString(backup); message = NumberCodeSyntax(backup); { lock_guard<mutex> lock(mtx); if (message.size() > 1 and ShowErrors) { auto text{ L + backup + L }; ConsoleText << Console{ text , 11 }; text = L + message + L; ConsoleText << Console{ text , 4 }; } else CodeConverter(backup, message, ShowErrors, false); if (interrupted) return; IsDone = true; cv.notify_one(); } } ); thread output_thread(CS_CornerPrinter); if (comp_thread.joinable()) comp_thread.join(); if (output_thread.joinable()) output_thread.join(); ConsoleText.log(); { lock_guard<mutex> lock(mtx); if (GlobalInterr) break; } } Cv.notify_all(); computing = false; interrupted = true; } static factor<big> GetMonomials(wstring pol) { factor<big> out; if (pol.empty()) return {}; if (!issign(pol.at(0))) pol = L + pol; for (ptrdiff_t i = pol.size() - 1; i >= 0; --i) if (issign(pol.at(i))) { auto part{ pol }; pol.erase(i); part.erase(0, i); big Numerator = LCM; if (part.find(L) != wstring::npos) { auto Denominator{ part }; Denominator.erase(0, part.find(L)); Numerator /= Denominator; } monomial<big> mono{ 1, tensor<int>(Variables.size(), 0) }; if (part.at(0) == L) mono.coefficient = -1; part.erase(0, 1); wstring coeff; while (isdigit(part.at(0))) { coeff += part.at(0); part.erase(0, 1); if (part.empty()) break; } big Coeff; for (size_t j = 0; j < coeff.size(); ++j) { Coeff += coeff.at(j) - ; if (j < coeff.size() - 1) Coeff *= 10; } if (coeff.empty()) Coeff = 1; if (mono.coefficient < 0) Coeff.invert(); mono.coefficient = Coeff * Numerator; if (part.empty()) { out << mono; continue; } for (ptrdiff_t j = 0; j < part.size(); ++j) if (isalpha(part.at(j))) { size_t VariableIndex{}; for (size_t k = 0; k < Variables.size(); ++k) if (Variables.at(k) == part.at(j)) { VariableIndex = k; break; } int degree{ 1 }; if (j < (ptrdiff_t)part.size() - 2) if (part.at(j + 1) == L and isdigit(part.at(j + 2))) { degree = part.at(j + 2) - L; if (j < (ptrdiff_t)part.size() - 3) if (isdigit(part.at(j + 3))) degree = 10 * degree + part.at(j + 3) - L; } mono.exp[VariableIndex] = degree; } out << mono; } return out; } static polynomial<big> GetMonomialsRedirector(wstring pol) { auto copy{ pol }; if (copy.size() >= 2) { if (copy.at(0) == L) copy.erase(0, 1); if (Last(copy) == L) copy.pop_back(); } if (copy.find(L) == wstring::npos and copy.find(L) == wstring::npos) return polynomial<big>{ PolynomialSum<big>(GetMonomials(copy)) }; int ParenthesisBalance{}; for (const auto& c : copy) { switch (c) { case L: ParenthesisBalance++; break; case L: ParenthesisBalance--; break; } if (ParenthesisBalance < 0) break; } if (ParenthesisBalance == 0) pol = copy; auto fact{ FractPolynomial(pol) }; tensor<int> null(Variables.size(), 0); tensor<polynomial<big>> Union; for (const auto& adder : fact) { polynomial<big> UnionElement(adder.size()); tensor<long double> ExpPos, ExpVal; for (size_t i = 0; i < adder; ++i) { if (adder[i].at(0) == L) { int value{ adder[i].at(1) - L }; if (adder[i].size() > 2) value = 10 * value + adder[i].at(2) - L; ExpPos << i; ExpVal << value; } else UnionElement[i] = PolynomialMultiply<big>(GetMonomialsRedirector(adder[i])); } for (size_t i = 0; i < ExpPos; ++i) UnionElement[ExpPos[i]] = { { ExpVal[i], {-1} } }; Union << UnionElement; } for (size_t i = 0; i < Union; ++i) for (size_t j = 0; j < Union[i]; ++j) { for (size_t k = 0; k < Union[i][j]; ++k) Union[i][j][k].exp(Variables.size(), 0); Union[i][j] = PolynomialSum(Union[i][j]); } size_t sizemax{}; for (auto P : Union) if (P > sizemax) sizemax = P.size(); for (auto& P : Union) { big NewLcm = LCM ^ int(sizemax - P.size()); for (auto& mon : P[0]) mon.coefficient *= NewLcm; } tensor<big> numbers; for (size_t i = 0; i < Union; ++i) { Union[i].open(); int sign{ 1 }; for (size_t j = 0; j < Union[i]; ++j) { Union[i][j].SortByExponents(); if (Union[i][j][0].coefficient < 0) { sign *= -1; for (size_t k = 0; k < Union[i][j]; ++k) Union[i][j][k].coefficient.invert(); } } big Coeff = sign; for (ptrdiff_t j = Union[i].size() - 1; j >= 0; --j) if (Union[i][j] == 1) { bool IsACoefficient{ true }; for (size_t k = 0; k < Variables.size(); ++k) if (Union[i][j][0].exp[k] != 0) IsACoefficient = false; if (IsACoefficient) { Coeff *= Union[i][j][0].coefficient; Union[i].erase(Union[i].begin() + j); } } Union[i] >> factor<big>{ { Coeff, null } }; numbers << Coeff; } auto gcd{ Gcd(numbers).fabs() }; if (gcd == 0) return polynomial<big>{ { { 0, null } } }; if (gcd != 1) for (size_t i = 0; i < Union; ++i) Union[i][0][0].coefficient /= gcd; auto ListCommonFactors{ Union[0] }; --ListCommonFactors; for (ptrdiff_t i = ListCommonFactors.size() - 1; i >= 0; --i) { bool IsCommon{ true }; for (size_t j = 1; j < Union; ++j) { ool common{ false }; for (size_t k = 0; k < Union[j]; ++k) if (ListCommonFactors[i] == Union[j][k]) common = true; if (!common) { IsCommon = false; break; } } if (!IsCommon) ListCommonFactors.erase(ListCommonFactors.begin() + i); else for (size_t j = 0; j < Union; ++j) for (ptrdiff_t k = Union[j].size() - 1; k >= 0; --k) if (Union[j][k] == ListCommonFactors[i]) { Union[j].erase(Union[j].begin() + k); break; } } ListCommonFactors >> factor<big>{ { gcd, null } }; tensor<factor<big>> products; for (const auto& Adder : Union) products << PolynomialMultiply<big>(Adder); factor<big> Sum; for (const auto& product : products) Sum += product; ListCommonFactors << PolynomialSum(Sum); if (ListCommonFactors.last() == factor<big>{ { 1, null } }) ListCommonFactors--; for (size_t i = 0; i < ListCommonFactors; ++i) if (ListCommonFactors[i] == 1) if (ListCommonFactors[i][0].coefficient < 0) { ListCommonFactors[i][0].coefficient.invert(); ListCommonFactors[0][0].coefficient.invert(); } if (ListCommonFactors[0] == factor<big>{ { 1, null } } and ListCommonFactors > 1) --ListCommonFactors; else if (ListCommonFactors[0] == factor<big>{ { -1, null } } and ListCommonFactors > 1) { --ListCommonFactors; for (size_t i = 0; i < ListCommonFactors[0]; ++i) ListCommonFactors[0][i].coefficient.invert(); } if (ListCommonFactors.last() == factor<big>{ { 1, null } } and ListCommonFactors > 1) ListCommonFactors--; big GeneralCoeff = 1; for (ptrdiff_t i = ListCommonFactors.size() - 1; i >= 0; --i) if (ListCommonFactors[i] == 1 and ListCommonFactors[i][0].exp == null) { GeneralCoeff *= ListCommonFactors[i][0].coefficient; ListCommonFactors.erase(ListCommonFactors.begin() + i); } ListCommonFactors >> factor<big>{ { GeneralCoeff, null } }; LCM ^= (int)sizemax; ListCommonFactors.close(); return ListCommonFactors; } static polynomial<big> GetMonomialsAssister(wstring pol) { for (ptrdiff_t index = pol.size() - 2; index > 0; --index) if (pol.at(index) == L and pol.at(index - 1) != and pol.at(index + 1) != ) { bool AssignedStart{ false }, AssignedEnd{ false }; ptrdiff_t startIndex{}, endIndex = pol.size() - 1; int StartBalance{}, EndBalance{}; for (ptrdiff_t i = index - 1; i >= 0; --i) { if (pol.at(i) == ) StartBalance--; if (pol.at(i) == ) StartBalance++; if (issign(pol.at(i)) or StartBalance == 1) { startIndex = i; AssignedStart = true; break; } } for (size_t i = index + 1; i < pol.size() - 1; ++i) { if (pol.at(i) == ) EndBalance--; if (pol.at(i) == ) EndBalance++; if (issign(pol.at(i)) or EndBalance == 1) { endIndex = i; AssignedEnd = true; break; } } wstring start{ pol }, first{ pol }, Last{ pol }, end{ pol }; if (AssignedEnd) end.erase(0, endIndex + (pol.at(endIndex) == L)); else end.clear(); if (AssignedStart) start.erase(startIndex + (pol.at(startIndex) != L)); else start.clear(); if (AssignedEnd) Last.erase(endIndex); Last.erase(0, index + 1); first.erase(index); if (AssignedStart) first.erase(0, startIndex + 1); pol = start + L + first + L + Last + L + end; } for (ptrdiff_t i = pol.size() - 1; i >= 0; --i) if (pol.at(i) == L) pol.erase(i, 1); Variables.clear(); for (const auto& c : pol) if (isalpha(c)) { bool IsTheVariableSet{ false }; for (const auto& Variable : Variables) if (Variable == c) IsTheVariableSet = true; if (!IsTheVariableSet) Variables += c; } if (Variables.empty()) Variables = L; LCM = 1; for (size_t i = 0; i < pol.size(); ++i) if (pol.at(i) == L) { auto bigger{ pol }; int J{ -1 }; if (i < bigger.size() - 2) for (size_t j = i; j < bigger.size(); ++j) { auto ch{ bigger.at(j) }; if (issign(ch) or ch == L or ch == L) { J = j; break; } } if (J >= 0) bigger.erase(J); bigger.erase(0, i + 1); big second = bigger; LCM = (LCM * second).fabs() / Gcd(LCM, second); } return GetMonomialsRedirector(pol); } template<typename T> T ObjectOperations (wstring& errcode, tensor<T> list, tensor<wstring> ops, wstring disposition) { if (list.empty()) { errcode = L; return T(); } auto shape{ list[0] }; if (disposition.empty()) { for (size_t i = 0; i < ops; ++i) disposition += ops[i] + L; if (disposition.empty()) { errcode = L; return T(); } if (ops.size() != list.size()) disposition.pop_back(); } bool stay{ true }; int TemporaryBalance{}; for (size_t i = 0; i < disposition.size(); ++i) switch (disposition.at(i)) { case L: TemporaryBalance++; break; case L: TemporaryBalance--; break; } if (TemporaryBalance < 0) { errcode = L; return T(); } if (TemporaryBalance > 0) disposition += wstring(TemporaryBalance, L); int occurrences{}; for (const auto& ch : disposition) { if (ch == L) occurrences++; if (occurrences > 1) { errcode = L; return T(); } } if (occurrences > 0) { auto position{ disposition.find(L) }; disposition.erase(position, 1); disposition.insert(disposition.begin() + position, L); disposition.insert(disposition.begin() + position, L); disposition += L; } if (!disposition.empty()) { if (disposition.at(0) == L) { errcode = L; return T(); } if (Last(disposition) == L) { errcode = L; return T(); } } for (ptrdiff_t i = 1; i < (ptrdiff_t)disposition.size() - 1; ++i) { if (disposition.at(i) == L) { if (disposition.at(i - 1) != L) { errcode = L; return T(); } int exp = disposition.at(i + 1) - L, balance{}; ptrdiff_t I{ -1 }; for (ptrdiff_t j = i - 1; j >= 0; --j) { switch (disposition.at(j)) { case L: balance--; break; case L: balance++; break; } if (balance == 0) { I = j; break; } } if (I < 0) { errcode = L; return T(); } if (i - I <= 2) { errcode = L; return T(); } bool StopUpdatingFirst{ false }; size_t FirstPointer{}, LastPointer{}; for (size_t j = 0; j < i - 1; ++j) { if (disposition.at(j) != L) continue; tPointer++; if (StopUpdatingFirst) continue; FirstPointer++; if (j > I) StopUpdatingFirst = true; } FirstPointer--; LastPointer--; disposition.erase(i, 2); i--;  (exp == 0) { disposition.erase(I, i - I + 1); disposition.insert(disposition.begin() + I, L); list.erase(FirstPointer, LastPointer - FirstPointer + 1); list.insert(list.begin() + FirstPointer, EmptyProduct<T>(shape)); i = I; continue; } if (exp == 1) continue; auto StringRepeater{ disposition.substr(I, i - I + 1) }; tensor<T> TensorRepeater( list.begin() + FirstPointer, list.begin() + LastPointer + 1 ); size_t StrIndex = i + 1, TnsIndex{ LastPointer + 1 }; for (int j = 0; j < exp - 1; ++j) { for (size_t k = 0; k < StringRepeater.size(); ++k) disposition.insert( disposition.begin() + StrIndex, StringRepeater.at(StringRepeater.size() - k - 1) );  (size_t k = 0; k < TensorRepeater.size(); ++k) list.insert( list.begin() + TnsIndex, TensorRepeater.at(TensorRepeater.size() - k - 1) ); StrIndex += StringRepeater.size(); TnsIndex += TensorRepeater.size(); } i = StrIndex - 1; } } for (;;) { int Apostrophes{}, apostrophes{}; T final; wstring part; if (disposition.find(L) == wstring::npos and disposition.find(L) == wstring::npos) stay = false; bool Break{ false }; int balance{}, start{ -1 }, end = disposition.size(); if (stay) for (size_t i = 0; i < disposition.size(); ++i) { switch (disposition.at(i)) { case L: apostrophes = Apostrophes; start = i; balance++; break; case L: if (balance == 0) { errcode = L; return T(); } end = i; Break = true; break; case L: Apostrophes++; } if (Break) { part = disposition.substr(start + 1, end - start - 1); break; } } else part = disposition; if (start + 1 == end) { errcode = L; return T(); } if (Last(part) != L) { errcode = L; return T(); } if (part.at(0) == L or part.at(0) == L) { errcode = L; return T(); } if (part.at(0) == L) part = L + part; for (size_t i = 1; i < part.size(); ++i) if (part.at(i - 1) != L and part.at(i) != L) { errcode = L; return T(); } int LocalApostrophes{ apostrophes - 1 }; for (ptrdiff_t i = part.size() - 1; i >= 0; --i) switch (part.at(i)) { case L: part.erase(i, 1); break; case L: LocalApostrophes++; } auto local_apostrophes{ LocalApostrophes }; for (ptrdiff_t i = part.size() - 1; i >= 0; --i) switch (part.at(i)) { case L: part.erase(i, 1); list[local_apostrophes + 1] = list[local_apostrophes + 1].invert(); if (isnan(list[local_apostrophes + 1])) { errcode = L; return T(); } break; case L: local_apostrophes--; } local_apostrophes = LocalApostrophes + 1; for (ptrdiff_t i = part.size() - 1; i >= 0; --i) switch (part.at(i)) { case L: { part.at(i) = L; auto& obj{ list[local_apostrophes] }; obj = T() - obj; break; } case L: local_apostrophes--; } tensor<tensor<T>> AddAndMultiply; tensor<T> Add; auto index{ apostrophes }; for (size_t i = 0; i < part.size(); ++i) switch (part.at(i)) { case L: AddAndMultiply << tensor<T>{}; break; case L: AddAndMultiply.last() << list[index++]; } for (auto& Multiply : AddAndMultiply) { if (Multiply.empty()) continue; auto product{ Multiply[0] }; for (size_t i = 1; i < Multiply; ++i) product *= Multiply[i]; Add << product; } final = Add[0]; for (size_t i = 1; i < Add; ++i) final += Add[i]; if (disposition.find(L) != wstring::npos or disposition.find(L) != wstring::npos) { disposition.erase(start, end - start + 1); disposition.insert(disposition.begin() + start, L); } list.erase( (size_t)apostrophes, size_t(LocalApostrophes - apostrophes + 1) ); list.insert(list.begin() + apostrophes, final); if (!stay) { errcode.clear(); return final; } } } static tensor<tensor<long double>> FromPolynomialToPos( factor<> vect, int& StartIndex, tensor<int>& CorrectSizes, tensor<int>& VDirectorTerm, tensor<int>& VKnownTerm, tensor<tensor<int>>& VDirectorSeq, tensor<tensor<int>>& VKnownSeq ) { vect.SortByExponents(); tensor<int> null(Variables.size(), 0); auto DirectorDegSequence{ vect[0].exp }; auto KnownDegSequence{ vect.last().exp }; StartIndex = 0; for (size_t i = 0; i < Variables.size(); ++i) if (DirectorDegSequence[i] > 0 and KnownDegSequence[i] > 0) return {}; for (ptrdiff_t i = Variables.size() - 1; i >= 0; --i) if (DirectorDegSequence[i] > 0 or KnownDegSequence[i] > 0) StartIndex = i; int Size{ Gcd(vect[0].exp + vect.last().exp) }; auto listSizes{ DivisorCounter(Size) }; for (const auto& size : listSizes) { bool keep{ false }; if (size + 1 < vect) continue; auto DirectorSeq{ DirectorDegSequence }; auto KnownSeq{ KnownDegSequence }; for (size_t i = 0; i < Variables.size(); ++i) { DirectorSeq[i] /= size; KnownSeq[i] /= size; } for (size_t i = 1; i + 1 < vect; ++i) { double Dquot{ -1 }, Kquot{ -1 }; for (size_t j = 0; j < Variables.size(); ++j) { double vexp = vect[i].exp[j]; if (!DirectorSeq[j] and !KnownSeq[j] and vexp) return {}; bool primary = DirectorSeq[j]; double quot = primary ? vexp / DirectorSeq[j] : vexp / KnownSeq[j]; if (!integer(quot)) { keep = true; break; } if (primary) { if (Dquot == -1) Dquot = quot; else if (Dquot != quot) keep = true; } else { if (Kquot == -1) Kquot = quot; else if (Kquot != quot) keep = true; } } if (keep) break; } if (keep) continue; if (size > 1) CorrectSizes << size; } tensor<tensor<long double>> result; for (const auto& CorrectSize : CorrectSizes) { auto DirectorSeq{ DirectorDegSequence }; auto KnownSeq{ KnownDegSequence }; for (size_t i = StartIndex; i < Variables.size(); ++i) { DirectorSeq[i] /= CorrectSize; KnownSeq[i] /= CorrectSize; } int DirectorTerm = vect[0].coefficient; int KnownTerm = vect.last().coefficient; if (abs(DirectorTerm) >= GlobalMax or abs(KnownTerm) >= GlobalMax) continue; int KnVarPos{ -1 }; tensor<long double> position(CorrectSize + 1, 0); for (size_t i = StartIndex; i < Variables.size(); ++i) if (KnownSeq[i] > 0) { KnVarPos = i; break; } bool skip{ false }; for (size_t i = 0; i < vect; ++i) { int index; if (KnVarPos >= 0) index = vect[i].exp[KnVarPos] / KnownSeq[KnVarPos]; else index = CorrectSize - vect[i].exp[StartIndex] / DirectorSeq[StartIndex]; if (index < 0) { skip = true; break; } position[index] = vect[i].coefficient; } if (skip) continue; result << position; VDirectorTerm << DirectorTerm; VKnownTerm << KnownTerm; VDirectorSeq << DirectorSeq; VKnownSeq << KnownSeq; } for (size_t i = 0; i < result; ++i) for (size_t j = i + 1; j < result; ++j) if (result[i] < result[j]) { swap(result[i], result[j]); swap(CorrectSizes[i], CorrectSizes[j]); swap(VDirectorTerm[i], VDirectorTerm[j]); swap(VKnownTerm[i], VKnownTerm[j]); swap(VDirectorSeq[i], VDirectorSeq[j]); swap(VKnownSeq[i], VKnownSeq[j]); } return result; } template<typename T_int = long double> static factor<T_int> PolynomialSum(factor<T_int> vect) { int ImgUnitPos = Variables.find(L); if (ImgUnitPos != wstring::npos) for (auto& mon : vect) { mon.exp[ImgUnitPos] %= 4; if (mon.exp[ImgUnitPos] > 1) { mon.coefficient *= -1; mon.exp[ImgUnitPos] -= 2; } } for (ptrdiff_t i = vect.size() - 1; i >= 0; --i) for (ptrdiff_t j = i - 1; j >= 0; --j) if (vect[i].exp[0] >= 0 and vect[j].exp[0] >= 0) { bool AreTheMonomialsSimiliar{ true }; for (int k = 0; k < Variables.size(); ++k) if (vect[i].exp[k] != vect[j].exp[k]) AreTheMonomialsSimiliar = false; if (AreTheMonomialsSimiliar) { vect[i].coefficient += vect[j].coefficient; vect[j].coefficient = 0; } } for (ptrdiff_t i = vect.size() - 1; i >= 0; --i) if (vect[i].coefficient == 0) vect[i].exp.clear(); auto it = remove(vect.begin(), vect.end(), monomial<T_int>{ 0, {} }); vect.erase(it, vect.end()); if (vect.empty()) return factor<T_int>{ { 0, tensor<int>(Variables.size(), 0) } }; return vect; } template<typename T_int = long double> static factor<T_int> PolynomialMultiply(polynomial<T_int> Polynomial) { bool Empty{ Polynomial.empty() }; if (!Empty) for (const auto& term : Polynomial) if (term.empty()) { Empty = true; break; } if (Empty) return { { 1, tensor<int>(Variables.size(), 0) } }; Polynomial.open(); while (Polynomial > 1) { factor<T_int> Temp; monomial<T_int> temp; for (auto A : Polynomial[0]) for (auto B : Polynomial[1]) { temp.coefficient = A.coefficient * B.coefficient; temp.exp.clear(); for (size_t i = 0; i < Variables.size(); ++i) temp.exp << A.exp[i] + B.exp[i]; Temp << temp; } --(--Polynomial); Polynomial >> Temp; } return PolynomialSum(Polynomial[0]); } static void PolynomialDivide ( FACTOR<> dividend, FACTOR<> divisor, FACTOR<>& quotient, FACTOR<>& rest ) { dividend.sort(); divisor.sort(); dividend.complete(dividend[0].degree); divisor.complete(divisor[0].degree); dividend.sort(); divisor.sort(); quotient.clear(); while (dividend[0].degree >= divisor[0].degree) { auto divide{ divisor }; int deg = dividend[0].degree, _deg = divisor[0].degree; long double rest_element{ dividend[0].coefficient }; rest_element /= divisor[0].coefficient; CORRECTION_RATIO *= divisor[0].coefficient; for (size_t i = 0; i < divide; ++i) { divide[i].coefficient *= -rest_element; divide[i].degree += deg - _deg; } dividend = dividend - divide.neg(); dividend.complete(deg); dividend.sort(); quotient << MONOMIAL<>{ deg - _deg, rest_element }; } rest = dividend; for (size_t i = 0; i < quotient; ++i) quotient[i].coefficient *= CORRECTION_RATIO; for (size_t i = 0; i < rest; ++i) rest[i].coefficient *= CORRECTION_RATIO; int gcd{ abs(Gcd(quotient + rest)) }; for (size_t i = 0; i < quotient; ++i) quotient[i].coefficient /= gcd; for (size_t i = 0; i < rest; ++i) rest[i].coefficient /= gcd; } static polynomial<> Total(factor<> vect) { polynomial<> output; output << vect; if (vect <= 1) return output; bool positive_min{ false }; int GCD{ Gcd(vect) }; tensor<int> exponents; for (size_t i = 0; i < Variables.size(); ++i) { int min{ vect[0].exp[i] }; for (const auto& t : vect) if (t.exp[i] < min) min = t.exp[i]; exponents << min; if (min > 0) positive_min = 1; } if (abs(GCD) != 1 or positive_min) { output.clear(); output << factor<>{ { (long double)GCD, exponents } }; for (size_t i = 0; i < vect; ++i) { vect[i].coefficient /= GCD; for (size_t j = 0; j < Variables.size(); ++j) vect[i].exp[j] -= exponents[j]; } } if (abs(GCD) != 1 or positive_min) { output.clear(); output << factor<>{ { (long double)GCD, exponents } } << vect; return output; } return { vect }; } static polynomial<> Partial(factor<> vect) { polynomial<> outp; outp << vect; if (vect != 4) return outp; tensor<int> null(Variables.size(), 0); factor<> part_1{ vect[0], vect[1] }, part_2{ vect[2], vect[3] }; auto Part1{ Total(part_1) }; auto Part2{ Total(part_2) }; if ((Part1.last() - Part2.last().neg()).empty()) { if (Part1 == 1) swap(Part1, Part2); Part2 >> factor<>{ { -1, null } }; Part2[1] = Part2[1].neg(); } part_1 = Part1.last(); part_2 = Part2.last(); if (part_1 != part_2) return outp; outp.clear(); polynomial<> mon_1, mon_2; if (Part1 == 1) mon_1 << factor<>{ { 1, null } }; else mon_1 << Part1[0]; if (Part2 == 1) mon_2 << factor<>{ { 1, null } }; else mon_2 << Part2[0]; mon_1 << part_1; mon_2 << part_2; part_1.SortByExponents(); part_2 = mon_1[0] - mon_2[0].neg(); part_2.SortByExponents(); outp << part_1 << part_2; return outp; } static polynomial<> Binomial(factor<> vect) { polynomial<> outp; outp << vect; int exponent = vect.size() - 1, sign{ 1 }; if (exponent <= 1) return outp; bool reassigne{ false }; vect.SortByDegree(); tensor<int> modifier(Variables.size(), 0); modifier[0] = -1; auto A{ vect[0] }; auto B{ vect.last() }; if (exponent % 2 == 0 and (A.coefficient < 0 or B.coefficient < 0)) return outp; double Sq_A, Sq_B; if (A.coefficient > 0) Sq_A = pow(A.coefficient, 1.0 / exponent); else Sq_A = -pow(-A.coefficient, 1.0 / exponent); if (B.coefficient > 0) Sq_B = pow(B.coefficient, 1.0 / exponent); else Sq_B = -pow(-B.coefficient, 1.0 / exponent); if (!integer(Sq_A)) return outp; if (!integer(Sq_B)) return outp; for (size_t i = 0; i < Variables.size(); ++i) if (A.exp[i] % exponent != 0) return outp; for (size_t i = 0; i < Variables.size(); ++i) if (B.exp[i] % exponent != 0) return outp; auto Aexps{ A.exp }; auto Bexps{ B.exp }; for (size_t i = 0; i < Variables.size(); ++i) { Aexps[i] /= exponent; Bexps[i] /= exponent; } for (size_t i = 1; i < exponent; ++i) { for (size_t j = 0; j < Variables.size(); ++j) if (vect[i].exp[j] != Aexps[j] * (exponent - i) + Bexps[j] * i) return outp; int coeff = BinomialCoeff(exponent, i); if (vect[i].coefficient == -coeff * (int)pow(Sq_A, exponent - i) * (int)pow(Sq_B, i) ) { if (!reassigne) { sign = -1; reassigne = 1; } else if (sign == 1) return outp; } else if (vect[i].coefficient == coeff * (int)pow(Sq_A, exponent - i) * (int)pow(Sq_B, i) ) { if (!reassigne) { sign = 1; reassigne = 1; } else if (sign == -1) return outp; } else return outp; } outp.clear(); outp << factor<>{ { (long double)exponent, modifier } }; outp++; outp[1] << monomial<>{ Sq_A, Aexps } << monomial<>{ sign * Sq_B, Bexps }; return outp; } static polynomial<> Trinomial(factor<> vect) { polynomial<> outp; outp << vect; if (vect != 3) return outp; vect.SortByDegree(); int A, B, C; for (size_t i = 0; i < Variables.size(); ++i) if (vect[0].exp[i] % 2 == 1 or vect[2].exp[i] % 2 == 1) return outp; auto Aexps{ vect[0].exp }; auto Cexps{ vect[2].exp }; for (size_t i = 0; i < Variables.size(); ++i) { if (2 * vect[1].exp[i] != vect[0].exp[i] + vect[2].exp[i]) return outp; Aexps[i] /= 2; Cexps[i] /= 2; } A = vect[0].coefficient; B = vect[1].coefficient; C = vect[2].coefficient; double firstX, secondX, delta; delta = B * B - 4 * A * C; if (delta <= 0) return outp; if (!integer(sqrt(delta))) return outp; firstX = (-B - sqrt(delta)) / (2 * A); secondX = (-B + sqrt(delta)) / (2 * A); if (!integer(A * firstX * secondX)) return outp; outp.clear(); int I, J; for (I = 1; I <= abs(A); ++I) if (integer(firstX * I)) break; if (I == abs(A) + 1) I--; if (A < 0) I *= -1; for (J = 1; J <= abs(A); ++J) if (integer(secondX * J)) break; if (J == abs(A) + 1) J--; outp = { {}, {} }; outp[0] << monomial<>{ -I * firstX, Cexps }; outp[0] << monomial<>{ (long double)I, Aexps }; outp[1] << monomial<>{ -J * secondX, Cexps }; outp[1] << monomial<>{ (long double)J, Aexps }; outp[0].SortByExponents(); outp[1].SortByExponents(); return outp; } static polynomial<> SquareDifference(factor<> vect) { polynomial<> outp; outp << vect; if (vect != 2) return outp; if (!vect[0].IsSquare()) return outp; if (!vect[1].IsSquare()) return outp; bool Sign_A{ vect[0].coefficient > 0 }; bool Sign_B{ vect[1].coefficient > 0 }; if (Sign_A == Sign_B) return outp; auto Aexps{ vect[0].exp }; auto Bexps{ vect[1].exp }; for (size_t i = 0; i < Variables.size(); ++i) { Aexps[i] /= 2; Bexps[i] /= 2; } outp = { {}, {} }; outp[0] << monomial<>{ +sqrt(fabs(vect[1].coefficient)), Bexps }; outp[0] << monomial<>{ +sqrt(fabs(vect[0].coefficient)), Aexps }; outp[1] << monomial<>{ +sqrt(fabs(vect[1].coefficient)), Bexps }; outp[1] << monomial<>{ -sqrt(fabs(vect[0].coefficient)), Aexps }; if (Sign_A) { outp[1][0].coefficient *= -1; outp[1][1].coefficient *= -1; } return outp; } static polynomial<> Ruffini(factor<> vect) { polynomial<> output; output << vect; if (vect < 2) return output; vect.SortByExponents(); tensor<int> null(Variables.size(), 0); int StartIndex; tensor<int> CorrectSizes; tensor<int> VDirectorTerm; tensor<int> VKnownTerm; tensor<tensor<int>> VDirectorSeq; tensor<tensor<int>> VKnownSeq; auto ListPos{ FromPolynomialToPos( vect, StartIndex, CorrectSizes, VDirectorTerm, VKnownTerm, VDirectorSeq, VKnownSeq ) }; for (size_t i = 0; i < ListPos; ++i) { auto position{ ListPos[i] }; auto DirectorTerm{ VDirectorTerm[i] }; auto KnownTerm{ VKnownTerm[i] }; auto DirectorSeq{ VDirectorSeq[i] }; auto KnownSeq{ VKnownSeq[i] }; auto CorrectSize{ CorrectSizes[i] }; auto P{ DivisorCounter(abs(KnownTerm)) }; auto Q{ DivisorCounter(abs(DirectorTerm)) }; tensor<int> PossibleRoots; for (auto p : P) for (auto q : Q) PossibleRoots.push_back(p / q); for (ptrdiff_t j = PossibleRoots.size() - 1; j >= 0; --j) for (ptrdiff_t k = j - 1; k >= 0 and j < PossibleRoots; --k) if (PossibleRoots[j] == PossibleRoots[k]) PossibleRoots.erase(PossibleRoots.begin() + j); int SetRoot{}, Root; for (int n = 1; n < CorrectSize; ++n) { tensor<long double> temp; for (const auto& root : PossibleRoots) { Root = root; do { temp = position; for (size_t j = 1; j < position; ++j) temp[j] = Root * temp[j - 1] + temp[j]; if (temp.last() == 0) { temp--; SetRoot = Root; position = temp; break; } Root *= -1; } while (Root != root); if (SetRoot != 0) break; } if (SetRoot != 0) { output.clear(); output++; output[0] << monomial<>{ 1, DirectorSeq }; output[0] << monomial<>{ -(long double)SetRoot, KnownSeq }; output++; for (int j = 0; j < CorrectSize; ++j) { if (position[CorrectSize - 1 - j] == 0) continue; tensor<int> VariableExp(Variables.size(), 0); size_t index{ Variables.size() }; if (DirectorSeq[StartIndex] == 0) swap(DirectorSeq, KnownSeq); for (size_t k = StartIndex; k < Variables.size(); ++k) { if (DirectorSeq[k] == 0) { index = k; break; } VariableExp[k] = j * DirectorSeq[k]; } for (size_t k = index; k < Variables.size(); ++k) VariableExp[k] = (CorrectSize - 1 - j) * KnownSeq[k]; output[1] << monomial<>{ (long double)position[CorrectSize - j - 1], VariableExp }; } output[1].SortByExponents(); return output; } } } return { vect }; } static polynomial<> CompleteTheSquare(factor<> vect) { polynomial<> outp; outp << vect; if (vect != 3) return outp; vect.SortByDegree(); auto A{ vect[0] }; auto B{ vect[2] }; if (A.coefficient < 0 or B.coefficient < 0) return outp; double Sq_A = sqrt(A.coefficient); double Sq_B = sqrt(B.coefficient); if (!A.IsSquare()) return outp; if (!B.IsSquare()) return outp; for (size_t i = 0; i < Variables.size(); ++i) if (A.exp[i] % 4 != 0) return outp; for (size_t i = 0; i < Variables.size(); ++i) { if (vect[1].exp[i] != A.exp[i] / 2 + B.exp[i] / 2) return outp; if (!integer(A.exp[i] / 4 + B.exp[i] / 4)) return outp; } monomial<> DiffSquare, Diffneg; for (size_t i = 0; i < Variables.size(); ++i) DiffSquare.exp << A.exp[i] / 4 + B.exp[i] / 4; int middleterm{ 2 * (int)Sq_A * (int)Sq_B }, sign; int CasePlus = middleterm - vect[1].coefficient; int CaseMinus = -middleterm - vect[1].coefficient; if (CasePlus > 0 and integer(sqrt(CasePlus))) { DiffSquare.coefficient = sqrt(CasePlus); sign = 1; } else if (CaseMinus > 0 and integer(sqrt(CaseMinus))) { DiffSquare.coefficient = sqrt(CaseMinus); sign = -1; } else return outp; Diffneg.coefficient = -DiffSquare.coefficient; Diffneg.exp = DiffSquare.exp; for (size_t i = 0; i < Variables.size(); ++i) { A.exp[i] /= 2; B.exp[i] /= 2; } outp << vect; outp[0].clear(); outp[1].clear(); outp[0] << monomial<>{ Sq_A, A.exp } << DiffSquare << monomial<>{ Sq_B, B.exp }; outp[1] << monomial<>{ Sq_A, A.exp } << Diffneg << monomial<>{ Sq_B, B.exp }; return outp; } static polynomial<> TrinomialSquare(factor<> vect) { polynomial<> output; output << vect; if (vect != 5 and vect != 6) return output; tensor<int> modifier(Variables.size(), 0); modifier[0] = -1; if (vect == 5) { vect.SortByDegree(); bool AB2, AC2, BC2; long double A{ sqrt(vect[0].coefficient) }; if (!integer(A)) return output; long double C{ sqrt(vect[4].coefficient) }; if (!integer(C)) return output; long double B{ (long double)vect[3].coefficient / (2 * C) }; if (!integer(B)) return output; if (fabs(B) != fabs((double)vect[1].coefficient / (2 * A))) return output; for (size_t i = 0; i < Variables.size(); ++i) for (int j = 0; j < 5; ++j) if (vect[4 - j].exp[i] != j * vect[3].exp[i]) return output; AB2 = vect[1].coefficient < 0; BC2 = vect[3].coefficient < 0; if (fabs(vect[2].coefficient) == fabs(2 * A * C + B * B)) AC2 = vect[2].coefficient - B * B < 0; else if (fabs(vect[2].coefficient) == fabs(2 * A * C - B * B)) AC2 = vect[2].coefficient + B * B < 0; else return output; if (AB2 + AC2 + BC2 > 1) { AB2 = !AB2; AC2 = !AC2; BC2 = !BC2; } A = A >= 0 ? A : -A; B = B >= 0 ? B : -B; C = C >= 0 ? C : -C; if (AB2) C = -C; if (AC2) B = -B; if (BC2) A = -A; output.clear(); output << factor<>{ { 2, modifier } }; output++; output[1] << monomial<>{ A, vect[2].exp }; output[1] << monomial<>{ B, vect[3].exp }; output[1] << monomial<>{ C, vect[4].exp }; } else if (vect == 6) { factor<> squares; for (int i = 0; i < 6; ++i) if (vect[i].IsSquare()) squares << vect[i]; if (squares < 3) return output; tensor<int> _pos{ 1, 2, 2 }; int IndexAccesser{ 2 }; monomial<> A, B, C; bool AB2{ true }, AC2{ true }, BC2{ true }; while (IndexAccesser >= 0) { A = {}; B = {}; C = {}; auto backup{ _pos }; for (int i = IndexAccesser; i < 3; ++i) backup[i]++; if (backup.last() > squares) { IndexAccesser--; continue; } IndexAccesser = 2; _pos = backup; factor<> NewSquares(3); for (int i = 0; i < 3; ++i) NewSquares[i] = squares[_pos[i] - 1]; A = NewSquares[0].Root(2); B = NewSquares[1].Root(2); C = NewSquares[2].Root(2); monomial<> AB, AC, BC; AB.coefficient = 2 * A.coefficient * B.coefficient; AC.coefficient = 2 * A.coefficient * C.coefficient; BC.coefficient = 2 * B.coefficient * C.coefficient; for (size_t i = 0; i < Variables.size(); ++i) { AB.exp << A.exp[i] + B.exp[i]; AC.exp << A.exp[i] + C.exp[i]; BC.exp << B.exp[i] + C.exp[i]; } monomial<> ABterm, ACterm, BCterm; for (const auto& v : vect) { if (v == AB) ABterm = v; if (v == AC) ACterm = v; if (v == BC) BCterm = v; auto v2{ v }; v2.coefficient *= -1; if (v2 == AB) ABterm = v; if (v2 == AC) ACterm = v; if (v2 == BC) BCterm = v; } if ( ABterm == monomial<>{} or ACterm == monomial<>{} or BCterm == monomial<>{} ) continue; AB2 = ABterm.coefficient >= 0; AC2 = ACterm.coefficient >= 0; BC2 = BCterm.coefficient >= 0; if (AB2 + AC2 + BC2 > 1) { AB2 = !AB2; AC2 = !AC2; BC2 = !BC2; } break; } if (BC2) A.coefficient *= -1; if (AC2) B.coefficient *= -1; if (AB2) C.coefficient *= -1; output.clear(); output << factor<>{ { 2, modifier } }; output++; output[1] << A << B << C; } return output; } static tensor<Fraction<big>> GetManyFractions (tensor<wstring> numerators, tensor<wstring> denominators, wstring& errcode) { if (numerators % denominators) return {}; Variables.clear(); tensor<Fraction<big>> fractions; auto un{ numerators + denominators }; for (auto& str : un) for (const auto& c : str) if (isalpha(c) and Variables.find(c) == wstring::npos) Variables += c; auto savx{ Variables }; tensor<int> null(Variables.size(), 0); for (size_t i = 0; i < un; ++i) { bool isnum{ i % 2 == 0 }; if (isnum) fractions << Fraction<big>{}; auto str = isnum ? numerators[i / 2] : denominators[i / 2]; if (!(errcode = PolynomialSyntaxDirector(str)).empty()) return {}; auto old{ PolynomialMultiply<big>(GetMonomialsAssister(str)) }; if (Variables == savx or savx.empty()) { savx = Variables; isnum ? fractions.last().num = { old } : fractions.last().den = { old }; continue; } for (auto& mon : old) mon.exp(savx.size(), 0); factor<big> correct; for (const auto& mono : old) correct << monomial<big>{ mono.coefficient, null }; for (size_t j = 0; j < Variables.size(); ++j) { auto pos{ savx.find(Variables.at(j)) }; if (pos == wstring::npos) continue; for (size_t k = 0; k < correct; ++k) correct[k].exp[pos] = old[k].exp[j]; } isnum ? fractions.last().num = { correct } : fractions.last().den = { correct }; Variables = savx; } return fractions; } static FACTOR<> Complementary(POLYNOMIAL<> Polynomial, FACTOR<> factor, int exp) { if (Polynomial[0] == factor) --Polynomial; else for (ptrdiff_t i = Polynomial.size() - 1; i > 0 and i < Polynomial; --i) if (Polynomial[i] == factor) { if (Polynomial[i - 1][0].degree >= 0) { Polynomial.erase(Polynomial.begin() + i); break; } if (Polynomial[i - 1][0].coefficient - exp > 1) { Polynomial[i - 1][0].coefficient -= exp; break; } if (Polynomial[i - 1][0].coefficient - exp < 1) { Polynomial.erase(Polynomial.begin() + i); Polynomial.erase(Polynomial.begin() + (i - 1)); break; } Polynomial.erase(Polynomial.begin() + (i - 1)); break; } return V1converter(PolynomialMultiply, Polynomial); } static void Simplify(Fraction<>& fr, int& ncoeff, int& dcoeff) { tensor<int> null(Variables.size(), 0); auto& num{ fr.num }; auto& den{ fr.den }; num.open(); den.open(); for (size_t i = 0; i < num; ++i) num[i].SortByExponents(); for (size_t i = 0; i < den; ++i) den[i].SortByExponents(); int sign{ 1 }; for (ptrdiff_t i = num.size() - 1; i >= 0; --i) { if (num[i] == 1 and num[i][0].exp == null) continue; for (ptrdiff_t j = den.size() - 1; j >= 0; --j) { if (i >= num or j >= den) continue; if (den[j] == 1 and den[j][0].exp == null) continue; if (num[i] == den[j]) { num.erase(num.begin() + i); den.erase(den.begin() + j); continue; } for (size_t k = 0; k < den[j]; ++k) den[j][k].coefficient *= -1; if (num[i] == den[j]) { num.erase(num.begin() + i); den.erase(den.begin() + j); sign = -1; continue; } else for (size_t k = 0; k < den[j]; ++k) den[j][k].coefficient *= -1; if (num[i] == 1 and den[j] == 1) for (size_t k = 0; k < Variables.size(); ++k) { int GradeDelta{ abs(num[i][0].exp[k] - den[j][0].exp[k]) }; if (num[i][0].exp[k] > den[j][0].exp[k]) { num[i][0].exp[k] = GradeDelta; den[j][0].exp[k] = 0; } else { num[i][0].exp[k] = 0; den[j][0].exp[k] = GradeDelta; } } } } int FindN{ -1 }, FindD{ -1 }; for (size_t i = 0; i < num; ++i) if (num[i] == 1) { ncoeff = num[i][0].coefficient * sign; if (num[i][0].exp == null and num != 1 and num[0] != 1) num.erase(num.begin() + i); else FindN = i; break; } for (size_t i = 0; i < den; ++i) if (den[i] == 1) { dcoeff = den[i][0].coefficient; if (den[i][0].exp == null and den != 1 and den[0] != 1) den.erase(den.begin() + i); else FindD = i; break; } int GCD = Gcd(abs(ncoeff), abs(dcoeff)); ncoeff /= GCD; dcoeff /= GCD; if (FindN >= 0) num[FindN][0].coefficient = 1; if (FindD >= 0) den[FindD][0].coefficient = 1; ncoeff *= sign; num.close(); den.close(); for (size_t i = 0; i < num.size(); ++i) if (num[i] == factor<>{ { 1, null } }) num.erase(num.begin() + i); for (size_t i = 0; i < den.size(); ++i) if (den[i] == factor<>{ { 1, null } }) den.erase(den.begin() + i); } static void PrintFraction (int NC, int DC, int& LINE, bool WritePlus, Fraction<> fract) { tensor<int> null(Variables.size(), 0); GetConsoleScreenBufferInfo(hConsole, &csbi)(); auto start{ csbi.dwCursorPosition }; wcout << wstring(10, L); GetConsoleScreenBufferInfo(hConsole, &csbi)(); if (csbi.dwCursorPosition.Y >= start.Y) start.Y -= 10 - csbi.dwCursorPosition.Y + start.Y; SetConsoleCursorPosition(hConsole, start); long double root{}; int I{ 1 }, Root{}; bool IsMinus{ false }; wstring den_, num_; if (fract.num == 1) if (fract.num[0] == 1) if (fract.num[0][0].exp == null) root = fract.num[0][0].coefficient; bool Empty{ fract.num.empty() }, dontreset{ false }; if (Empty) { fract.num = polynomial<>{ { { 1, null } } }; dontreset = true; } else { Empty = true; for (const auto& term : fract.num) if (!term.empty()) { Empty = false; break; } } if (Empty and !dontreset) { NC = 0; fract.num = polynomial<>{ { { 0, null } } }; } if (!(Empty = fract.den.empty())) { Empty = true; for (const auto& term : fract.den) if (!term.empty()) { Empty = false; break; } } if (Empty) fract.den = polynomial<>{ { { 1, null } } }; if (root != 0) { for (;;) { if (integer(I * root)) break; I++; } Root = root * I; DC *= I; if (NC * Root < 0 and DC < 0) { NC = -NC; DC = -DC; } else if (NC * Root < 0) { NC = -NC; IsMinus = true; } else if (DC < 0) { DC = -DC; IsMinus = true; } } bool HasACoefficient{ false }; if (fract.den >= 1) if (fract.den[0] == 1) if (fract.den[0][0].exp == null) HasACoefficient = true; if (HasACoefficient) fract.den[0][0].coefficient *= CORRECTION_RATIO; else fract.den >> factor<>{ monomial<>{ CORRECTION_RATIO, null } }; int gcd = Gcd(NC, DC); NC /= gcd; DC /= gcd; int Gcd{ 1 }; if (root == 0) Gcd = ::Gcd((int)fract.num[0][0].coefficient, (int)fract.den[0][0].coefficient); else Gcd = ::Gcd(Root, fract.den[0][0].coefficient); fract.den[0][0].coefficient /= Gcd; if (root != 0) Root /= Gcd; else fract.num[0][0].coefficient /= Gcd; if (fract.den[0] == 1 and fract.den[0][0] == monomial<>{ 1, null }) --fract.den; else if (fract.den[0][0] == monomial<>{ -1, null }) { --fract.den; if (root == 0) fract.num[0][0].coefficient *= -1; else Root *= -1; } if (root == 0) if (fract.num[0] == 1 and fract.num[0][0] == monomial<>{ 1, null }) --fract.num; if (root != 0) num_ = to_wstring(NC * Root); if (root == 0) { num_ = fract.num.str(); if (num_ == L) num_.clear(); else if (abs(NC) != 1 and (fract.num[0] > 1 and fract.num == 1)) num_ = L + num_ + L; if (abs(NC) != 1) num_ = to_wstring(NC) + num_; if (num_.empty()) num_ = L; if (NC == -1 and (num_.find(L) == wstring::npos and num_.find(L) == wstring::npos) or num_.find(L) != wstring::npos) num_ = L + num_; else if (NC == -1) num_ = L + num_ + L; } den_.clear(); auto tempden{ fract.den.str() }; if (tempden != L) den_ = tempden; if (den_ == L) den_.clear(); else if (abs(DC) != 1 and (fract.den[0] > 1 and fract.den == 1)) den_ = L + den_ + L; if (abs(DC) != 1) den_ = to_wstring(DC) + den_; if (den_.empty()) den_ = L; if (DC == -1 and (den_.find(L) == wstring::npos and den_.find(L) == wstring::npos) and den_.find(L) != wstring::npos) den_ = L + den_; else if (DC == -1) den_ = L + den_ + L; bool both{ true }; if (num_.at(0) == L and den_.at(0) == L and fract.num == 1 and fract.den == 1) if (fract.num[0] == 1 and fract.den[0] == 1) { num_.erase(0, 1); den_.erase(0, 1); both = false; } if (num_.at(0) == L and fract.num == 1 and both) if (fract.num[0] == 1) { num_.erase(0, 1); IsMinus = !IsMinus; both = false; } if (den_.at(0) == L and fract.den == 1 and both) if (fract.den[0] == 1) { den_.erase(0, 1); IsMinus = !IsMinus; } if (NC == 0) { num_ = L; den_ = L; } int sizemax = max(num_.size(), den_.size()); int spacing = num_.size() - den_.size(); spacing = abs(spacing) / 2; if (num_.size() > den_.size()) den_ = wstring(spacing, L) + den_; else num_ = wstring(spacing, L) + num_; if (LINE + spacing + WritePlus * 2 > csbi.dwSize.X) { LINE = 0; start.Y += 4; SetConsoleCursorPosition(hConsole, start); } if (WritePlus or IsMinus) { if (WritePlus) start.X++; start.Y++; SetConsoleCursorPosition(hConsole, start); IsMinus ? wcout << L : wcout << L; start.X += 2; LINE += 2; start.Y--; } SetConsoleCursorPosition(hConsole, start); wcout << num_; start.Y++; SetConsoleCursorPosition(hConsole, start); wcout << wstring(sizemax, L); start.Y++; SetConsoleCursorPosition(hConsole, start); wcout << den_; start.Y -= 2; start.X += sizemax; SetConsoleCursorPosition(hConsole, start); LINE += sizemax + 1; } static void PrintFractionaryResult ( int NC, int DC, int& lines, Fraction<> Fract, POLYNOMIAL<> NScomp, POLYNOMIAL<> DScomp, bool HasMoreVariables, bool correct, tensor<double> roots, tensor<POLYNOMIAL<>> Denominators ) { tensor<int> null(Variables.size(), 0); bool ShowPlus{ false }; Fraction<> Part; Part.num = HasMoreVariables ? Fract.num : ToXV(NScomp); Part.den = HasMoreVariables ? Fract.den : ToXV(DScomp); if (correct) { wcout << L; for (size_t i = 0; i < Denominators; ++i) { PrintFraction( NC, DC, lines, ShowPlus, { polynomial<>{ { { roots[i], null } } }, ToXV(Denominators[i]) } ); ShowPlus = true; } wcout << L; goto EndOfStatement; } if (!Part.den.empty()) { if (Part.den > 1 or Part.den[0] > 1 or Part.den[0][0].exp != null) { GetConsoleScreenBufferInfo(hConsole, &csbi)(); csbi.dwCursorPosition.Y--; SetConsoleCursorPosition(hConsole, csbi.dwCursorPosition); PrintFraction( NC, DC, lines, false, Part ); wcout << L; goto EndOfStatement; } } if (abs(DC) != 1 and !Part.num.empty()) { GetConsoleScreenBufferInfo(hConsole, &csbi)(); csbi.dwCursorPosition.Y--; SetConsoleCursorPosition(hConsole, csbi.dwCursorPosition); PrintFraction( NC, DC, lines, false, { Part.num, { { monomial<>{ 1, null } } } } ); wcout << L; } else if (abs(DC) != 1 and NScomp.empty()) { GetConsoleScreenBufferInfo(hConsole, &csbi)(); csbi.dwCursorPosition.Y--; SetConsoleCursorPosition(hConsole, csbi.dwCursorPosition); PrintFraction( NC, DC, lines, false, { { { { 1, null } } }, { { { 1, null } } } } ); wcout << L; } else if (NScomp.empty()) { if (DC == -1) NC *= -1; wcout << L << NC; } else if (NScomp == 1) { auto output = HasMoreVariables ? Fract.num[0].str() : NScomp[0].str(); ElabExponents(output); if (NScomp[0] > 1 and NC != 1) output = L + output + L; if (abs(NC) != 1) output = to_wstring(NC) + output; if (NC * DC == -1) output = L + output; wcout << L << output; } else wcout << L << (HasMoreVariables ? Fract.num.str() : NScomp.str()); EndOfStatement: GetConsoleScreenBufferInfo(hConsole, &csbi)(); auto cursorP{ csbi.dwCursorPosition }; cursorP.X = lines; cursorP.Y--; SetConsoleCursorPosition(hConsole, cursorP); } static void Approximator(tensor<long double>& Equation, long double& root) { FACTOR<> equation(Equation.size()); for (ptrdiff_t i = Equation.size() - 1; i >= 0; --i) { equation[i].coefficient = Equation[i]; equation[i].degree = Equation.size() - i - 1; } auto derivative{ equation.derivate() }; const double TOL{ 1e-06 }; for (int i = 0; i < 100; ++i) { long double fx{}, dfx{}; for (size_t j = 0; j < equation; ++j) fx += equation[j].coefficient * pow(root, equation[j].degree); for (size_t j = 0; j < derivative; ++j) dfx += derivative[j].coefficient * pow(root, derivative[j].degree); if (dfx == 0) dfx += TOL; long double next = root - fx / dfx; if (fabs(next - root) < TOL) { root = next; break; } root = next; } for (size_t i = 1; i < equation.size(); ++i) { equation[i].coefficient = root * equation[i - 1].coefficient + equation[i].coefficient; equation[i].degree--; } equation[0].degree--; equation--; for (size_t i = 0; i < equation; ++i) Equation[i] = equation[i].coefficient; Equation--; } static tensor<wstring> EquationSolver(factor<> Equation) { tensor<int> null(Variables.size() , 0); if (Equation.empty()) return {}; tensor<wstring> answer; if (Equation == 1) { if (Equation[0].exp[0] == -1) return {}; or (size_t i = 0; i < Variables.size(); ++i) if (Equation[0].exp[i] != 0) answer << wstring(1, Variables.at(i)) + L; return answer; } int StartIndex; tensor<int> CorrectSizes; tensor<int> VDirectorTerm; tensor<int> VKnownTerm; tensor<tensor<int>> VDirectorSeq; tensor<tensor<int>> VKnownSeq; auto equation{ FromPolynomialToPos( Equation, StartIndex, CorrectSizes, VDirectorTerm, VKnownTerm, VDirectorSeq, VKnownSeq ) }; if (equation.empty() and Variables.size() == 1) { FACTOR<> eq{ To1V(Equation) }; eq.sort(); eq.complete(eq[0].degree + 1); tensor<long double> _eq; for (const auto& term : eq) _eq << term.coefficient; equation = { _eq }; VDirectorSeq = { { 1 } }; VKnownSeq = { { 0 } }; } if (!equation.empty()) for (;;) { if (equation[0] == 2) break; if (equation[0] == 3) { long double A, B, C; A = equation[0][0]; B = equation[0][1]; C = equation[0][2]; long double delta_4{ (B * B - 4 * A * C) / (4 * A * A) }; long double half_root_sum{ -B / (2 * A) }; wstring _push; if (delta_4 >= 0) { _push = factor<>{ { 1, VDirectorSeq[0] } }.str() + L + to_wstring(half_root_sum + sqrt(delta_4)); if (VKnownSeq[0] != null) _push += factor<>{ { 1, VKnownSeq[0] } }.str(); answer << _push; _push = factor<>{ { 1, VDirectorSeq[0] } }.str() + L + to_wstring(half_root_sum - sqrt(delta_4)); if (VKnownSeq[0] != null) _push += factor<>{ { 1, VKnownSeq[0] } }.str(); answer << _push; } else { _push = factor<>{ { 1, VDirectorSeq[0] } }.str() + L + complex<double>(half_root_sum, sqrt(-delta_4)).str(); if (VKnownSeq[0] != null) _push += factor<>{ { 1, VKnownSeq[0] } }.str(); answer << _push; _push = factor<>{ { 1, VDirectorSeq[0] } }.str() + L + complex<double>(half_root_sum, -sqrt(-delta_4)).str(); if (VKnownSeq[0] != null) _push += factor<>{ { 1, VKnownSeq[0] } }.str(); answer << _push; } return answer; } long double root{}; Approximator(equation[0], root); auto push{ factor<>{ { 1, VDirectorSeq[0] } }.str() + L + to_wstring(root) }; if (VKnownSeq[0] != null) push += factor<>{ { 1, VKnownSeq[0] } }.str(); answer << push; } if (Equation == 2) { int gcd{ abs(Gcd(Equation)) }; Equation[0].coefficient /= gcd; Equation[1].coefficient /= gcd; for (size_t i = 0; i < Variables.size(); ++i) { int min{ ::min(Equation[0].exp[i], Equation[1].exp[i]) }; Equation[0].exp[i] -= min; Equation[1].exp[i] -= min; } Equation.SortByExponents(); auto coeff{ Equation[0].coefficient }; Equation[0].coefficient = 1; if (coeff < 0) coeff *= -1; else Equation[1].coefficient *= -1; wstring push{ factor<>{ Equation[0] }.str() + L }; push += factor<>{ Equation[1] }.str(); if (coeff != 1) push += L + to_wstring(coeff); return { push }; } factor<> top, bottom; size_t Vpos{ Variables.find(L) }; for (const auto& mon : Equation) if (mon.exp[Vpos] > 1) return { Equation.str() + L }; for (auto mon : Equation) { if (mon.exp[Vpos] == 1) { mon.exp[Vpos] = 0; bottom << mon; continue; } mon.coefficient *= -1; top << mon; } tensor<bool> Used(Variables.size(), false); for (const auto& mon : Equation) for (size_t i = 0; i < Variables.size(); ++i) if (mon.exp[i] > 0) Used[i] = true; uto D = bottom.empty() ? L : bottom.str(); auto DD{ D }; if (D == L) { D = L; for (auto& mon : top) mon.coefficient *= -1; } auto N = top.empty() ? L : top.str(); auto NN{ N }; if (issign(NN.at(0))) NN.erase(0, 1); if (issign(DD.at(0))) DD.erase(0, 1); if (NN.find(L) != wstring::npos or NN.find(L) != wstring::npos) N = L + N + L; if (DD.find(L) != wstring::npos or DD.find(L) != wstring::npos) D = L + D + L; auto str{ N }; if (D == L) { if (str.at(0) == L) str.erase(0, 1); if (str.find(L) == wstring::npos) str.pop_back(); else str = L + str; str.at(0) == L ? str.erase(0, 1) : str = L + str; } if (D != L) str += L + D; return Used[Vpos] ? tensor<wstring>{ L + str } : tensor<wstring>{ str + L }; } static tensor<tensor<long double>> SystemSolver(tensor<factor<>> functions) { const double TOL{ 1e-06 }; tensor<int> null(Variables.size(), 0); if (functions != Variables.size()) return {}; int degree{ 1 }; for (const auto& function : functions) { int max{ function[0].degree() }; for (size_t i = 1; i < function; ++i) { int deg{ function[i].degree() }; if (max < deg) max = deg; } degree *= max; } if (degree == 0) return {}; if (degree == 1) { tensor<tensor<long double>> solutions(1); tensor<int> KnownTerms(Variables.size(), 0); for (size_t i = 0; i < functions; ++i) for (size_t j = 0; j < functions[i]; ++j) if (functions[i][j].exp == null) KnownTerms[i] = -functions[i][j].coefficient; Matrix<int> system(Variables.size(), tensor<int>(Variables.size(), 0)); for (size_t i = 0; i < functions; ++i) for (size_t j = 0; j < functions[i]; ++j) for (size_t k = 0; k < Variables.size(); ++k) if (functions[i][j].exp[k] == 1) system[k][i] = functions[i][j].coefficient; auto D{ system.det<long double>() }; tensor<long double> dets; for (size_t i = 0; i < Variables.size(); ++i) { auto mx{ system }; mx[i] = KnownTerms; dets << mx.det<long double>(); } if (D == 0) { if (dets == tensor<long double>(dets.size(), 0)) return { { nan() } }; return { {} }; } for (const auto& det : dets) solutions[0] << det / D; return solutions; } tensor<Fraction<>> NewFunctions; for (const auto& funct : functions) NewFunctions << Fraction<>({ funct }); tensor<tensor<long double>> solutions; tensor<long double> StarterPoint; for (size_t i = 0; i < Variables.size(); ++i) StarterPoint << pow(5, 1.0 / (i + 2)); for (int i = 0; i < 100 and solutions < degree; ++i) { Matrix<Fraction<>> Jacobian(Variables.size()); for (size_t j = 0; j < Variables.size(); ++j) for (size_t k = 0; k < Variables.size(); ++k) Jacobian[j] << NewFunctions[j].derivate(k); auto solution{ StarterPoint }; for (int j = 0; j < 100; ++j) { trix<> JInvpoint(Variables.size()); for (size_t k = 0; k < Variables.size(); ++k) for (size_t l = 0; l < Variables.size(); ++l) JInvpoint[k] << Jacobian[k][l](solution); auto determinant{ JInvpoint.det<long double>() }; JInvpoint = determinant == 0 ? JInvpoint.invert(1e-03) : JInvpoint.invert(determinant); tensor<long double> vect; for (size_t k = 0; k < Variables.size(); ++k) vect << NewFunctions[k](solution); tensor<long double> updater{ JInvpoint * vect }; for (size_t k = 0; k < Variables.size(); ++k) solution[k] -= updater[k]; long double norm{}; for (size_t k = 0; k < Variables.size(); ++k) norm += updater[k] * updater[k]; if (norm < TOL) break; } bool present{ false }; for (auto& sol : solutions) { bool LocalPresent{ true }; for (size_t j = 0; j < sol; ++j) if (fabs(sol[j] - solution[j]) > 100 * TOL) { LocalPresent = false; break; } if (LocalPresent) { present = true; break; } } if (!present) solutions << solution; factor<> remover; for (size_t j = 0; j < Variables.size(); ++j) { tensor<int> exponent(Variables.size(), 0); remover << monomial<>{ solution[j] * solution[j], exponent }; exponent[j] = 1; remover << monomial<>{ -2 * solution[j], exponent }; exponent[j] = 2; remover << monomial<>{ 1, exponent }; } for (auto& newfunct : NewFunctions) newfunct.den[0] *= remover; } return solutions; } static tensor<long double> RootExtractor(polynomial<> vect) { bool repeat{ false }; tensor<long double> roots; for (const auto& fact : vect) { if (fact.empty()) continue; if (fact[0].exp[0] < 0) { repeat = true; continue; } auto solutions{ EquationSolver(fact) }; if (fact == 1 and fact[0].exp[Variables.find(L)] == 2) solutions += solutions; for (auto sol : solutions) if (sol.find(L) == wstring::npos) { sol.erase(0, 5); auto fden{ sol }; if (sol.find(L) != wstring::npos) { while (fden.at(0) != L) fden.erase(0, 1); fden.erase(0, 1); while (Last(sol) != L) sol.pop_back(); sol.pop_back(); } else fden = L; auto root{ stold(sol) / stold(fden) }; roots << root; if (repeat)	roots << root; } repeat = false; } return roots; } static void FractDisequationMain( polynomial<> Num, polynomial<> Den, tensor<wstring>& Roots, tensor<bool>& ItsFromDenominator, bool& InitSign, bool& Invert ) { polynomial<> Un{ Num + Den }; long double Coeff{ 1 }; for (size_t i = 0; i < Un; ++i) if (Un[i] == 1 and Un[i][0].exp == tensor<int>{ 0 }) Coeff *= Un[i][0].coefficient; Invert = Coeff < 0; auto roots{ RootExtractor(Num) }; ItsFromDenominator = tensor<bool>(roots.size(), false); roots += RootExtractor(Den); ItsFromDenominator += tensor<bool>( roots.size() - ItsFromDenominator.size(), true ); for (ptrdiff_t i = roots.size() - 1; i >= 0; --i) if (roots[i] <= -2'147'483'647 or roots[i] >= 2'147'483'647) roots.erase(roots.begin() + i); for (size_t i = 0; i < roots; ++i) for (size_t j = i + 1; j < roots; ++j) if (roots[i] > roots[j]) { swap(roots[i], roots[j]); swap(ItsFromDenominator[i], ItsFromDenominator[j]); } InitSign = false; for (auto& fact : Num) { if (fact.empty()) continue; fact.SortByExponents(); if (fact[0].coefficient < 0) InitSign = !InitSign; } for (auto& fact : Den) { if (fact.empty()) continue; fact.SortByExponents(); if (fact[0].coefficient < 0) InitSign = !InitSign; } for (const auto& root : roots) Roots << Handler(to_wstring(root)); } static ConsoleStream GetAlgebricSolution( tensor<wstring> roots, tensor<bool> ItsFromDenominator, bool InitialSign, bool ExpectedSign, bool CanBeNull ) { ConsoleStream text; bool condition{ ((InitialSign == (roots.size() % 2 == 0)) == ExpectedSign) }; for (ptrdiff_t i = 0; i < roots.size() - 1; ++i) { bool SamePart{ int(i % 2) == condition }; if (i >= roots) break; if (roots[i] == roots[i + 1]) { bool T0{ ItsFromDenominator[i] or !CanBeNull }; bool T1{ ItsFromDenominator[i + 1] or !CanBeNull }; if ( (T0 and T1 and SamePart) or !(T0 or T1 or SamePart) or (!SamePart and (T0 xor T1)) ) { roots.erase(roots.begin() + (i + 1)); roots.erase(roots.begin() + i); ItsFromDenominator.erase(ItsFromDenominator.begin() + (i + 1)); ItsFromDenominator.erase(ItsFromDenominator.begin() + i); i--; continue; } if ((T0 xor T1) and SamePart) { ItsFromDenominator[i] = true; ItsFromDenominator[i] = false; } } } if (roots.empty()) return InitialSign == ExpectedSign ? ConsoleStream{ Console(L, 11) } : ConsoleStream{ Console(L, 11) }; if (condition) { text = { Console(L) }; CanBeNull and !ItsFromDenominator[0] ? text << Console(L) : text << Console(L); text << Console(roots[0]); if (roots > 1) text << Console(L, 8); } for (size_t i = condition; i < roots; i += 2) { if (i + 1 == roots) { CanBeNull and !ItsFromDenominator[i] ? text << Console(L) : text << Console(L); text << Console(roots[i]); break; } text << Console(roots[i]); CanBeNull and !ItsFromDenominator[i] ? text << Console(L) : text << Console(L); CanBeNull and !ItsFromDenominator[i + 1] ? text << Console(L) : text << Console(L); text << Console(roots[i + 1]); if (i + 2 < roots) text << Console(L, 8); } for (auto& cons : text) ElabExponents(cons.Text); return text; } static bool ParamDisequationSetup( polynomial<>& Num, polynomial<>& Den, polynomial<>& Sum, tensor<bool>& FromDenominator, tensor<long double>& AdditionalRoots, factor<>& Parametric, tensor<factor<>>& tops, tensor<factor<>>& bottoms, bool& InitSign, bool& InvertSign ) { auto Vpos{ Variables.find(L) }; for (auto& fact : Num) if (fact[0].exp[0] < 0 and fact[0].coefficient > 2) fact[0].coefficient = (int)fact[0].coefficient % 2; for (auto& fact : Den) if (fact[0].exp[0] < 0 and fact[0].coefficient > 2) fact[0].coefficient = (int)fact[0].coefficient % 2; Num.open(); Den.open(); Sum = Num + Den; for (auto& fact : Sum) for (const auto& mon : fact) if (mon.exp[Vpos] > 1) return false; FromDenominator = tensor<bool>(Num.size(), false) + tensor<bool>(Den.size(), true); InitSign = false; for (auto& fact : Sum) { fact.SortByExponents(); if (fact[0].coefficient < 0) InitSign = !InitSign; } tensor<factor<>> Parametrics; for (ptrdiff_t i = Sum.size() - 1; i >= 0; --i) { bool IsACoefficient{ true }; for (const auto& mon : Sum[i]) if (mon.exp[Vpos] != 0) { IsACoefficient = false; break; } if (IsACoefficient) { Parametrics << Sum[i]; Sum.erase(Sum.begin() + i); FromDenominator.erase(FromDenominator.begin() + i); if (Sum.empty()) return false; } } AdditionalRoots = RootExtractor(Parametrics); Parametric = PolynomialMultiply<long double>(Parametrics); tops(Sum.size()), bottoms(Sum.size()); for (size_t i = 0; i < Sum; ++i) { auto fact{ Sum[i] }; for (auto mon : fact) { if (mon.exp[Vpos] == 1) { mon.exp[Vpos] = 0; bottoms[i] << mon; continue; } mon.coefficient *= -1; tops[i] << mon; } if (tops[i].empty()) tops[i] = factor<>{ { 1, { 0, 0 } } }; if (bottoms[i].empty()) bottoms[i] = factor<>{ { 1, { 0, 0 } } }; if (fact == 1 and fact[0].exp == tensor<int>{ 0, 0 }) { InvertSign = ((tops[i][0].coefficient < 0) xor (bottoms[i][0].coefficient < 0)); Sum.erase(Sum.begin() + i); tops.erase(tops.begin() + i); bottoms.erase(bottoms.begin() + i); i--; } } return true; } static void ParamDisequationMain( polynomial<> Un, tensor<factor<>> tops, tensor<factor<>> bottoms, tensor<long double> AdditionalRoots, size_t& Unisize, tensor<tensor<factor<>>>& TableOfMains, tensor<long double>& RootSet, tensor<long double>& RootExamples, tensor<wstring>& vals ) { Unisize = Un.size(); tensor<tensor<factor<>>> FirstTable( bottoms.size(), tensor<factor<>>(bottoms.size()) ); TableOfMains = FirstTable; if (Unisize > 1) for (int first = 0; first < TableOfMains; ++first) for (int second = first + 1; second < TableOfMains; ++second) TableOfMains[first][second] = tops[first] * bottoms[second] - tops[second] * bottoms[first]; if (FirstTable == TableOfMains) Unisize = 1; RootSet = tensor<long double>{ RootExtractor(bottoms) }; if (Unisize > 1) for (auto& F : TableOfMains) for (auto& S : F) RootSet += RootExtractor({ S }); RootSet += AdditionalRoots; if (!RootSet.empty()) { long double RepeatedValue{ RootSet.last() }; for (size_t i = 0; i < RootSet; ++i) for (size_t j = i + 1; j < RootSet; ++j) if (RootSet[i] > RootSet[j]) swap(RootSet[i], RootSet[j]); for (ptrdiff_t i = RootSet.size() - 2; i >= 0; --i) { if (RootSet[i] == RepeatedValue) { RootSet.erase(RootSet.begin() + i); continue; } RepeatedValue = RootSet[i]; } RootExamples << RootSet[0] - 1; for (ptrdiff_t i = 0; i < RootSet.size() - 1; ++i) RootExamples << (RootSet[i] + RootSet[i + 1]) / 2.0; RootExamples << RootSet.last() + 1; } else RootExamples = { 0 }; for (size_t i = 0; i < Un; ++i) { auto D = bottoms[i].empty() ? L : bottoms[i].str(); auto DD{ D }; auto top{ tops[i] }; if (D == L) { D = L; for (auto& mon : top) mon.coefficient *= -1; } auto N = top.empty() ? L : top.str(); auto NN{ N }; if (issign(NN.at(0))) NN.erase(0, 1); if (issign(DD.at(0))) DD.erase(0, 1); if (NN.find(L) != wstring::npos or NN.find(L) != wstring::npos) N = L + N + L; if (DD.find(L) != wstring::npos or DD.find(L) != wstring::npos) D = L + D + L; auto str{ N }; if (D != L) str += L + D; vals << str; } } static ConsoleStream GetParametricSolution( wchar_t parameter, size_t Unisize, size_t Vpos, bool InitialSign, bool ExpectedSign, bool CanBeNull, tensor<bool> TermsFromDenominator, polynomial<>& Num, polynomial<>& Den, factor<> Parametric, tensor<factor<>> tops, tensor<factor<>> bottoms, tensor<tensor<factor<>>> TableOfMains, tensor<long double> RootSet, tensor<long double> RootExamples, tensor<wstring> vals ) { ConsoleStream text; tensor<wstring> ParameterIntervals; tensor<ConsoleStream> UnknownIntervals; for (size_t index = 0; index < RootExamples; ++index) { auto interval{ RootExamples[index] }; auto values{ vals }; auto ItsFromDenominator{ TermsFromDenominator }; ConsoleStream line; tensor<int> SumOfGEQValues(bottoms.size(), 0); if (index == 0) { ParameterIntervals << wstring(1, parameter); ParameterIntervals[0] += L + Handler(to_wstring(RootSet[0])); UnknownIntervals << ConsoleStream{ Console(L) }; goto comparison; } if (index == RootSet) { ParameterIntervals << wstring(1, parameter); ParameterIntervals.last() += L + Handler(to_wstring(RootSet.last())); UnknownIntervals << ConsoleStream{ Console(L) }; goto comparison; } ParameterIntervals << Handler(to_wstring(RootSet[index - 1])); CanBeNull and index - 1 < bottoms ? ParameterIntervals.last() += L : ParameterIntervals.last() += L; ParameterIntervals.last() += wstring(1, parameter); CanBeNull and index < bottoms ? ParameterIntervals.last() += L : ParameterIntervals.last() += L; ParameterIntervals.last() += Handler(to_wstring(RootSet[index])); UnknownIntervals << ConsoleStream{ Console(L) }; comparison: if (Unisize == 1) goto add_line; for (size_t first = 0; first < SumOfGEQValues; ++first) for (size_t second = first + 1; second < SumOfGEQValues; ++second) { bool value{ (TableOfMains[first][second](interval, 1 - Vpos, true)) == ( bottoms[first](interval, 1 - Vpos, true) == bottoms[second](interval, 1 - Vpos, true) ) }; SumOfGEQValues[first] += value; SumOfGEQValues[second] += !value; } for (size_t i = 0; i < SumOfGEQValues; ++i) for (size_t j = i + 1; j < SumOfGEQValues; ++j) if (SumOfGEQValues[i] == SumOfGEQValues[j]) line = { Console(L, 8), Console(L, 11) }; for (size_t i = 0; i < SumOfGEQValues; ++i) for (size_t j = i + 1; j < SumOfGEQValues; ++j) if (SumOfGEQValues[i] > SumOfGEQValues[j]) { swap(SumOfGEQValues[i], SumOfGEQValues[j]); swap(values[i], values[j]); swap(ItsFromDenominator[i], ItsFromDenominator[j]); } add_line: line = ConsoleStream{ Console(L, 8) } + GetAlgebricSolution( values, ItsFromDenominator, InitialSign, ExpectedSign == Parametric(interval, 1 - Vpos, true), CanBeNull ); UnknownIntervals.last() = line + UnknownIntervals.last(); if (index == RootSet) break; ParameterIntervals << wstring(1, parameter) + L; ParameterIntervals.last() += Handler(to_wstring(RootSet[index])); auto numerator{ Num }; auto denominator{ Den }; for (auto& fact : numerator) fact = fact(RootSet[index], 1 - Vpos, 1); for (auto& fact : denominator) fact = fact(RootSet[index], 1 - Vpos, 1); if (Vpos == 1) { for (auto& fact : numerator) for (auto& mon : fact) mon.exp[0] = mon.exp[1]; for (auto& fact : denominator) for (auto& mon : fact) mon.exp[0] = mon.exp[1]; } auto save{ Variables }; Variables = L; UnknownIntervals << ConsoleStream{ Console(L, 8) }; if (numerator.empty()) numerator = polynomial<>{ { { 0, { 0 } } } }; if (denominator.empty()) denominator = polynomial<>{ { { 0, { 0 } } } }; UnknownIntervals.last() += DisequationSolutionPrinter( numerator, denominator, 1 << ( 2 * (ExpectedSign xor Parametric(RootSet[index], 1 - Vpos, true)) + CanBeNull ), false, false ) + ConsoleStream{ Console(L) }; Variables = save; } size_t sizemax{ ParameterIntervals[0].size() }; for (size_t i = 1; i < ParameterIntervals; ++i) if (sizemax < ParameterIntervals[i].size()) sizemax = ParameterIntervals[i].size(); for (auto& word : ParameterIntervals) if (word.size() < sizemax) word += wstring(sizemax - word.size(), L); for (size_t i = 0; i < ParameterIntervals; ++i) { text << Console(ParameterIntervals[i]); for (size_t j = 0; j < UnknownIntervals[i]; ++j) text << UnknownIntervals[i][j]; } for (auto& cons : text) ElabExponents(cons.Text); return text; } static ConsoleStream DisequationSolutionPrinter( polynomial<> Num, polynomial<> Den, int behaviour, bool ChangeSign, bool PrintCondition ) { auto Vpos{ Variables.find(L) }; if (Variables.size() > 2 or Vpos == wstring::npos) return {}; if (Num.empty() and Den.empty()) return {}; WORD wAttribute{ 6 }; wstring expr = Variables == L ? L : L + wstring(1, Variables.at(1 - Vpos)) + L; expr = L + expr; ConsoleStream dir{ Console(expr + L, wAttribute), Console(expr + L, wAttribute), Console(expr + L, wAttribute), Console(expr + L, wAttribute) }; if (Variables == L) { ensor<wstring> roots; tensor<bool> ItsFromTheDenominator; bool InitialSign, InvertTheSign; FractDisequationMain( Num, Den, roots, ItsFromTheDenominator, InitialSign, InvertTheSign ); ConsoleStream Output; for (int i = 0; i < 4; ++i) if ((behaviour | (1 << i)) == behaviour) { bool positive = i / 2; if (PrintCondition) Output << dir[i] << Console(L); Output += GetAlgebricSolution( roots, ItsFromTheDenominator, InitialSign, (positive == InvertTheSign) xor ChangeSign, i % 2 == 1 ); if (PrintCondition) Output << Console(L); } if (PrintCondition) { Output--; Output << Console(L); } return Output; } wchar_t parameter{ Variables.at(1 - Vpos) }; polynomial<> Un; tensor<bool> TermsFromDenominator; tensor<long double> AdditionalRoots; factor<> Parametric; tensor<factor<>> tops, bottoms; bool InitialSign, InvertSign{ true }; if ( !ParamDisequationSetup( Num, Den, Un, TermsFromDenominator, AdditionalRoots, Parametric, tops, bottoms, InitialSign, InvertSign ) ) return {}; if (Un == 1 and Parametric == factor<>{ { 1, { 0, 0 } } }) { ConsoleStream Output; tensor<wstring> vals{ EquationSolver(Un[0]) }; if (vals == 1) if (isalpha(vals[0].at(0)) and isalpha(vals[0].at(1))) { if (vals[0].find(L) == wstring::npos) vals[0] += L; vals[0] += parameter; } for (auto& val : vals) val.erase(0, 5); for (int i = 0; i < 4; ++i) if ((behaviour | (1 << i)) == behaviour) { bool positive = i / 2; if (PrintCondition) Output << dir[i] << Console(L); Output += GetAlgebricSolution( vals, tensor<bool>(vals.size(), TermsFromDenominator[0]), InitialSign, (positive == InvertSign) xor ChangeSign, i % 2 == 1 ); if (PrintCondition) Output << Console(L); } if (PrintCondition) { Output--; Output << Console(L); } return Output; } size_t Unisize; tensor<tensor<factor<>>> TableOfMains; tensor<long double> RootSet, RootExamples; tensor<wstring> vals; ParamDisequationMain( Un, tops, bottoms, AdditionalRoots, Unisize, TableOfMains, RootSet, RootExamples, vals ); ConsoleStream Output; for (int i = 0; i < 4; ++i) if ((behaviour | (1 << i)) == behaviour) { bool positive = i / 2; if (PrintCondition) Output << dir[i] << Console(L); Output += ( RootSet.empty() ? GetAlgebricSolution( vals, TermsFromDenominator, InitialSign, (positive xor InvertSign) xor ChangeSign, i % 2 == 1 ) + ConsoleStream{ Console(L) } : tParametricSolution( parameter, Unisize, Vpos, InitialSign, (positive xor InvertSign) xor ChangeSign, i % 2 == 1, TermsFromDenominator, Num, Den, Parametric, tops, bottoms, TableOfMains, RootSet, RootExamples, vals ) ); if (PrintCondition) Output << Console(L); } if (PrintCondition) { Output--; Output << Console(L); } return Output; } static void CodeToNumber(switchcase& argc) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); wstring to_evaluate, ToEvaluate, message; bool ShowErrors{ true }, NecessaryBoundary{ true }; SetConsoleTextAttribute(hConsole, 14); wcout << L; SetConsoleTextAttribute(hConsole, 12); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 9); wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); for (;;) { do { message.clear(); wcout << L; wcout << L; getline(wcin, ToEvaluate); if (ToEvaluate == L) { argc = NotAssigned; return; } argc = ConvertWStringToEnum(ToEvaluate); ReassigneEnum(argc); if (argc != NotAssigned) { system(); SetConsoleTitle(ToEvaluate.c_str()); return; } if (ToEvaluate == L) { argc = Random; return; } if (!ToEvaluate.empty()) { NecessaryBoundary = ToEvaluate.at(0) != L and ToEvaluate.at(0) != L; ShowErrors = ToEvaluate.at(0) != L and NecessaryBoundary; if (!NecessaryBoundary) ToEvaluate.erase(0, 1); } to_evaluate = ToEvaluate; if (NecessaryBoundary) message = UpdateString(ToEvaluate); if (message.empty()) message = NumberCodeSyntax(ToEvaluate); if (message.size() > 1) { lock_guard<mutex> lock(CoutMutex); SetConsoleTextAttribute(hConsole, 4); wcout << L << message << L; SetConsoleTextAttribute(hConsole, 15)(); } } while (message.size() > 1); for (ptrdiff_t space = ToEvaluate.size() - 1; space >= 0; --space) if (ToEvaluate.at(space) == L or ToEvaluate.at(space) == L) ToEvaluate.erase(space, 1); { lock_guard<mutex> lock(mtx); GlobalInterr = false; interrupted = false; computing = true; } Cv.notify_all(); R; thread ComputationThread([=]() { LongComputation(to_evaluate, message, ShowErrors, NecessaryBoundary); } ); thread InputThread(UserInputThread); unique_lock<mutex> lock(CoutMutex); Cv.wait(lock, [] { return !GlobalInterr; }); if (ComputationThread.joinable()) ComputationThread.join(); if (InputThread.joinable()) InputThread.join(); if (GlobalInterr) { SetConsoleTextAttribute(hConsole, 14); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); } SetConsoleCursorInfo(hConsole, &cursor); } } tensor<tensor<wstring>> Map(17); static wstring ExpandNumber( switchcase& argc, big Number,	int Base,	bool access	) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); bool code{ true }; wstring ToEvaluate; bool RetAccess{ false }; if (access) { SetConsoleTextAttribute(hConsole, 14); wcout << L; SetConsoleTextAttribute(hConsole, 12); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); } for (;;) { if (!RetAccess) code = true; if (access) { input: SetConsoleTextAttribute(hConsole, 11); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); getline(wcin, ToEvaluate); for (ptrdiff_t i = ToEvaluate.size() - 1; i >= 0; --i) if (ToEvaluate.at(i) == L or ToEvaluate.at(i) == L) ToEvaluate.erase(i, 1); if (ToEvaluate == L) { argc = NotAssigned; return L; } argc = ConvertWStringToEnum(ToEvaluate); ReassigneEnum(argc); if (argc != NotAssigned) { system(); SetConsoleTitle(ToEvaluate.c_str()); return L; } if (ToEvaluate == L) { argc = Random; return L; } if (regex_search(ToEvaluate, wregex(L))) goto input; if (ToEvaluate.size() > 2 and ( ToEvaluate.find(L) != wstring::npos and ToEvaluate.find(L) != wstring::npos )) { code = false; Base = 2; if (Last(ToEvaluate) != L) goto input; int pos = ToEvaluate.find(L); switch (pos) { case 0: Base = -1; break; case 1: if (!isdigit(ToEvaluate.at(0))) goto input; Base = ToEvaluate.at(0) - L; break; case 2: if (!isdigit(ToEvaluate.at(0)) or !isdigit(ToEvaluate.at(1))) goto input; Base = (ToEvaluate.at(0) - L) * 10 + ToEvaluate.at(1) - L; break; default: goto input; } if ((Base < 2 or Base > 16) and Base >= 0) goto input; ToEvaluate.erase(0, pos + 1); ToEvaluate.pop_back(); if (ToEvaluate.find(L) != wstring::npos and ToEvaluate.find(L) != wstring::npos) goto input; if (regex_search(ToEvaluate, wregex(L))) goto input; if (ToEvaluate.at(0) == L or Last(ToEvaluate) == L) goto input; for (size_t i = 1; i < ToEvaluate.size(); ++i) if (ToEvaluate.at(i - 1) == L and ToEvaluate.at(i) == L) goto input; int Parenthesis{}; for (const auto& ch : ToEvaluate) { switch (ch) { case L: Parenthesis++; break; case L: Parenthesis--; break; } if (Parenthesis < 0 or Parenthesis > 5) goto input; } if (regex_search(ToEvaluate, wregex(L))) goto input; if (regex_search(ToEvaluate, wregex(L))) goto input; for (size_t i = 1; i < ToEvaluate.size() - 1; ++i) if (ToEvaluate.at(i) == L and ( ToEvaluate.at(i - 1) == L or ToEvaluate.at(i + 1) == L) ) goto input; ToEvaluate.size() >= 2) if ( isdigit(Last(ToEvaluate)) and isdigit(ToEvaluate.at(ToEvaluate.size() - 2)) ) goto input; if (regex_search(ToEvaluate, wregex(L))) goto input; } if (ToEvaluate.size() > 50 and code) goto input; if (code) { if (regex_search(ToEvaluate, wregex(L))) goto input; Number = ToEvaluate; } if (Number == 0) goto input; if (!code and Base == -1) { access = false; RetAccess = true; Base = 1; } } if (RetAccess) Base++; if (Base == 17) { access = true; RetAccess = false; Base = 2; continue; } if (code) for (int base = 2; base <= 16; ++base) { if (!access and base != Base) continue; wstring output; big number = Number; tensor<int> coefficients; for (int i = 0;; ++i) { if (number < base) break; big quotient = number / base; coefficients << (number - quotient * base).Number<int>(); number = quotient; } coefficients << number.Number<int>(); Map[base](max(Map[base].size(), coefficients.size()), L); Map[base][0] = L; for (ptrdiff_t i = coefficients.size() - 1; i >= 0; --i) if (coefficients[i] > 0) { ring partial{ L }; bool recursion{ coefficients[i] > 1 }; if (recursion) partial += to_wstring(coefficients[i]); if (Map[base][i].empty()) Map[base][i] = ExpandNumber(argc, i, base, false); if (!recursion) recursion = Map[base][i].find(L) != wstring::npos or Map[base][i].find(L) != wstring::npos; if (recursion) partial += L + Map[base][i] + L; else partial += to_wstring(stoi(Map[base][i]) + 1); output += partial; } if (output.at(0) == L) output.erase(0, 1); if (!access) return output; SetConsoleTextAttribute(hConsole, 6); wcout << L << base << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L << output << L; } else { auto toevaluate{ ToEvaluate }; tensor<big> tetration{ 0, 1, Base }; big Last = Base; for (;;) { if (Last * log2(Base) >= 256) break; Last = big(Base) ^ Last; tetration << Last; } for (ptrdiff_t i = toevaluate.size() - 1; i >= 0; --i) if (isdigit(toevaluate.at(i))) { if (i != (int)toevaluate.size() - 1) if (toevaluate.at(i + 1) == L) continue; int dim = toevaluate.at(i) - L; if (dim < 2) continue; if (dim >= tetration) goto overflow; auto first{ toevaluate }; auto second{ toevaluate }; first.erase(i); second.erase(0, i + 1); toevaluate = toevaluate.substr(0, i) + tetration[dim].str() + toevaluate.substr(i + 1, toevaluate.size() - 1); } while (toevaluate.find(L) != wstring::npos) for (ptrdiff_t i = toevaluate.size() - 1; i >= 0; --i) if (toevaluate.at(i) == L) { size_t j = i; for (; j < toevaluate.size(); ++j) if (toevaluate.at(j) == L) break; auto part{ toevaluate }; part.erase(j); part.erase(0, i + 1); tensor<big> add; for (ptrdiff_t k = part.size() - 1; k >= 0; --k) if (part.at(k) == L) { auto NewPart{ part }; part.erase(k); NewPart.erase(0, k + 1); add << NewPart; } add << part; big sum; for (const auto& num : add) sum += num; int coefficient{ 1 }, size{}; if (i > 0) if (isdigit(toevaluate.at(i - 1))) { coefficient = toevaluate.at(i - 1) - L; size = 1; } if (i > 1) if ( isdigit(toevaluate.at(i - 1)) and isdigit(toevaluate.at(i - 2)) ) { coefficient = coefficient * 10 + toevaluate.at(i - 1) - L; size = 2; } if (sum * log2(Base) >= 256) goto overflow; big result = (big(Base) ^ sum) * coefficient; auto first{ toevaluate }; auto second{ toevaluate }; first.erase(i - size); second.erase(0, j + 1); toevaluate = toevaluate.substr(0, i - size) + result.str() + toevaluate.substr(j + 1, toevaluate.size() - 1); } tensor<big> add; for (ptrdiff_t j = toevaluate.size() - 1; j >= 0; --j) if (toevaluate.at(j) == L) { auto part{ toevaluate }; toevaluate.erase(j); part.erase(0, j + 1); add << part; } add << toevaluate; big LastSum; for (const auto& num : add) LastSum += num; SetConsoleTextAttribute(hConsole, 2); wcout << L << Base << L; wcout << LastSum << L; SetConsoleTextAttribute(hConsole, 15)(); } continue; overflow: if (!RetAccess) { SetConsoleTextAttribute(hConsole, 4); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); } continue; } argc = NotAssigned; return L; } static void Repeater( switchcase& argc, wstring message, NumberData CPU(ptrdiff_t input) ) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); wstring n_{ to_wstring(GlobalMax) }, Input; ptrdiff_t input; NumberData result; SetConsoleTextAttribute(hConsole, 14); wcout << message << L; SetConsoleTextAttribute(hConsole, 15)(); for (;;) { SetConsoleTextAttribute(hConsole, 14); wstring txt{ L + n_ + L }; SetConsoleTextAttribute(hConsole, 15)(); Input = GetUserNum(txt, 1, GlobalMax, true); if (!Input.empty()) { if (Input == L) { argc = Random; return; } argc = ConvertWStringToEnum(Input); ReassigneEnum(argc); if (argc != NotAssigned) { system(); SetConsoleTitle(Input.c_str()); return; } input = stoull(Input); } else { random_device rng; mt19937 gen(rng()); uniform_int_distribution<size_t> dis(2, GlobalMax); input = dis(gen); } if (input == 1) break; result = CPU(input); result.printf(); } argc = NotAssigned; return; } static void Loop( switchcase& argc, wstring message, NumberData CPU(ptrdiff_t input), bool select ) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); wstring n_{ to_wstring(GlobalMax) }, Input, txt; tensor<NumberData> data; ptrdiff_t LowerBound, UpperBound, datalenght; bool Return; wcout << L; SetConsoleTextAttribute(hConsole, 14); wcout << message << ; SetDebug(message, argc, Return, LowerBound, UpperBound, datalenght); if (Return) return; wstring instr; if (select) { PRINTN = false; items = { 0, 0, 0, 0 }; SetConsoleTextAttribute(hConsole, 9); wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); bool exit{ false }; do { wcout << L; instr = GetLine(Expressions); if (instr == L) { argc = Random; return; } for (ptrdiff_t i = instr.size() - 1; i >= 0; --i) if (instr.at(i) == L or instr.at(i) == L) instr.erase(i, 1); wstring sum_instr{ instr }, prod_instr{ instr }; int posP{}, posS{}; if (instr.empty()) { items = { 0, 0, 0, 0 }; break; } posS = instr.find(L); posP = instr.find(L); if (posS == wstring::npos) sum_instr.clear(); if (posP == wstring::npos) prod_instr.clear(); if (sum_instr.empty()) prod_instr.erase(0, posP + 1); else if (prod_instr.empty()) sum_instr.erase(0, posS + 1); else if (posS < posP) { prod_instr.erase(0, posP + 1); sum_instr.erase(posP); sum_instr.erase(0, posS + 1); } else { sum_instr.erase(0, posS + 1); prod_instr.erase(posS); prod_instr.erase(0, posP + 1); } int pos_p{}, pos_s{}; if (!sum_instr.empty()) pos_s = sum_instr.find(L); if (!prod_instr.empty()) pos_p = prod_instr.find(L); if (pos_s == wstring::npos or pos_p == wstring::npos) continue; wstring np, dp, ns, ds; bool Continue{ false }; if (!prod_instr.empty()) { np = prod_instr; dp = prod_instr; np.erase(pos_p); dp.erase(0, pos_p + 1); for (const auto& c : np) if (!isdigit(c)) Continue = true; for (const auto& c : dp) if (!isdigit(c)) Continue = true; if (Continue) continue; items.digitProductRatioNum = stoi(np); items.digitProductRatioDen = stoi(dp); exit = true; } if (!sum_instr.empty()) { ns = sum_instr; ds = sum_instr; ns.erase(pos_s); ds.erase(0, pos_s + 1); for (const auto& c : ns) if (!isdigit(c)) Continue = true; for (const auto& c : ds) if (!isdigit(c)) Continue = true; if (Continue) continue; items.digitSumRatioNum = stoi(ns); items.digitSumRatioDen = stoi(ds); exit = true; } if (!exit) wcout << L; } while (!exit); } system(); GetConsoleScreenBufferInfo(hConsole, &csbi)(); const int Barwidth{ csbi.dwSize.X - 11 }; R; if (datalenght >= 1'000) { int iter{}; atomic<long double> Progress{}; DECLARE_TIME_POINT(begin); parallel_for(ptrdiff_t(LowerBound), UpperBound, [&](ptrdiff_t set) { auto data_element{ CPU(set) }; mtx.lock(); data << data_element; if (iter % 200 == 0) { DECLARE_TIME_POINT(stop); SetConsoleTextAttribute(hConsole, 112); Progress = (long double)data.size() / datalenght; ProgressBar(Progress, Barwidth); time = 1'000 * static_cast<double>(stop.QuadPart - begin.QuadPart) / (ProgramFrequency.QuadPart); SetConsoleTextAttribute(hConsole, 15)(); long double time_rem{ (time / Progress) * (1 - Progress) }; long double time_seconds{ (long double)time_rem / 1'000 }; wostringstream stream; stream << fixed << setprecision(1) << time_seconds; wcout << L << stream.str(); wcout << L; } iter++; mtx.unlock(); } ); SetConsoleCursorPosition(hConsole, { 0, 0 }); wcout << wstring(Barwidth + 11, L) << L; thread t1([&data]() { GeneralizedHeapSort(data); lock_guard<mutex> lock(mtx); IsDone = true; cv.notify_one(); } ); thread t2(CS_CenterPrinter); if (t2.joinable()) t2.join(); if (t1.joinable()) t1.join(); system(); SetConsoleCursorInfo(hConsole, &cursor); for (auto& member : data) member.printf(); DECLARE_TIME_POINT(end); wcout << L; wcout << 1'000 * static_cast<double>(end.QuadPart - begin.QuadPart) / (ProgramFrequency.QuadPart); wcout << L; } else { SetConsoleCursorInfo(hConsole, &cursor); DECLARE_TIME_POINT(begin); for (ptrdiff_t set = LowerBound; set < UpperBound; ++set) data << NumberData{ CPU(set) }; for (auto& member : data) member.printf(); wcout << L; DECLARE_TIME_POINT(end); wcout << 1'000 * static_cast<double>(end.QuadPart - begin.QuadPart) / (ProgramFrequency.QuadPart); wcout << L; } PRINTN = true; Beep(750, 100); Beep(650, 75); Beep(550, 50); wcout << L; argc = _getch() == L ? Random : NotAssigned; return; } template<typename Type = wstring> static polynomial<> DecompPolynomial(switchcase& argc, Type Polynomial) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); SetConsoleTextAttribute(hConsole, 14); wstring pol; polynomial<> HT; bool empty{ true }, Xout{ false }, input{ Polynomial == Type() }; const constexpr bool CheckSafe{ is_same_v<Type, wstring> }; if constexpr (CheckSafe) if (input) { wcout << L; SetConsoleTextAttribute(hConsole, 12); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 4); wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); } do { bool draw{ false }; if (!RunMonitor) goto RETURN; if constexpr (CheckSafe) if (input) { empty = true; Xout = false; wstring Message; do { GetConsoleScreenBufferInfo(hConsole, &csbi)(); draw = false; bool wrong{ true }; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; wcout << L; do { Polynomial = GetLine(Polynomials); wcout << L; } while (Polynomial.empty()); if (Polynomial.at(0) == L) { Polynomial.erase(0, 1); draw = true; } if (Polynomial == L) { argc = Random; HT = {}; goto RETURN; } argc = ConvertWStringToEnum(Polynomial); ReassigneEnum(argc); if (argc != NotAssigned) { system(); SetConsoleTitle(Polynomial.c_str()); HT = {}; goto RETURN; } if (Polynomial == L) { BOOLALPHA = true; wrong = false; } if (Polynomial == L) { BOOLALPHA = false; wrong = false; } if (!wrong) wcout << Polynomial << L; for (ptrdiff_t i = Polynomial.size() - 1; i >= 0; --i) if (Polynomial.at(i) == L or Polynomial.at(i) == L) Polynomial.erase(i, 1); Message = Polynomial.empty() ? L : PolynomialSyntaxDirector(Polynomial); if (!Message.empty() and wrong) { SetConsoleTextAttribute(hConsole, 12); wcout << Message << L; SetConsoleTextAttribute(hConsole, 15)(); } } while (!Message.empty()); if (Polynomial == L) break; } polynomial<> BackT, Back_T{ HT }; polynomial<big> bigHT; tensor<int> null, Null; ptrdiff_t Coeff{ 1 }; int size; if constexpr (CheckSafe) { bigHT = GetMonomialsAssister(Polynomial); tensor<big> ListOfCoefficients; for (auto fact : bigHT) for (auto mon : fact) if (mon.exp[0] >= 0) ListOfCoefficients << mon.coefficient; big G{ Gcd(ListOfCoefficients + tensor<big>{ LCM }).fabs() }; for (auto& fact : bigHT) for (auto& mon : fact) if (mon.exp[0] >= 0) mon.coefficient /= G; LCM /= G; if (input) charVariable = Variables.at(0); HT = FromBigToDefault(bigHT); if (HT >= 1) if (HT[0] >= 1) if (HT[0][0].exp[0] == -2) { if (input) { SetConsoleTextAttribute(hConsole, 2); wcout << L << bigHT << L; SetConsoleTextAttribute(hConsole, 64); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; continue; } else return {}; } if (Variables.find(L) != wstring::npos) { if (!input) return {}; SetConsoleTextAttribute(hConsole, 2); wcout << L; wcout << PolynomialMultiply<big>(bigHT).str() << L; SetConsoleTextAttribute(hConsole, 64); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; continue; } } else if constexpr (is_same_v<Type, factor<>>) HT = { Polynomial }; else if constexpr (is_same_v<Type, polynomial<>>) HT = Polynomial; wstring _polynomial; if constexpr (CheckSafe) _polynomial = Polynomial; Null(Variables.size(), 0); null(Variables.size(), 0); null[0] = -1; for (const auto& poly_data : HT) if (poly_data.empty()) { _polynomial = L; break; } if (HT.empty()) _polynomial = L; else if (_polynomial != L) _polynomial = HT.str(); if (input) { SetConsoleTextAttribute(hConsole, 2); if (_polynomial.empty()) _polynomial = L; wcout << L << _polynomial << L; } size = HT.size(); if (_polynomial == L) { if (input) { SetConsoleTextAttribute(hConsole, 15)(); wcout << ; } goto EndOfDecomposition; } Back_T = HT; HT.clear(); for (const auto& polydata : Back_T) HT += Total(polydata); for (ptrdiff_t i = HT.size() - 1; i >= 0; --i) if (HT[i] == 1) if (HT[i][0].exp == Null) { Coeff *= HT[i][0].coefficient; HT.erase(HT.begin() + i); if (Coeff >= 2'147'483'647 or Coeff <= -2'147'483'647) { if (!input) return {}; SetConsoleTextAttribute(hConsole, 2); wcout << L << bigHT << L; SetConsoleTextAttribute(hConsole, 64); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; continue; } } if (HT.empty()) HT = polynomial<>{ { { (long double)Coeff, Null } } }; else if (abs(Coeff) != 1) HT >> factor<>{ { (long double)Coeff, Null } }; else if (Coeff == -1) for (auto& mon : HT[0]) mon.coefficient *= -1; HT.close(); _polynomial = HT.str(); if (HT != size and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 12); wcout << L << _polynomial << L; empty = false; } do { Back_T = HT; pol = _polynomial; auto polydata{ HT.last() }; polydata.SortByDegree(); HT--; HT += Partial(polydata); HT.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 4); wcout << L << _polynomial << L; empty = false; } HT.close(); Back_T = HT; HT.clear(); for (const auto& a : Back_T) HT += Binomial(a); HT.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 3); wcout << L; wcout << _polynomial << L; empty = false; } Back_T = HT; HT.clear(); for (const auto& a : Back_T) HT += Trinomial(a); HT.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 9); wcout << L; wcout << _polynomial << L; empty = false; } Back_T = HT; HT.clear(); int extend{ 1 }; for (const auto& a : Back_T) { if (a[0].exp[0] < 0) { extend = a[0].coefficient; continue; } BackT = SquareDifference(a); for (const auto& b : BackT) { if (extend > 1) HT << factor<>{ { (long double)extend, null } }; HT << b; } extend = 1; } HT.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 5); wcout << L; wcout << _polynomial << L; empty = false; } for (auto& poldata : HT) poldata.SortByExponents(); pol = HT.str(); Back_T = HT; HT.clear(); extend = 1; for (const auto& a : Back_T) { if (a[0].exp[0] < 0) { extend = a[0].coefficient; continue; } BackT = Ruffini(a); if (!a.empty() and BackT.empty()) { Xout = true; break; } for (const auto& b : BackT) { if (extend > 1) HT << factor<>{ { (long double)extend, null } }; HT << b; } extend = 1; } HT.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 6); wcout << L; wcout << _polynomial << L; empty = false; } } while (_polynomial != pol); Back_T = HT; HT.clear(); for (const auto& a : Back_T) HT += CompleteTheSquare(a); HT.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 79); wcout << L << _polynomial; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; empty = false; } Back_T = HT; HT.clear(); for (const auto& a : Back_T) HT += TrinomialSquare(a); T.close(); _polynomial = HT.str(); if (Back_T % HT and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 79); wcout << L << _polynomial; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; empty = false; } if (empty and !Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 15)(); wcout << L; } if (Xout and CheckSafe and input) { SetConsoleTextAttribute(hConsole, 64); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; } if (CheckSafe and input and draw) switch (Variables.size()) { case 1: if (CreateGraph( { { PolynomialMultiply(HT) }, { { { 1, Null } } } } )) while (CreateGraph()); break; case 2: Project3DGraph( { { PolynomialMultiply(HT) }, { { { 1, { Null } } } } } ); break; } EndOfDecomposition: if (!(CheckSafe and input)) break; } while (CheckSafe and input); argc = NotAssigned; RETURN: if (CheckSafe and input) { { lock_guard<mutex> lk(MonitorMTX); RunMonitor = false; } MonitorCV.notify_all(); } return HT; } static void DecompAndSolve(switchcase& argc) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); SetConsoleTextAttribute(hConsole, 14); wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 12); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 10); wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); bool startover{ true }; tensor<wstring> VariablesDisposition; tensor<Fraction<>> Fractions; for (;;) { argc = NotAssigned; while (GetAsyncKeyState(VK_SHIFT) & 0x8000 or GetAsyncKeyState(VK_RETURN) & 0x8000); if (!RunMonitor) goto RETURN; insert: if (startover) { Variables = L; wcout << L; wcout << L; } startover = false; wstring err; bool _graph, _equation, skip{ false }; Fraction<big> inputed{ Expression().in(argc, err, _graph, _equation) }; Fraction<> it{ FromBigToDefault(inputed.num), FromBigToDefault(inputed.den) }; VariablesDisposition << Variables; if (argc != NotAssigned) { auto redirect{ ConvertEnumToWString(argc) }; if ( argc != FactorPolynomial and argc != FractElaborator and it != Fraction<>{} ) { tensor<long double> zero(Variables.size(), 0); ptrdiff_t Num{ 1 }, Den{ 1 }; for (size_t i = 0; i < it.num; ++i) Num *= it.num[i](zero); for (size_t i = 0; i < it.den; ++i) Den *= it.den[i](zero); if (Den == 0) { argc = NotAssigned; goto RETURN; } wchar_t sign = (Num > 0) xor (Den > 0) ? L : L; Num = abs(Num); Den = abs(Den); SendString( wstring(1, sign) + to_wstring(Num) + L + to_wstring(Den) ); INPUT inputs[2]{}; inputs[0].type = INPUT_KEYBOARD; inputs[0].ki.wVk = VK_RETURN; inputs[1] = inputs[0]; inputs[1].ki.dwFlags = KEYEVENTF_KEYUP; SendInput(2, inputs, sizeof(INPUT)); system(); SetConsoleTitle(redirect.c_str()); goto RETURN; } if (it.num != polynomial<>{ { { 0, tensor<int>(Variables.size(), 0) } } }) { bool saved{ BOOLALPHA }; BOOLALPHA = false; SendString(it.num.str()); if (argc != FactorPolynomial) { INPUT inputs[2]{}; inputs[0].type = INPUT_KEYBOARD; inputs[0].ki.wVk = VK_DOWN; inputs[0].ki.dwFlags = KEYEVENTF_EXTENDEDKEY; inputs[1] = inputs[0]; inputs[1].ki.dwFlags |= KEYEVENTF_KEYUP; SendInput(2, inputs, sizeof(INPUT)); SendString(it.den.str()); } BOOLALPHA = saved; INPUT inputs[2]{}; inputs[0].type = INPUT_KEYBOARD; inputs[0].ki.wVk = VK_RETURN; inputs[1] = inputs[0]; inputs[1].ki.dwFlags = KEYEVENTF_KEYUP; SendInput(2, inputs, sizeof(INPUT)); } system(); SetConsoleTitle(redirect.c_str()); goto RETURN; } if (it == Fraction<>{}) { if (err.empty()) break; if (err == L) { argc = Random; goto RETURN; } SetConsoleTextAttribute(hConsole, 4); wcout << L << err << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); startover = true; continue; } Fractions << it; if ((GetAsyncKeyState(VK_SHIFT) & 0x8000) and Fractions < 5) continue; bool Continue{ false }; wstring complete; for (auto& disp : VariablesDisposition) for (const auto& ch : disp) if (complete.find(ch) == wstring::npos) complete += ch; for (auto& disp : VariablesDisposition) for (const auto& ch : complete) if (disp.find(ch) == wstring::npos) disp += ch; or (auto& fraction : Fractions) { for (auto& fact : fraction.num) for (auto& mon : fact) mon.exp(complete.size()); for (auto& fact : fraction.den) for (auto& mon : fact) mon.exp(complete.size()); } tensor<int> ExpNull(complete.size(), 0); for (size_t i = 0; i < 2 * Fractions.size(); ++i) { if (VariablesDisposition[i / 2] == complete) continue; auto& old = i % 2 ? Fractions[i / 2].den : Fractions[i / 2].num; polynomial<> correct(old.size()); for (size_t j = 0; j < correct; ++j) for (const auto& mono : old[j]) correct[j] << monomial<>{ mono.coefficient, ExpNull }; for (size_t j = 0; j < VariablesDisposition[i / 2].size(); ++j) { auto pos{ complete.find(VariablesDisposition[i / 2].at(j)) }; if (pos == wstring::npos) continue; for (size_t k = 0; k < correct; ++k) for (size_t l = 0; l < correct[k]; ++l) correct[k][l].exp[pos] = old[k][l].exp[j]; } old = correct; } VariablesDisposition.clear(); if (Variables.size() > Fractions.size() + 1) { SetConsoleTextAttribute(hConsole, 12); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); startover = true; continue; } if (Fractions == 1 and !_equation) { auto It{ Fractions[0] }; f (!It.num.empty()) if (!It.num[0].empty()) if (It.num[0][0].coefficient == 0) break; if (!it.num.empty()) if (!it.num[0].empty()) if (it.num[0][0].coefficient == 0) break; CORRECTION_RATIO = 1; Fraction<> fraction; fraction.num = DecompPolynomial(usefree, it.num); big DenMultiplier = LCM; auto savx{ Variables }; fraction.den = DecompPolynomial(usefree, it.den); big NumMultiplier = LCM, GCD{ Gcd(NumMultiplier, DenMultiplier) }; NumMultiplier /= GCD; DenMultiplier /= GCD; auto nummultiplier{ NumMultiplier.Number<long double>() }; auto denmultiplier{ DenMultiplier.Number<long double>() }; if (!(fraction.num and fraction.den) or isnan(nummultiplier) or isnan(denmultiplier)) { wcout << L; SetConsoleTextAttribute(hConsole, 64); wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); wcout << L; goto insert; } auto Backup{ fraction }; int NCOEFF{ 1 }, DCOEFF{ 1 }; tensor<int> null(Variables.size(), 0); Simplify(fraction, NCOEFF, DCOEFF); NCOEFF *= nummultiplier; DCOEFF *= denmultiplier; LCM = 1; auto test{ fraction.num }; if (!(fraction.num or fraction.den)) charVariable = L; else if (fraction.num.empty()) test = fraction.den; if (fraction.num or fraction.den) for (size_t i = 0; i < Variables.size(); ++i) if (test[0][0].exp[i] != 0) charVariable = Variables.at(i); auto NScomp{ To1V(fraction.num) }; auto DScomp{ To1V(fraction.den) }; NScomp.close(); DScomp.close(); for (size_t i = 0; i < NScomp; ++i) NScomp[i].sort(); for (size_t i = 0; i < DScomp; ++i) DScomp[i].sort(); if (DScomp <= 1) skip = true; if (!skip) for (auto a : DScomp) for (auto b : a) if (a != 1 and b.degree > 1) skip = true; bool IsAModifier{ false }, HasMoreVariables{ false }; tensor<POLYNOMIAL<>> denominators; POLYNOMIAL<> complementaries; size_t index{}, size{}; int Det{ 1 }; Matrix<int> Matrix; tensor<int> results; tensor<double> roots; FACTOR<> Quotient, Rest; if (fraction.num != ToXV(NScomp) or fraction.den != ToXV(DScomp)) { skip = true; HasMoreVariables = true; goto PrintStatement; } if (!skip) for (size_t i = 0; i < DScomp; ++i) { if (DScomp[i][0].degree == -1) { IsAModifier = true; continue; } if (IsAModifier) for (ptrdiff_t j = DScomp[i - 1][0].coefficient; j > 0; --j) { denominators++; if (j > 1) denominators[index] << FACTOR<>{ { -1, (long double)j } }; denominators[index] << DScomp[i]; index++; complementaries << Complementary(DScomp, DScomp[i], j); } else if (DScomp[i] == 1) for (ptrdiff_t j = DScomp[i][0].degree; j > 0; --j) { denominators++; denominators[index] << FACTOR<>{ { (int)j, 1 } }; index++; auto NewScomp{ DScomp }; NewScomp.erase(NewScomp.begin() + i); NewScomp.insert(NewScomp.begin() + i, { { 1, 1 } }); NewScomp.insert(NewScomp.begin() + i, { { -1, (long double)DScomp[i][0].degree } }); complementaries << Complementary(NewScomp, NewScomp[i + 1], j); } else { denominators++; denominators[index] << DScomp[i]; index++; complementaries << Complementary(DScomp, DScomp[i], 1); } IsAModifier = false; } if (!skip) for (size_t i = 0; i < complementaries; ++i) complementaries[i].complete(complementaries.size()); if (!skip) { size = complementaries.size(); Matrix(size); for (size_t i = 0; i < complementaries; ++i) for (size_t j = 0; j < complementaries; ++j) Matrix[i] << complementaries[i][j].coefficient; } if (!skip) { PolynomialDivide( To1V(PolynomialMultiply, Polynomial(ToXV(PolynomialMultiply, NScomp))), V1converter(PolynomialMultiply, DScomp), Quotient, Rest ); Rest.complete(complementaries.size() - 1); Rest.sort(); for (const auto& R : Rest) results << R.coefficient; while (results.size() < complementaries.size()) results >> 0; Det = Matrix.det(); } if (!skip) for (size_t i = 0; i < results; ++i) { ::Matrix<int> MX{ Matrix }; MX[i] = results; roots << (double)MX.det() / Det; } for (ptrdiff_t i = denominators.size() - 1; i >= 0; --i) if (roots[i] == 0) { denominators.erase(denominators.begin() + i); roots.erase(roots.begin() + i); } if (roots.empty()) skip = true; PrintStatement: SetConsoleTextAttribute(hConsole, 11); wcout << L; SetConsoleTextAttribute(hConsole, 10); tensor<wstring> C_E_; bool HasBeenPrinted{ false }; COORD cursorPos; for (const auto& d : Backup.den) { auto Ctemp_{ EquationSolver(d) }; for (const auto& i : Ctemp_) C_E_ << i; } for (ptrdiff_t i = C_E_.size() - 1; i >= 0; --i) for (ptrdiff_t j = i - 1; j >= 0; --j) if (C_E_[i] == C_E_[j]) C_E_.erase(C_E_.begin() + i); for (auto I : C_E_) { wcout << Handler(I) << L; HasBeenPrinted = true; } if (!HasBeenPrinted) wcout << L; GetConsoleScreenBufferInfo(hConsole, &csbi)(); cursorPos = csbi.dwCursorPosition; if (!HasBeenPrinted) { cursorPos.X = 0; cursorPos.Y--; SetConsoleCursorPosition(hConsole, cursorPos); } else wcout << L; auto DiseqSol{ DisequationSolutionPrinter( fraction.num, fraction.den, 15, NCOEFF < 0 or DCOEFF < 0 ) }; if (!DiseqSol.empty()) wcout << L << DiseqSol << L; SetConsoleTextAttribute(hConsole, 10); wcout << L; SetConsoleTextAttribute(hConsole, 12); int lines{}; PrintFractionaryResult( NCOEFF, DCOEFF, lines, fraction, NScomp, DScomp, HasMoreVariables, !skip, roots, denominators ); if (!skip) for (const auto& a : Quotient) { auto rest{ POLYNOMIAL<>{ { a } } }; if (a.coefficient == 0) continue; if (integer(a.coefficient / CORRECTION_RATIO)) { rest[0][0].coefficient /= CORRECTION_RATIO; auto pol{ rest.str() }; ElabExponents(pol); bool IsMinus{ false }; if (pol.at(0) == L) { pol.erase(0, 1); IsMinus = true; } if (pol.size() >= 2) if (pol.at(0) == and Last(pol) == ) { pol.pop_back(); pol.erase(0, 1); } if (pol.at(0) == L) { pol.erase(0, 1); IsMinus = true; } else if (pol.at(0) == L) pol.erase(0, 1); IsMinus ? wcout << L : wcout << L; wcout << L << pol << L; lines += 2 + pol.size(); } else { GetConsoleScreenBufferInfo(hConsole, &csbi)(); COORD dwCursorPos{ csbi.dwCursorPosition }; dwCursorPos.Y--; SetConsoleCursorPosition(hConsole, dwCursorPos); PrintFraction( 1, 1, lines, true, { { { { a.coefficient, null } } }, { { { 1, null } } } } ); GetConsoleScreenBufferInfo(hConsole, &csbi)(); dwCursorPos = csbi.dwCursorPosition; dwCursorPos.Y++; SetConsoleCursorPosition(hConsole, dwCursorPos); wstring power; if (a.degree > 0) power += charVariable; if (a.degree > 1) { power += L + to_wstring(a.degree); ElabExponents(power); } wcout << L << power << L; } } wcout << L; if (_graph) switch (Variables.size()) { case 1: if (CreateGraph(Backup.extend())) while (CreateGraph()); break; case 2: Project3DGraph(Backup.extend()); break; } SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); startover = true; continue; } polynomial<> equations; for (const auto& eq : Fractions) equations << eq.num[0]; for (auto& equation : equations) for (auto& mono : equation) mono.exp(Variables.size(), 0); if (Variables.size() == Fractions and Fractions == 1) { charVariable = Variables.at(0); Variables = L; auto solutions{ RootExtractor(equations) }; Variables = wstring(1, charVariable); r (ptrdiff_t i = solutions.size() - 1; i >= 0; --i) for (ptrdiff_t j = i - 1; j >= 0; --j) if (solutions[i] == solutions[j]) solutions.erase(solutions.begin() + i); for (ptrdiff_t i = solutions.size() - 1; i >= 0; --i) for (const auto& fract : Fractions) if (fabs(fract.den[0]({ solutions[i] })) < 1e-05) solutions.erase(solutions.begin() + i); SetConsoleTextAttribute(hConsole, 11); wcout << L << solutions << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } if (Variables.size() <= equations) { to solutions{ SystemSolver(tensor<factor<>>( equations.begin(), equations.begin() + Variables.size() )) }; SetConsoleTextAttribute(hConsole, 11); if (isnan(solutions[0][0])) { wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } r (ptrdiff_t i = solutions.size() - 1; i >= 0; --i) { if (solutions[i].empty()) continue; for (const auto& fract : Fractions) if (fract.den[0](solutions[i]) < 1e-05) solutions.erase(solutions.begin() + i); } if (solutions.empty()) { wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } if (solutions[0].empty()) { wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } for (ptrdiff_t i = solutions.size() - 1; i >= 0; --i) for (size_t j = Variables.size(); j < equations; ++j) if (fabs(equations[j](solutions[i])) > 1e-05) { solutions.erase(solutions.begin() + i); break; }  (solutions.empty()) { wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } wcout << L; for (const auto& sol : solutions) { wcout << L; for (size_t i = 0; i < Variables.size(); ++i) { wcout << L << Variables.at(i); wcout << L << sol[i] << L; } wcout << L; } SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } int pIndex{ -1 }; wstring VarOrder; tensor<int> VariablePos; const wstring VariablePriority{ L }; for (const auto& var : VariablePriority) { auto pos{ Variables.find(var) }; if (pos != wstring::npos) { VarOrder += var; VariablePos << pos; } } ptrdiff_t ParameterIndex = VarOrder.size() - 1; for (; ParameterIndex >= 0; --ParameterIndex) { for (const auto& eq : equations) { for (size_t i = 0; i < eq; ++i) { int deg{}; for (size_t j = 0; j < VarOrder.size(); ++j) { if (j == ParameterIndex) continue; deg += eq[i].exp[VariablePos[j]]; } if (deg > 1) { Continue = true; break; } } if (Continue) break; } if (Continue) { Continue = false; continue; } pIndex = VariablePos[ParameterIndex]; charVariable = Variables.at(pIndex); break; } if (pIndex < 0) { Fractions.clear(); equations.clear(); startover = true; continue; } size_t Vsize{ Variables.size() }, I{}; tensor<int> null(Vsize, 0); tensor<factor<>> KnownTerms(Vsize); for (size_t i = 0; i < equations;) { if (I == pIndex) { I++; continue; } for (size_t j = 0; j < equations[i]; ++j) { auto exps{ equations[i][j].exp }; exps[pIndex] = 0; if (exps == null) { auto mon{ equations[i][j] }; mon.coefficient *= -1; KnownTerms[I] << mon; } } i++; I++; } I = 0; bool Break{ false }; Matrix<factor<>> system(Vsize, tensor<factor<>>(Vsize)); for (size_t i = 0; i < equations;) { for (size_t j = 0; j < equations[i]; ++j) { for (size_t k = 0; k < Vsize; ++k) { if (I == pIndex) { I++; Break = true; break; } if (k == pIndex) continue; auto mon{ equations[i][j] }; mon.exp[k] = 0; if (equations[i][j].exp[k] != 0) system[k][I] << mon; } if (Break) break; } if (Break) { Break = false; continue; } I++; i++; } KnownTerms.erase(KnownTerms.begin() + pIndex); system.erase(system.begin() + pIndex); for (auto& eq : system) eq.erase(eq.begin() + pIndex); tensor<Fraction<>> solve; tensor<polynomial<>> dets; auto D{ DecompPolynomial(usefree, system.det()) }; auto ProblematicPoints{ RootExtractor(D) }; tensor<long double> Zeros; for (size_t i = 0; i < Vsize - 1; ++i) { to mx{ system }; mx[i] = KnownTerms; dets << DecompPolynomial(usefree, mx.det()); to NewZeros{ RootExtractor(dets.last()) }; for (const auto& zero : NewZeros) { tinue = false; for (const auto& OtherZero : Zeros) if (fabs(OtherZero - zero) < 1e-05) { Continue = true; break; } if (Continue) continue; Zeros << zero; } } if (D.empty()) { SetConsoleTextAttribute(hConsole, 11);  (dets == tensor<polynomial<>>(dets.size())) { wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; continue; } for (const auto& det : dets) solve << Fraction<>{ det, D }; wcout << L; int line{}; bool skipped{ false }; for (size_t i = 0; i < Vsize; ++i) { if (i == pIndex) { skipped = true; continue; } int ncoeff{ 1 }, dcoeff{ 1 }; auto& resolution{ solve[i - skipped] }; Simplify(resolution, ncoeff, dcoeff); auto NScomp{ To1V(resolution.num) }; auto DScomp{ To1V(resolution.den) }; NScomp.close(); DScomp.close(); for (size_t j = 0; j < NScomp; ++j) NScomp[j].sort(); for (size_t j = 0; j < DScomp; ++j) DScomp[j].sort(); SetConsoleTextAttribute(hConsole, 11); wcout << Variables.at(i) << L; PrintFractionaryResult( ncoeff, dcoeff, line, resolution, NScomp, DScomp, resolution.num != ToXV(NScomp) or resolution.den != ToXV(DScomp) ); wcout << L; if (i != Vsize - 1) wcout << L; } ool starting{ true }; SetConsoleTextAttribute(hConsole, 6); for (const auto& p : ProblematicPoints) { Continue = false; for (const auto& zero : Zeros) if (fabs(p - zero) < 1e-05) { if (starting) { starting = false; wcout << L; } wcout << L << charVariable << L << Handler(to_wstring(p)); wcout << L; Continue = true; } if (Continue) continue; if (starting) { starting = false; wcout << L; } wcout << L << charVariable << L << Handler(to_wstring(p)); wcout << L; } SetConsoleTextAttribute(hConsole, 15)(); Fractions.clear(); equations.clear(); startover = true; } argc = NotAssigned; RETURN: { lock_guard<mutex> lk(MonitorMTX); RunMonitor = false; } MonitorCV.notify_all(); } static void DecompMatrices(switchcase& argc) { setlocale(LC_ALL, ); SetConsoleOutputCP(CP_UTF8); SetConsoleCP(CP_UTF8); wcout.imbue(locale()); SetConsoleTextAttribute(hConsole, 14); wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 12); wcout << L; wcout << L; wcout << L; wcout << L; wcout << L; SetConsoleTextAttribute(hConsole, 15)(); Matrix<> matrix, Mx; for (;;) { SetConsoleTextAttribute(hConsole, 15)(); wcout << L; for (;;) { wstring err; if (matrix.input(err)) break; wcout << L; SetConsoleTextAttribute(hConsole, 4); wcout << err << L; SetConsoleTextAttribute(hConsole, 15)(); } size_t size{ matrix.size() }; if (size == 0) { argc = Random; goto RETURN; } if (matrix == Matrix<>(size, tensor<long double>(size, 0))) break; Mx = matrix; SetConsoleTextAttribute(hConsole, 2); wcout << L; matrix.output({ 0, -2 }, __NULL__, 2); wcout << L; SetConsoleTextAttribute(hConsole, 15)(); auto Id{ Matrix<>(size, tensor<long double>(size, 0)) }; for (size_t i = 0; i < size; ++i) Id[i][i] = 1; auto permutator{ Id }; for (size_t i = 0; i + 1 < size; ++i) { int max = Mx[size - 1][i], IndexofMax = size - 1; for (ptrdiff_t j = size - 2; j >= i; --j) { if (j < 0) break; if (Mx[j][i] > max) { max = Mx[j][i]; IndexofMax = j; } } if (IndexofMax != i) { swap(Mx[IndexofMax], Mx[i]); swap(permutator[IndexofMax], permutator[i]); } } auto NewPermutator{ Matrix<>(size) }; for (size_t i = 0; i < size; ++i) for (size_t j = 0; j < size; ++j) NewPermutator[i] << permutator[j][i]; permutator = NewPermutator; auto lower{ Id }; auto upper{ Mx }; bool Break{ false }; for (size_t i = 0; i + 1 < size; ++i) { r (size_t j = i + 1; j < size; ++j) { (upper[i][i] == 0) { Break = true; break; } lower[j][i] = upper[j][i] / upper[i][i]; for (size_t k = 0; k < size; ++k) upper[j][k] -= lower[j][i] * upper[i][k]; } if (Break) break; } if (!Break) { wcout << L; permutator.DisplayWith(lower, upper); } Mx = matrix; auto ortogonal{ Id }; Break = false; for (size_t i = 0; i < size; ++i) { for (size_t j = i + 1; j < size; ++j) if (Mx[j][i] != 0) { long double norm{ hypot(Mx[j][i], Mx[j - 1][i]) }; if (norm == 0) { Break = true; break; } long double cosine{ Mx[j - 1][i] / norm }, sine{ Mx[j][i] / norm }; auto givens{ Id }; givens[i][i] = cosine; givens[i][j] = sine; givens[j][i] = -sine; givens[j][j] = cosine; Mx = givens * Mx; ortogonal *= givens; } if (Break) break; } if (!Break) { wcout << L; ortogonal.DisplayWith(Mx); } Mx = matrix; lower = Id; Break = false; for (size_t i = 0; i < size; ++i) { for (size_t j = 0; j <= i; ++j) { double sum{}; if (i == j) { for (size_t k = 0; k < i; ++k) sum += lower[i][k] * lower[i][k]; lower[i][i] = sqrt(Mx[i][i] - sum); } if (lower[i][i] == 0 or isnan(lower[i][i])) { Break = true; break; } if (i != j) { for (size_t k = 0; k < i; ++k) sum += lower[i][k] * lower[j][k]; lower[i][j] = (Mx[i][j] - sum) / lower[j][j]; } } if (Break) break; } auto lowerT{ Matrix<>(size) }; if (!Break) for (size_t i = 0; i < size; ++i) for (size_t j = 0; j < size; ++j) lowerT[i] << lower[j][i]; if (!Break) { wcout << L; lower.DisplayWith(lowerT); } Mx = matrix; auto MxT{ Id }; for (size_t i = 0; i < size; ++i) for (size_t j = 0; j < size; ++j) MxT[i][j] = Mx[j][i]; auto Mx_MxT{ Mx * MxT }; auto MxT_Mx{ MxT * Mx }; auto EigenV{ Mx_MxT.EigenValues() }; auto sigma{ Id }; Break = EigenV.size() != size; Matrix<> U, V; if (!Break) { for (size_t i = 0; i < size; ++i) sigma[i][i] = sqrt(EigenV[i]); U = Mx_MxT.EigenVectors(EigenV); V = MxT_Mx.EigenVectors(); if (V.empty()) Break = true; else { auto NewV{ Id }; for (size_t i = 0; i < size; ++i) for (size_t j = 0; j < size; ++j) NewV[i][j] = V[j][i]; V = NewV; } } if (!Break) { wcout << L; U.DisplayWith(sigma, V); } auto maindet{ matrix.det() }; wcout << L << maindet << L; auto eigenvalues{ matrix.EigenValues() }; wcout << L << eigenvalues << L; auto eigenvectors{ matrix.EigenVectors(eigenvalues) }; if (eigenvectors == size) { wcout << L; for (auto vector : eigenvectors) wcout << vector << L; wcout << L; } if (maindet == 0) { wstring varlist{ L }; tensor<double> solutionList; auto NewMatrix{ matrix }; for (auto& row : NewMatrix) row--; NewMatrix--; auto newdet{ NewMatrix.det() }; if (newdet == 0) continue; for (size_t i = 0; i < size - 1; ++i) { Mx = NewMatrix; for (size_t j = 0; j < size - 1; ++j) Mx[j][i] = matrix[j].last(); solutionList << Mx.det() / newdet; } wcout << L; for (size_t i = 0; i < size - 1; ++i) wcout << varlist[i] << L << solutionList[i] << L; wcout << L; } } argc = NotAssigned; RETURN: { lock_guard<mutex> lk(MonitorMTX); RunMonitor = false; } MonitorCV.notify_all(); } 